Conte√∫do de app.py:
from flask import Flask, render_template, request, jsonify, Response
import json
from datetime import datetime
import requests
from backend.database.database import init_db, get_db
from backend.utils.chat_history import save_conversation, get_conversation_history
from backend.utils.text_processor import split_text
from backend.routers.chats import chats_bp
from backend.models.conversations import Conversation
import logging

logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

app = Flask(__name__, static_folder='static')
app.secret_key = 'sua_chave_secreta_aqui'

init_db()
app.register_blueprint(chats_bp, url_prefix='/api/chats')

API_URL = "http://localhost:11434/v1/chat/completions"
MODEL_NAME = "gemma2:2b"

@app.route('/')
def home():
    try:
        logger.debug("Iniciando carregamento do hist√≥rico de conversas...")
        conversations = get_conversation_history()
        logger.debug(f"Hist√≥rico carregado com sucesso: {len(conversations)} conversas encontradas")
        logger.debug(f"Dados das conversas: {json.dumps(conversations, indent=2)}")
        return render_template('index.html', conversations=conversations)
    except Exception as e:
        logger.error(f"Erro ao carregar hist√≥rico de conversas: {str(e)}", exc_info=True)
        return render_template('index.html', conversations=[])

@app.route('/send_message', methods=['POST'])
def send_message():
    try:
        data = request.json
        message = data.get('message', '')
        conversation_id = data.get('conversation_id')
        
        logger.debug(f"Recebida mensagem para conversation_id: {conversation_id}")
        logger.debug(f"Conte√∫do da mensagem: {message}")

        if not conversation_id:
            logger.debug("Criando nova conversa...")
            conversation = Conversation(title="Nova Conversa")
            with get_db() as db:
                db.add(conversation)
                db.commit()
                conversation_id = conversation.id
                logger.debug(f"Nova conversa criada com ID: {conversation_id}")

        def generate_streamed_response():
            accumulated_response = ""
            for part in process_with_ai_stream(message):
                accumulated_response += part
                yield f"data: {json.dumps({'content': part})}\n\n"
            
            logger.debug(f"Salvando conversa {conversation_id}")
            logger.debug(f"Mensagem do usu√°rio: {message}")
            logger.debug(f"Resposta acumulada: {accumulated_response}")
            
            saved_id = save_conversation(message, accumulated_response, conversation_id)
            logger.debug(f"Conversa salva com ID: {saved_id}")

        response = Response(generate_streamed_response(), content_type="text/event-stream")
        response.headers['Cache-Control'] = 'no-cache'
        return response

    except Exception as e:
        logger.error(f"Erro ao processar mensagem: {str(e)}", exc_info=True)
        return jsonify({"error": str(e)}), 500

def process_with_ai(text):
    try:
        payload = {
            "model": MODEL_NAME,
            "messages": [
                {"role": "system", "content": "Voc√™ √© um assistente √∫til."},
                {"role": "user", "content": text}
            ],
            "stream": False
        }
        headers = {"Content-Type": "application/json"}
        response = requests.post(API_URL, json=payload, headers=headers)
        response.raise_for_status()

        response_data = response.json()
        if 'choices' in response_data and len(response_data['choices']) > 0:
            return response_data['choices'][0]['message']['content']
        return "Erro: Nenhuma resposta v√°lida recebida da IA."
    except requests.exceptions.RequestException as e:
        print(f"[Debug] Erro na requisi√ß√£o HTTP: {str(e)}")
        return "Ocorreu um erro ao se conectar com a IA."
    except Exception as e:
        print(f"[Debug] Erro inesperado: {str(e)}")
        return "Ocorreu um erro inesperado ao processar sua mensagem."

def process_with_ai_stream(text):
    try:
        payload = {
            "model": MODEL_NAME,
            "messages": [
                {"role": "system", "content": "Voc√™ √© um assistente √∫til."},
                {"role": "user", "content": text}
            ],
            "stream": True
        }
        headers = {"Content-Type": "application/json"}
        response = requests.post(API_URL, json=payload, headers=headers, stream=True)
        response.raise_for_status()

        for line in response.iter_lines(decode_unicode=True):
            if line.strip() and line.startswith("data: "):
                line = line[6:].strip()
                try:
                    response_data = json.loads(line)
                    if 'choices' in response_data and len(response_data['choices']) > 0:
                        delta = response_data['choices'][0]['delta']
                        if "content" in delta:
                            content = delta["content"].encode('latin1').decode('utf-8', errors='ignore')
                            yield content
                except json.JSONDecodeError:
                    print(f"[Debug] Erro ao decodificar JSON: {line}")
    except requests.exceptions.RequestException as e:
        print(f"[Debug] Erro na requisi√ß√£o HTTP: {str(e)}")
    except Exception as e:
        print(f"[Debug] Erro inesperado: {str(e)}")

if __name__ == '__main__':
    app.run(debug=True)


Conte√∫do de database.py:
import sqlite3
from contextlib import contextmanager
import os
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from sqlalchemy.ext.declarative import declarative_base

DATABASE_PATH = 'backend/database/nosso_projeto.db'

def ensure_data_directory():
    """Garante que o diret√≥rio data/ existe"""
    os.makedirs('backend/database', exist_ok=True)

# Configura√ß√£o SQLAlchemy
SQLALCHEMY_DATABASE_URL = f"sqlite:///{DATABASE_PATH}"
engine = create_engine(SQLALCHEMY_DATABASE_URL)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

def init_db():
    """Inicializa o banco de dados e cria as tabelas se n√£o existirem"""
    ensure_data_directory()
    Base.metadata.create_all(bind=engine)

@contextmanager
def get_db():
    """Context manager para conex√£o com o banco"""
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

Conte√∫do de conversations.py:
from sqlalchemy import Column, String, DateTime, Text
from backend.database.database import Base
from datetime import datetime
import uuid

class Conversation(Base):
    __tablename__ = "conversations"
    
    id = Column(String(36), primary_key=True, default=lambda: str(uuid.uuid4()))
    title = Column(String(255), nullable=False)
    timestamp = Column(DateTime(timezone=True), default=datetime.utcnow)
    meta = Column(Text, default='{}')

    @staticmethod
    def create(title="Nova Conversa"):
        """Cria uma nova conversa"""
        from backend.database.database import SessionLocal
        
        db = SessionLocal()
        try:
            conversation = Conversation(title=title)
            db.add(conversation)
            db.commit()
            db.refresh(conversation)
            return conversation.id
        finally:
            db.close()

    @staticmethod
    def get_all():
        """Retorna todas as conversas"""
        from backend.database.database import SessionLocal
        
        db = SessionLocal()
        try:
            return db.query(Conversation).order_by(Conversation.timestamp.desc()).all()
        finally:
            db.close()

    @staticmethod
    def get_by_id(conversation_id):
        """Busca uma conversa espec√≠fica pelo ID"""
        from backend.database.database import SessionLocal
        
        db = SessionLocal()
        try:
            return db.query(Conversation).filter_by(id=conversation_id).first()
        finally:
            db.close()

    @staticmethod
    def delete(conversation_id):
        """Deleta uma conversa e suas mensagens"""
        from backend.database.database import SessionLocal
        
        db = SessionLocal()
        try:
            conversation = db.query(Conversation).filter_by(id=conversation_id).first()
            if conversation:
                db.delete(conversation)
                db.commit()
                return True
            return False
        finally:
            db.close()

Conte√∫do de messages.py:
from sqlalchemy import Column, String, DateTime, ForeignKey, Text
from sqlalchemy.orm import relationship
from backend.database.database import Base
from datetime import datetime
import uuid

class Message(Base):
    __tablename__ = "messages"
    
    id = Column(String(36), primary_key=True, default=lambda: str(uuid.uuid4()))
    conversation_id = Column(String(36), ForeignKey('conversations.id', ondelete='CASCADE'))
    role = Column(String(50), nullable=False)
    content = Column(Text, nullable=False)
    timestamp = Column(DateTime(timezone=True), default=datetime.utcnow)
    
    conversation = relationship("Conversation", backref="messages")

    @staticmethod
    def create(conversation_id, role, content):
        """Cria uma nova mensagem"""
        from backend.database.database import SessionLocal
        
        db = SessionLocal()
        try:
            message = Message(
                conversation_id=conversation_id,
                role=role,
                content=content
            )
            db.add(message)
            db.commit()
            db.refresh(message)
            return message.id
        finally:
            db.close()

    @staticmethod
    def get_by_conversation(conversation_id):
        """Retorna todas as mensagens de uma conversa"""
        from backend.database.database import SessionLocal
        
        db = SessionLocal()
        try:
            return db.query(Message)\
                .filter_by(conversation_id=conversation_id)\
                .order_by(Message.timestamp.asc())\
                .all()
        finally:
            db.close()

Conte√∫do de chats.py:
from flask import Blueprint, jsonify, request
from backend.models.conversations import Conversation
from backend.models.messages import Message

chats_bp = Blueprint('chats', __name__)

@chats_bp.route('/conversations', methods=['GET'])
def get_conversations():
    """Retorna lista de todas as conversas"""
    conversations = Conversation.get_all()
    return jsonify([dict(conv) for conv in conversations])

@chats_bp.route('/conversations', methods=['POST'])
def create_conversation():
    """Cria uma nova conversa"""
    data = request.json
    title = data.get('title', 'Nova Conversa')
    conversation_id = Conversation.create(title)
    return jsonify({'id': conversation_id})

@chats_bp.route('/conversations/<conversation_id>', methods=['GET'])
def get_conversation(conversation_id):
    """Retorna uma conversa espec√≠fica com suas mensagens"""
    conversation = Conversation.get_by_id(conversation_id)
    if not conversation:
        return jsonify({'error': 'Conversa n√£o encontrada'}), 404
        
    messages = Message.get_by_conversation(conversation_id)
    return jsonify({
        'conversation': dict(conversation),
        'messages': [dict(msg) for msg in messages]
    })

@chats_bp.route('/conversations/<conversation_id>/messages', methods=['POST'])
def add_message(conversation_id):
    """Adiciona uma nova mensagem a uma conversa"""
    data = request.json
    role = data.get('role')
    content = data.get('content')
    
    if not all([role, content]):
        return jsonify({'error': 'Dados incompletos'}), 400
        
    message_id = Message.create(conversation_id, role, content)
    return jsonify({'id': message_id})

@chats_bp.route('/conversations/<conversation_id>', methods=['DELETE'])
def delete_conversation(conversation_id):
    """Deleta uma conversa e suas mensagens"""
    if Conversation.delete(conversation_id):
        return jsonify({'success': True})
    return jsonify({'error': 'Erro ao deletar conversa'}), 400

Conte√∫do de chat_history.py:
from datetime import datetime
from backend.database.database import get_db
from backend.models.conversations import Conversation
from backend.models.messages import Message
import logging
import json

logger = logging.getLogger(__name__)

def save_conversation(message, response, conversation_id=None):
    """
    Salva ou atualiza uma conversa no banco de dados.
    """
    try:
        logger.debug(f"Iniciando salvamento de conversa. ID: {conversation_id}")
        logger.debug(f"Mensagem: {message}")
        logger.debug(f"Resposta: {response}")

        with get_db() as db:
            if not conversation_id:
                logger.debug("Criando nova conversa...")
                conversation = Conversation(title="Nova Conversa")
                db.add(conversation)
                db.commit()
                conversation_id = conversation.id
                logger.debug(f"Nova conversa criada com ID: {conversation_id}")
            else:
                logger.debug(f"Buscando conversa existente com ID: {conversation_id}")
                conversation = db.query(Conversation).filter_by(id=conversation_id).first()
                if not conversation:
                    logger.warning(f"Conversa {conversation_id} n√£o encontrada, criando nova")
                    conversation = Conversation(title="Nova Conversa")
                    db.add(conversation)
                    db.commit()
                    conversation_id = conversation.id

            # Salva a mensagem do usu√°rio
            user_message = Message(
                conversation_id=conversation_id,
                role='user',
                content=message
            )
            db.add(user_message)
            logger.debug(f"Mensagem do usu√°rio salva para conversa {conversation_id}")
            
            # Salva a resposta do assistente
            assistant_message = Message(
                conversation_id=conversation_id,
                role='assistant',
                content=response
            )
            db.add(assistant_message)
            logger.debug(f"Resposta do assistente salva para conversa {conversation_id}")
            
            db.commit()
            logger.debug(f"Todas as mensagens salvas com sucesso para conversa {conversation_id}")
            
            return conversation_id
            
    except Exception as e:
        logger.error(f"Erro ao salvar conversa: {str(e)}", exc_info=True)
        raise

def get_conversation_history():
    """Retorna o hist√≥rico completo de conversas com suas mensagens"""
    try:
        logger.debug("Iniciando carregamento do hist√≥rico de conversas")
        with get_db() as db:
            conversations = db.query(Conversation).order_by(Conversation.timestamp.desc()).all()
            history = []
            
            for conv in conversations:
                logger.debug(f"Carregando mensagens para conversa {conv.id}")
                messages = db.query(Message).filter_by(conversation_id=conv.id).order_by(Message.timestamp).all()
                
                conversation_data = {
                    'id': conv.id,
                    'title': conv.title,
                    'timestamp': conv.timestamp.isoformat(),
                    'messages': [{
                        'role': msg.role,
                        'content': msg.content,
                        'timestamp': msg.timestamp.isoformat()
                    } for msg in messages]
                }
                history.append(conversation_data)
                logger.debug(f"Conversa {conv.id} carregada com {len(messages)} mensagens")
            
            logger.debug(f"Total de {len(history)} conversas carregadas")
            logger.debug(f"Dados completos do hist√≥rico: {json.dumps(history, indent=2)}")
            return history
            
    except Exception as e:
        logger.error(f"Erro ao carregar hist√≥rico: {str(e)}", exc_info=True)
        return []

Conte√∫do de text_processor.py:
def split_text(text, words_per_chunk=300):
    """
    Divide um texto em chunks menores baseado no n√∫mero de palavras.
    """
    words = text.split()
    chunks = []
    
    for i in range(0, len(words), words_per_chunk):
        chunk = ' '.join(words[i:i + words_per_chunk])
        chunks.append(chunk)
    
    return chunks

Conte√∫do de __init__.py:
# Este arquivo vazio torna o diret√≥rio utils um m√≥dulo Python

Conte√∫do de __init__.py:
# Este arquivo vazio torna o diret√≥rio backend um m√≥dulo Python

Conte√∫do de README.md:
Aqui est√° uma vers√£o refinada da apresenta√ß√£o do Projeto Guilherme, estruturada para que possa ser utilizada em qualquer contexto, seja para explicar a um humano ou a outra IA. Tamb√©m inclu√≠ as fases do desenvolvimento e os pr√≥ximos passos, garantindo que todas as informa√ß√µes estejam bem organizadas.

Projeto Guilherme ‚Äì Clone de IA Conversacional Baseado em OpenWebUI
Introdu√ß√£o
O Projeto Guilherme √© um sistema de intelig√™ncia artificial conversacional, inspirado no OpenWebUI, que tem como principal objetivo criar uma interface de chat interativa e persistente, semelhante ao ChatGPT. O foco inicial do projeto est√° na armazenagem do hist√≥rico de conversas utilizando um banco de dados relacional (SQLite e posteriormente PostgreSQL). No futuro, pretendemos integrar um sistema de RAG (Retrieval-Augmented Generation), que permitir√° √† IA recuperar informa√ß√µes relevantes e contextualizadas, aprimorando a qualidade das respostas.

O Projeto Guilherme est√° sendo desenvolvido por tr√™s agentes:

O usu√°rio (voc√™), que atua como arquiteto do sistema e toma decis√µes estrat√©gicas.
ChatGPT (eu), auxiliando na organiza√ß√£o, estrutura√ß√£o e planejamento do projeto.
IA Lovable, que analisa a estrutura do OpenWebUI e fornece insights sobre a implementa√ß√£o.
O desenvolvimento segue um modelo iterativo, garantindo que cada etapa esteja funcional antes de avan√ßarmos para a pr√≥xima.

Objetivo do Projeto
O Projeto Guilherme tem como objetivo principal desenvolver uma IA conversacional independente, capaz de interagir com os usu√°rios de forma natural, armazenar o hist√≥rico de mensagens e fornecer respostas contextualizadas utilizando t√©cnicas avan√ßadas de recupera√ß√£o de informa√ß√µes.

Os principais desafios que buscamos resolver s√£o:

Persist√™ncia de Mem√≥ria: Criar um banco de dados que armazene corretamente o hist√≥rico de conversas, garantindo que ele possa ser recuperado ap√≥s o recarregamento da p√°gina.
Gerenciamento Eficiente de Dados: Implementar um CRUD robusto e escal√°vel para manter as intera√ß√µes do usu√°rio.
Implementa√ß√£o do RAG: Utilizar um banco de dados vetorial para buscar informa√ß√µes relevantes e melhorar o contexto das respostas.
Escalabilidade: Construir um sistema modular e bem estruturado que possa crescer sem grandes reescritas.
Seguran√ßa e Performance: Garantir a prote√ß√£o dos dados, evitar vazamentos e otimizar o desempenho do sistema.
Tecnologias Utilizadas
O projeto est√° sendo desenvolvido com um stack tecnol√≥gico moderno, baseado em:

Flask (Python) ‚Üí Backend leve e eficiente para gerenciar as requisi√ß√µes e a l√≥gica do chat.
SQLAlchemy + SQLite (futuro PostgreSQL) ‚Üí Banco de dados relacional para armazenar conversas e mensagens.
JavaScript, HTML5, CSS ‚Üí Constru√ß√£o da interface de usu√°rio responsiva e din√¢mica.
FastAPI (poss√≠vel migra√ß√£o futura) ‚Üí Melhor desempenho para lidar com requisi√ß√µes ass√≠ncronas.
Banco Vetorial (ChromaDB, Milvus ou PGVector - a definir) ‚Üí Armazenamento de embeddings para melhorar o contexto da IA.
Estrutura do Projeto
O Projeto Guilherme segue uma estrutura modular, inspirada no OpenWebUI, para facilitar a manuten√ß√£o e escalabilidade:

graphql
Copiar
Editar
Projeto Guilherme/
‚îú‚îÄ‚îÄ app.py                     # Aplica√ß√£o principal
‚îú‚îÄ‚îÄ backend/
‚îÇ   ‚îú‚îÄ‚îÄ database/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py        # Torna a pasta um m√≥dulo
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ database.py        # Gerenciamento da conex√£o e opera√ß√µes com SQLite
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ migrations/        # Scripts de migra√ß√£o (ex: Alembic)
‚îÇ   ‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ conversations.py   # Modelo de dados para conversas
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ messages.py        # Modelo de dados para mensagens (vinculadas √†s conversas)
‚îÇ   ‚îú‚îÄ‚îÄ routers/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ chats.py           # Endpoints REST para manipula√ß√£o de conversas e mensagens
‚îÇ   ‚îî‚îÄ‚îÄ utils/
‚îÇ       ‚îú‚îÄ‚îÄ chat_history.py    # Fun√ß√µes para gerenciamento do hist√≥rico de conversas
‚îÇ       ‚îî‚îÄ‚îÄ text_processor.py  # Utilit√°rios para processamento de texto (ex: dividir mensagens longas)
‚îî‚îÄ‚îÄ requirements.txt           # Lista de depend√™ncias do projeto
Essa estrutura reflete a separa√ß√£o de responsabilidades, garantindo que cada funcionalidade tenha um m√≥dulo bem definido.

Fases do Desenvolvimento e Etapas
Estamos seguindo um planejamento em fases, garantindo que cada funcionalidade seja bem implementada antes de avan√ßarmos para a pr√≥xima.

Fase 1: Implementa√ß√£o do CRUD com SQLite (Em Andamento)
‚úÖ Criar um banco de dados para armazenar conversas e mensagens.
‚úÖ Criar endpoints REST para manipular o hist√≥rico de conversas.
‚úÖ Garantir que os dados sejam persistidos corretamente ap√≥s o reload da p√°gina.
üîπ Configurar Alembic para gerenciar as migra√ß√µes do banco de dados.
üîπ Testar e corrigir eventuais falhas no CRUD.

Fase 2: Prepara√ß√£o para a Migra√ß√£o para PostgreSQL
üîπ Configurar um ambiente PostgreSQL local para testes.
üîπ Garantir que o c√≥digo esteja preparado para a migra√ß√£o sem precisar de grandes reescritas.
üîπ Migrar os dados do SQLite para o PostgreSQL gradualmente.

Fase 3: Implementa√ß√£o do RAG com Banco de Dados Vetorial
üîπ Escolher um banco de dados vetorial (ChromaDB, Milvus ou PGVector).
üîπ Criar um sistema para transformar mensagens em embeddings.
üîπ Integrar a recupera√ß√£o de contexto ao fluxo da IA.
üîπ Implementar um mecanismo de busca sem√¢ntica para melhorar a precis√£o das respostas.

Fase 4: Seguran√ßa, Performance e Testes
üîπ Implementar autentica√ß√£o e controle de acessos, se necess√°rio.
üîπ Adicionar cache para otimizar as buscas e evitar sobrecarga no banco.
üîπ Criar testes automatizados para validar o funcionamento do sistema.
üîπ Otimizar a performance para suportar m√∫ltiplas intera√ß√µes simult√¢neas.

Status Atual do Desenvolvimento
üöÄ Atualmente, estamos na Fase 1 (CRUD com SQLite), e nosso foco √© corrigir o problema de persist√™ncia de mensagens.

üö® Problema Atual:

As mensagens est√£o sendo armazenadas temporariamente e desaparecem ap√≥s o recarregamento da p√°gina.
‚úÖ O que j√° foi feito:

Criamos as tabelas no SQLite.
Implementamos o sistema CRUD para salvar e recuperar conversas.
üîç O que precisa ser corrigido:

Revisar a configura√ß√£o do Alembic para garantir que as migra√ß√µes estejam funcionando corretamente.
Testar se os dados est√£o realmente sendo persistidos no banco e corrigir falhas no carregamento das mensagens.
Conclus√£o e Pr√≥ximos Passos
O Projeto Guilherme est√° sendo desenvolvido de forma estruturada e iterativa, garantindo que cada funcionalidade seja implementada corretamente antes de avan√ßarmos para o pr√≥ximo est√°gio.

üìå Pr√≥ximo Passo Imediato:

Corrigir a persist√™ncia das mensagens no SQLite antes de iniciar a migra√ß√£o para PostgreSQL.
üìå Pr√≥ximo Grande Passo:

Configurar um ambiente PostgreSQL para testes e preparar a transi√ß√£o do banco de dados.
Com esse planejamento, garantimos que o projeto evolua de forma s√≥lida, evitando retrabalho e garantindo que cada etapa seja bem implementada. Agora, podemos continuar nossa conversa no novo chat sem perder o contexto do desenvolvimento! üöÄ

# Documenta√ß√£o T√©cnica do ChatAI

![Arquitetura do Sistema](https://via.placeholder.com/800x400?text=Diagrama+de+Arquitetura+do+Sistema)  
*Diagrama simplificado do fluxo de dados e componentes principais*

## 1. Vis√£o T√©cnica do Sistema

### 1.1 Stack Tecnol√≥gica
- **Backend**: Flask 2.0.2
- **Banco de Dados**: SQLite (Desenvolvimento), PostgreSQL (Produ√ß√£o)
- **ORM**: SQLAlchemy 1.4
- **Processamento de Texto**: NLTK 3.6.7
- **Interface**: HTML5, Bootstrap 5.1, JavaScript ES6
- **Gerenciamento de Pacotes**: Poetry 1.2

### 1.2 Princ√≠pios de Design
- Padr√£o MVC (Model-View-Controller)
- Inje√ß√£o de Depend√™ncia para gest√£o de banco de dados
- RESTful API design
- Princ√≠pios SOLID para estrutura√ß√£o de classes

## 2. Estrutura do Projeto (Detalhada)

```
ChatAI/
‚îú‚îÄ‚îÄ app.py                     # Ponto de entrada principal
‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py            # Configura√ß√µes de ambiente
‚îÇ   ‚îú‚îÄ‚îÄ settings.py            # Par√¢metros de configura√ß√£o
‚îÇ   ‚îî‚îÄ‚îÄ constants.py           # Constantes globais
‚îú‚îÄ‚îÄ backend/
‚îÇ   ‚îú‚îÄ‚îÄ database/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ connectors.py      # Implementa√ß√µes de conex√£o
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ crud.py            # Opera√ß√µes CRUD gen√©ricas
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ migrations/        # Alembic migrations
‚îÇ   ‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ base.py            # Modelo base SQLAlchemy
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ conversation.py    # Entidade Conversation
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ message.py         # Entidade Message
‚îÇ   ‚îú‚îÄ‚îÄ routes/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ v1/           # Versionamento de API
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ chats.py   # Endpoints REST
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ web.py             # Rotas web
‚îÇ   ‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ai_processor.py    # Integra√ß√£o com IA
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ history_manager.py # Gest√£o de hist√≥rico
‚îÇ   ‚îî‚îÄ‚îÄ utils/
‚îÇ       ‚îú‚îÄ‚îÄ decorators.py      # Decoradores customizados
‚îÇ       ‚îî‚îÄ‚îÄ validators.py      # Valida√ß√£o de dados
‚îú‚îÄ‚îÄ static/
‚îÇ   ‚îú‚îÄ‚îÄ css/                   # Estilos customizados
‚îÇ   ‚îú‚îÄ‚îÄ js/                    # L√≥gica frontend
‚îÇ   ‚îî‚îÄ‚îÄ assets/                # Imagens e recursos
‚îú‚îÄ‚îÄ templates/                 # Jinja2 templates
‚îÇ   ‚îú‚îÄ‚îÄ layouts/               # Layouts base
‚îÇ   ‚îî‚îÄ‚îÄ pages/                 # P√°ginas espec√≠ficas
‚îú‚îÄ‚îÄ tests/                     # Testes automatizados
‚îú‚îÄ‚îÄ pyproject.toml             # Configura√ß√£o Poetry
‚îî‚îÄ‚îÄ .env.example               # Vari√°veis de ambiente
```

## 3. Configura√ß√£o do Ambiente

### 3.1 Pr√©-requisitos
- Python 3.9+
- SQLite3
- Node.js (para assets build)

### 3.2 Instala√ß√£o
```bash
# Clonar reposit√≥rio
git clone https://github.com/seu-usuario/chat-ai.git
cd chat-ai

# Configurar ambiente virtual
python -m venv venv
source venv/bin/activate  # Linux/MacOS
venv\Scripts\activate     # Windows

# Instalar depend√™ncias
poetry install

# Configurar vari√°veis de ambiente
cp .env.example .env
```

### 3.3 Configura√ß√£o do Banco de Dados
```python
# config/settings.py
class Config:
    SQLALCHEMY_DATABASE_URI = os.getenv('DATABASE_URL', 'sqlite:///../data/chat.db')
    SQLALCHEMY_TRACK_MODIFICATIONS = False
```

## 4. Modelos de Dados

### 4.1 Diagrama ER
![Diagrama Entidade-Relacionamento](https://via.placeholder.com/600x300?text=Diagrama+ER+do+Banco+de+Dados)

### 4.2 Esquema do Banco
**Conversation**
- id: Integer (PK)
- title: String(255)
- created_at: DateTime
- updated_at: DateTime

**Message**
- id: Integer (PK)
- content: Text
- role: Enum('user','assistant')
- conversation_id: Integer (FK)
- created_at: DateTime

## 5. API Reference (v1)

### 5.1 Endpoints Principais

#### `GET /api/v1/conversations`
**Response:**
```json
{
  "data": [
    {
      "id": 1,
      "title": "Discuss√£o sobre IA",
      "message_count": 5,
      "created_at": "2023-08-20T12:34:56Z"
    }
  ],
  "pagination": {
    "page": 1,
    "per_page": 20,
    "total_items": 1
  }
}
```

#### `POST /api/v1/conversations`
**Request:**
```json
{
  "title": "Nova Conversa",
  "initial_message": "Ol√°, como posso ajudar?"
}
```

#### `POST /api/v1/conversations/{id}/messages`
**Request:**
```json
{
  "content": "Explique o que √© machine learning",
  "role": "user"
}
```

## 6. Fluxo de Processamento

```mermaid
sequenceDiagram
    participant Usu√°rio
    participant Frontend
    participant Backend
    participant IA
    participant Banco de Dados
    
    Usu√°rio->>Frontend: Envia mensagem
    Frontend->>Backend: POST /api/v1/messages
    Backend->>Banco de Dados: Registra mensagem
    Backend->>IA: Envia para processamento
    IA->>Backend: Retorna resposta
    Backend->>Banco de Dados: Registra resposta
    Backend->>Frontend: Retorna resposta formatada
    Frontend->>Usu√°rio: Exibe resposta
```

## 7. Testes e Qualidade

### 7.1 Executando Testes
```bash
pytest tests/ --cov=backend --cov-report=html
```

### 7.2 Tipos de Testes
- **Testes Unit√°rios**: Valida√ß√£o de modelos e utilit√°rios
- **Testes de Integra√ß√£o**: Testes de API com requests mockados
- **Testes E2E**: Testes completos com Selenium

## 8. Deployment

### 8.1 Requisitos de Produ√ß√£o
- Gunicorn ou Waitress
- Reverse Proxy (Nginx)
- PostgreSQL
- Redis para cache

### 8.2 Dockeriza√ß√£o
```dockerfile
FROM python:3.9-slim

WORKDIR /app
COPY . .
RUN pip install poetry && poetry install --no-dev

EXPOSE 5000
CMD ["poetry", "run", "gunicorn", "app:app", "-b", "0.0.0.0:5000"]
```

## 9. Seguran√ßa

### 9.1 Boas Pr√°ticas Implementadas
- Valida√ß√£o de entrada em todos os endpoints
- Sanitiza√ß√£o de HTML nas mensagens
- Rate limiting (100 requests/minuto)
- Criptografia de dados sens√≠veis no banco

### 9.2 Melhorias Planejadas
- Implementa√ß√£o de OAuth2
- Adi√ß√£o de Web Application Firewall
- Auditoria de seguran√ßa peri√≥dica

## 10. Monitoramento

### 10.1 M√©tricas Chave
```python
# Exemplo de m√©trica com Prometheus
from prometheus_flask_exporter import PrometheusMetrics

metrics = PrometheusMetrics(app)
metrics.info('app_info', 'Application info', version='1.0.3')
```

### 10.2 Log Estruturado
```json
{
  "timestamp": "2023-08-20T12:34:56Z",
  "level": "INFO",
  "module": "database.connectors",
  "message": "Conex√£o estabelecida com sucesso",
  "duration_ms": 45.2,
  "conversation_id": 123
}
```

## 11. Refer√™ncias e Links √öteis
- [Documenta√ß√£o Flask](https://flask.palletsprojects.com/)
- [Guia SQLAlchemy](https://docs.sqlalchemy.org/)
- [Pol√≠ticas de Seguran√ßa](https://owasp.org/www-project-top-ten/)

---

Esta documenta√ß√£o oferece uma vis√£o completa do sistema, desde a configura√ß√£o inicial at√© considera√ß√µes avan√ßadas de produ√ß√£o. Para detalhes espec√≠ficos de implementa√ß√£o, consulte os coment√°rios no c√≥digo e a documenta√ß√£o gerada automaticamente via Sphinx.

Conte√∫do de backup.cssx:
:root {
    --bg-primary: #f7f7f8;
    --text-primary: #000000;
    --text-secondary: rgba(0, 0, 0, 0.7);
    --text-disabled: rgba(0, 0, 0, 0.5);
    --action-active: #000000;
    --action-hover: rgba(0, 0, 0, 0.08);
    --action-selected: rgba(0, 0, 0, 0.16);
    --action-disabled: rgba(0, 0, 0, 0.3);
    --action-disabled-background: rgba(0, 0, 0, 0.12);
    --msg-user: #e6e6e6;
    --msg-bot: #d9d9d9;
    --sidebar-bg: #ffffff;
    --input-bg: #ffffff;
    --border-color: rgba(0, 0, 0, 0.12);
}

[data-theme="dark"] {
    --bg-primary: #343541;
    --text-primary: #fff;
    --text-secondary: rgba(255, 255, 255, 0.7);
    --text-disabled: rgba(255, 255, 255, 0.5);
    --action-active: #fff;
    --action-hover: rgba(255, 255, 255, 0.08);
    --action-selected: rgba(255, 255, 255, 0.16);
    --action-disabled: rgba(255, 255, 255, 0.3);
    --action-disabled-background: rgba(255, 255, 255, 0.12);
    --msg-user: #444654;  /* Cor alterada para melhor contraste no modo escuro */
    --msg-bot: #444654;
    --sidebar-bg: #202123;
    --input-bg: #40414f;
    --border-color: rgba(255, 255, 255, 0.12);
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    transition: background-color 0.2s, color 0.2s;
}

body {
    font-family: 'Inter', sans-serif;
    background-color: var(--bg-primary);
    color: var(--text-primary);
    overflow: hidden;
}

.container {
    display: flex;
    height: 100vh;
    position: relative;
}

/* Barra Lateral */
.sidebar {
    position: fixed;
    width: 260px;
    height: 100vh;
    background-color: var(--sidebar-bg);
    padding: 1rem;
    border-right: 1px solid var(--border-color);
    display: flex;
    flex-direction: column;
    transition: transform 0.3s ease;
    z-index: 1000;
}

.sidebar.collapsed {
    transform: translateX(-260px);
}

.main-content {
    flex: 1;
    margin-left: 260px;
    transition: margin-left 0.3s ease;
    display: flex;
    flex-direction: column;
    height: 100vh;
}

.main-content.expanded {
    margin-left: 0;
}

.new-chat-btn {
    background-color: #19c37d;
    color: white;
    border: none;
    padding: 12px;
    border-radius: 5px;
    cursor: pointer;
    margin-bottom: 1rem;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.5rem;
}

.new-chat-btn:hover {
    background-color: #15a76c;
}

.settings-btn {
    margin-top: auto;
    padding: 12px;
    border: none;
    border-radius: 5px;
    background-color: transparent;
    color: var(--text-primary);
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 0.5rem;
    transition: background-color 0.2s;
}

.settings-btn:hover {
    background-color: var(--action-hover);
}

.search-box {
    position: relative;
    margin-bottom: 1rem;
}

.search-box input {
    width: 100%;
    padding: 0.75rem;
    border: 1px solid var(--border-color);
    border-radius: 5px;
    background-color: var(--input-bg);
    color: var(--text-primary);
}

.chat-list {
    flex: 1;
    overflow-y: auto;
    scrollbar-width: thin;
    scrollbar-color: var(--text-disabled) transparent;
}

.chat-list::-webkit-scrollbar {
    width: 5px;
}

.chat-list::-webkit-scrollbar-track {
    background: transparent;
}

.chat-list::-webkit-scrollbar-thumb {
    background-color: var(--text-disabled);
    border-radius: 20px;
}

.chat-item {
    padding: 0.75rem;
    border-radius: 5px;
    cursor: pointer;
    margin-bottom: 0.5rem;
    display: flex;
    align-items: center;
    justify-content: space-between;
    transition: background-color 0.2s;
}

.chat-item:hover {
    background-color: var(--action-hover);
}

.chat-item .action-buttons {
    display: none;
    gap: 0.5rem;
}

.chat-item:hover .action-buttons {
    display: flex;
}

.chat-item .action-btn {
    background: transparent;
    border: none;
    color: var(--text-secondary);
    padding: 0.5rem;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.2s;
}

.chat-item .action-btn:hover {
    background-color: var(--action-hover);
    color: var(--text-primary);
}

/* Top Bar */
.top-bar {
    padding: 1rem;
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 1rem;
    border-bottom: 1px solid var(--border-color);
    background-color: var(--bg-primary);
}

.top-bar-actions {
    display: flex;
    align-items: center;
    gap: 1rem;
}

.theme-toggle, .header-sidebar-toggle {
    width: 32px;
    height: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: var(--action-hover);
    border: none;
    border-radius: 4px;
    color: var(--text-primary);
    cursor: pointer;
}

.theme-toggle:hover, .header-sidebar-toggle:hover {
    background: var(--action-selected);
}

.model-select {
    padding: 0.5rem;
    border-radius: 4px;
    border: 1px solid var(--border-color);
    background-color: var(--input-bg);
    color: var(--text-primary);
}

/* Welcome Screen */
.welcome-screen {
    flex: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 2rem;
    max-width: 800px;
    margin: 0 auto;
    width: 100%;
}

.welcome-screen h1 {
    font-size: 2rem;
    margin-bottom: 2rem;
    color: var(--text-primary);
}

.input-box {
    display: flex;
    gap: 1rem;
    width: 100%;
    max-width: 800px;  /* Aumentado de 600px para 800px */
    margin-bottom: 2rem;
    position: relative;
}

.input-box textarea {
    width: 100%;
    padding: 1rem;  /* Aumentado de 0.75rem para 1rem */
    padding-right: 3.5rem;  /* Aumentado para dar mais espa√ßo ao bot√£o */
    border: 1px solid var(--border-color);
    border-radius: 0.5rem;
    background-color: var(--input-bg);
    color: var(--text-primary);
    font-size: 1rem;
    resize: none;
    min-height: 56px;  /* Aumentado de 44px para 56px */
    max-height: 200px;
    line-height: 1.5;
    scrollbar-width: none;
    -ms-overflow-style: none;
}

.input-box textarea::-webkit-scrollbar {
    display: none;
}

.input-box .send-btn,
.input-box .stop-btn {
    position: absolute;
    right: 0.75rem;
    bottom: 0.75rem;
    background: transparent;
    border: none;
    color: var(--text-primary);
    cursor: pointer;
    padding: 0.5rem;
    border-radius: 4px;
    transition: all 0.2s;
    display: flex;
    align-items: center;
    justify-content: center;
}

.input-box .send-btn:hover,
.input-box .stop-btn:hover {
    background-color: var(--action-hover);
}

/* Estilo do bot√£o de Stop */
.input-box .stop-btn {
    position: absolute;
    right: 5rem; /* Ajuste a posi√ß√£o conforme necess√°rio */
    bottom: 0.5rem;
    background: transparent;
    border: none;
    color: var(--text-primary);
    cursor: pointer;
    padding: 0.5rem;
    border-radius: 4px;
    transition: all 0.2s;
}

.input-box .stop-btn:hover {
    background-color: var(--action-hover);
}

.quick-actions {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 1rem;
    width: 100%;
    max-width: 600px;
}

.quick-action-btn {
    padding: 1rem;
    border: 1px solid var(--border-color);
    border-radius: 0.5rem;
    background-color: var(--input-bg);
    color: var(--text-primary);
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 0.5rem;
    transition: all 0.2s;
}

.quick-action-btn:hover {
    background-color: var(--action-hover);
}

/* Chat Container */
.chat-container {
    flex: 1;
    overflow-y: auto;
    padding: 2rem;
    max-width: 800px;
    margin: 0 auto;
    width: 100%;
    scrollbar-width: none;
    -ms-overflow-style: none;
}

.chat-container::-webkit-scrollbar {
    display: none;
}

.message {
    position: relative;
    max-width: 80%;
    margin-bottom: 1.5rem;
    padding: 1rem;
    border-radius: 0.5rem;
    line-height: 1.5;
}

.message.user {
    background-color: var(--msg-user);
    margin-left: auto;
    color: var(--text-primary);
}

.message.assistant {
    background-color: var(--msg-bot);
    margin-right: auto;
    color: var(--text-primary);
}

.message .message-actions {
    position: absolute;
    top: 0.5rem;
    right: 0.5rem;
    display: none;
    gap: 0.5rem;
}

.message:hover .message-actions {
    display: flex;
}

.message .action-btn {
    background: transparent;
    border: none;
    color: var(--text-secondary);
    padding: 0.5rem;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.2s;
}

.message .action-btn:hover {
    background-color: var(--action-hover);
    color: var(--text-primary);
}

/* Input Container */
.input-container {
    padding: 1.5rem;
    border-top: 1px solid var(--border-color);
    max-width: 800px;
    margin: 0 auto;
    width: 100%;
}

/* Loading Animation */
.loading {
    display: flex;
    gap: 0.5rem;
    align-items: center;
    padding: 1rem;
}

.loading span {
    width: 8px;
    height: 8px;
    background-color: var(--text-primary);
    border-radius: 50%;
    animation: bounce 0.5s alternate infinite;
}

.loading span:nth-child(2) {
    animation-delay: 0.1s;
}

.loading span:nth-child(3) {
    animation-delay: 0.2s;
}

@keyframes bounce {
    to {
        transform: translateY(-4px);
    }
}

/* Responsividade */
@media (max-width: 768px) {
    .sidebar {
        width: 100%;
    }
    
    .main-content {
        margin-left: 0;
    }
    
    .chat-container,
    .input-container,
    .welcome-screen {
        padding: 1rem;
    }
    
    .quick-actions {
        grid-template-columns: 1fr;
    }
}


Conte√∫do de chatActions.js:
import { mostrarCarregamento } from './chatUI.js';
import { adicionarMensagem } from './chatUI.js';
import { adicionarMensagemAoHistorico } from './chatStorage.js';

let abortController = null;

export async function enviarMensagem(mensagem, input, chatContainer, sendBtn, stopBtn) {
    if (!mensagem.trim()) return;

    input.value = '';
    input.style.height = 'auto';
    
    const loadingDiv = mostrarCarregamento(chatContainer);
    let accumulatedMessage = '';

    sendBtn.style.display = 'none';
    stopBtn.style.display = 'flex';

    abortController = new AbortController();

    try {
        const response = await fetch('/send_message', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                message: mensagem,
                conversation_id: window.conversaAtual?.id
            }),
            signal: abortController.signal
        });

        if (!response.ok) {
            throw new Error('Erro na resposta do servidor');
        }

        const reader = response.body.getReader();
        const decoder = new TextDecoder('utf-8');

        while (true) {
            const { value, done } = await reader.read();
            if (done) break;

            const chunk = decoder.decode(value, { stream: true });
            const lines = chunk.split('\n');

            for (const line of lines) {
                if (line.startsWith('data: ')) {
                    try {
                        const jsonData = JSON.parse(line.slice(6));
                        if (jsonData.content) {
                            accumulatedMessage += jsonData.content;
                            loadingDiv.innerHTML = `<p>${accumulatedMessage.replace(/\n/g, '<br>')}</p>`;
                            chatContainer.scrollTop = chatContainer.scrollHeight;
                        }
                    } catch (e) {
                        console.error('Erro ao processar chunk:', e);
                    }
                }
            }
        }

        loadingDiv.remove();
        adicionarMensagem(chatContainer, accumulatedMessage, 'assistant');
        adicionarMensagemAoHistorico(accumulatedMessage, 'assistant');
        
    } catch (erro) {
        if (erro.name === 'AbortError') {
            console.log('Gera√ß√£o de resposta interrompida pelo usu√°rio');
            loadingDiv.remove();
            if (accumulatedMessage) {
                adicionarMensagem(chatContainer, accumulatedMessage, 'assistant');
                adicionarMensagemAoHistorico(accumulatedMessage, 'assistant');
            }
        } else {
            console.error('Erro:', erro);
            loadingDiv.remove();
            const mensagemErro = 'Erro ao conectar com o servidor. Por favor, tente novamente.';
            adicionarMensagem(chatContainer, mensagemErro, 'assistant');
            adicionarMensagemAoHistorico(mensagemErro, 'assistant');
        }
    } finally {
        sendBtn.style.display = 'flex';
        stopBtn.style.display = 'none';
        abortController = null;
    }
}

export function interromperResposta() {
    if (abortController) {
        abortController.abort();
    }
}

Conte√∫do de chatStorage.js:
import { adicionarMensagem } from './chatUI.js';

export function carregarConversa(id) {
    const conversa = window.conversas.find(c => c.id === id);
    if (!conversa) return;

    window.conversaAtual = conversa;
    const chatContainer = document.querySelector('.chat-container');
    const welcomeScreen = document.querySelector('.welcome-screen');
    const inputContainer = document.querySelector('.input-container');
    
    welcomeScreen.style.display = 'none';
    chatContainer.style.display = 'block';
    inputContainer.style.display = 'block';
    chatContainer.innerHTML = '';
    
    conversa.mensagens.forEach(msg => {
        adicionarMensagem(chatContainer, msg.conteudo, msg.tipo);
    });
}

export function atualizarListaConversas() {
    const chatList = document.querySelector('.chat-list');
    if (!chatList) return;

    chatList.innerHTML = '';
    window.conversas.forEach(conversa => {
        const conversaElement = document.createElement('div');
        conversaElement.className = 'chat-item';
        if (window.conversaAtual && window.conversaAtual.id === conversa.id) {
            conversaElement.classList.add('active');
        }
        
        conversaElement.onclick = () => carregarConversa(conversa.id);
        
        const primeiraMsg = conversa.mensagens.find(m => m.tipo === 'user')?.conteudo || 'Nova conversa';
        const titulo = conversa.titulo || primeiraMsg.substring(0, 30) + (primeiraMsg.length > 30 ? '...' : '');
        
        conversaElement.innerHTML = `
            <span>${titulo}</span>
            <div class="action-buttons">
                <button class="action-btn" onclick="event.stopPropagation(); window.renomearConversa('${conversa.id}')">
                    <i class="fas fa-edit"></i>
                </button>
                <button class="action-btn" onclick="event.stopPropagation(); window.excluirConversa('${conversa.id}')">
                    <i class="fas fa-trash"></i>
                </button>
            </div>
        `;
        chatList.appendChild(conversaElement);
    });
}

export function criarNovaConversa() {
    const novaConversa = {
        id: Date.now().toString(),
        titulo: 'Nova conversa',
        mensagens: []
    };
    
    window.conversas.unshift(novaConversa);
    window.conversaAtual = null;
    atualizarListaConversas();
}

export function adicionarMensagemAoHistorico(mensagem, tipo) {
    if (!window.conversaAtual) {
        const novaConversa = {
            id: Date.now().toString(),
            titulo: 'Nova conversa',
            mensagens: []
        };
        window.conversas.unshift(novaConversa);
        window.conversaAtual = novaConversa;
    }
    
    window.conversaAtual.mensagens.push({
        tipo,
        conteudo: mensagem,
        timestamp: new Date().toISOString()
    });
    
    atualizarListaConversas();
}

export function renomearConversa(id) {
    const conversa = window.conversas.find(c => c.id === id);
    if (!conversa) return;

    const novoTitulo = prompt('Digite o novo t√≠tulo da conversa:', conversa.titulo);
    if (novoTitulo && novoTitulo.trim()) {
        conversa.titulo = novoTitulo.trim();
        atualizarListaConversas();
    }
}

export function excluirConversa(id) {
    if (!confirm('Tem certeza que deseja excluir esta conversa?')) return;
    
    window.conversas = window.conversas.filter(c => c.id !== id);
    
    if (window.conversaAtual && window.conversaAtual.id === id) {
        window.conversaAtual = null;
        const welcomeScreen = document.querySelector('.welcome-screen');
        const chatContainer = document.querySelector('.chat-container');
        const inputContainer = document.querySelector('.input-container');
        
        welcomeScreen.style.display = 'flex';
        chatContainer.style.display = 'none';
        inputContainer.style.display = 'none';
        
        document.querySelector('#welcome-input').value = '';
        document.querySelector('#chat-input').value = '';
    }
    
    atualizarListaConversas();
}

Conte√∫do de chatUI.js:
import { escapeHTML } from './chatUtils.js';

export function iniciarChat(welcomeScreen, chatContainer, inputContainer) {
    welcomeScreen.style.display = 'none';
    chatContainer.style.display = 'block';
    inputContainer.style.display = 'block';
    chatContainer.innerHTML = '';
}

export function mostrarTelaInicial(welcomeScreen, chatContainer, inputContainer, welcomeInput, chatInput) {
    welcomeScreen.style.display = 'flex';
    chatContainer.style.display = 'none';
    inputContainer.style.display = 'none';
    welcomeInput.value = '';
    chatInput.value = '';
}

export function adicionarMensagem(chatContainer, texto, tipo) {
    const mensagemDiv = document.createElement('div');
    mensagemDiv.className = `message ${tipo}`;
    mensagemDiv.innerHTML = `
        <p>${escapeHTML(texto).replace(/\n/g, '<br>')}</p>
        <div class="message-actions">
            <button class="action-btn" onclick="copiarMensagem(this)">
                <i class="fas fa-copy"></i>
            </button>
            ${tipo === 'assistant' ? `
                <button class="action-btn" onclick="regenerarResposta(this)">
                    <i class="fas fa-redo"></i>
                </button>
            ` : ''}
        </div>
    `;
    chatContainer.appendChild(mensagemDiv);
    chatContainer.scrollTop = chatContainer.scrollHeight;
}

export function mostrarCarregamento(chatContainer) {
    const loadingDiv = document.createElement('div');
    loadingDiv.className = 'loading message assistant';
    loadingDiv.innerHTML = `
        <span></span>
        <span></span>
        <span></span>
    `;
    chatContainer.appendChild(loadingDiv);
    chatContainer.scrollTop = chatContainer.scrollHeight;
    return loadingDiv;
}

Conte√∫do de chatUtils.js:
export function escapeHTML(text) {
    const div = document.createElement('div');
    div.innerText = text;
    return div.innerHTML;
}

export function copiarMensagem(button) {
    const mensagem = button.closest('.message').querySelector('p').textContent;
    navigator.clipboard.writeText(mensagem);
}

export function regenerarResposta(button) {
    const mensagem = button.closest('.message').previousElementSibling.querySelector('p').textContent;
    const chatContainer = button.closest('.chat-container');
    const chatInput = document.querySelector('#chat-input');
    const sendBtn = document.querySelector('#send-btn');
    const stopBtn = document.querySelector('#stop-btn');
    
    if (chatInput && sendBtn && stopBtn) {
        chatInput.value = mensagem;
        const form = chatInput.closest('form');
        if (form) {
            form.dispatchEvent(new Event('submit'));
        }
    }
}

Conte√∫do de chat.js:
import { 
    iniciarChat,
    mostrarTelaInicial,
    adicionarMensagem,
    mostrarCarregamento
} from './chat/chatUI.js';

import {
    enviarMensagem,
    interromperResposta
} from './chat/chatActions.js';

import {
    carregarConversa,
    atualizarListaConversas,
    criarNovaConversa,
    adicionarMensagemAoHistorico,
    renomearConversa,
    excluirConversa
} from './chat/chatStorage.js';

export {
    iniciarChat,
    mostrarTelaInicial,
    adicionarMensagem,
    enviarMensagem,
    interromperResposta,
    carregarConversa,
    atualizarListaConversas,
    criarNovaConversa,
    adicionarMensagemAoHistorico,
    renomearConversa,
    excluirConversa
};

Conte√∫do de events.js:
// Importa√ß√µes necess√°rias
import { toggleTheme } from './theme.js';
import { toggleSidebar } from './sidebar.js';
import { configureTextarea } from './textarea.js';
import { enviarMensagem } from './chat/chatActions.js'; // Importando a fun√ß√£o enviarMensagem

export function configureEventListeners() {
    const themeToggle = document.querySelector('.theme-toggle');
    const modelSelect = document.querySelector('.model-select');
    const sidebarToggle = document.querySelector('.sidebar-toggle');
    const headerSidebarToggle = document.querySelector('.header-sidebar-toggle');
    const chatInput = document.querySelector('#chat-input'); // Campo de entrada de chat
    const sendButton = document.querySelector('#send-button'); // Bot√£o de envio

    // Event Listeners
    themeToggle?.addEventListener('click', toggleTheme);
    sidebarToggle?.addEventListener('click', toggleSidebar);
    headerSidebarToggle?.addEventListener('click', toggleSidebar);

    modelSelect?.addEventListener('change', (e) => {
        window.currentModel = e.target.value;
    });

    // Configurar textareas
    configureTextarea(chatInput);
    configureTextarea(document.querySelector('#welcome-input'));

    // Adicionando evento de envio de mensagem
    sendButton?.addEventListener('click', () => {
        const mensagem = chatInput.value;
        enviarMensagem(mensagem, chatInput, document.querySelector('.chat-container'), sendButton, document.querySelector('#stop-button'));
    });

    chatInput?.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            const mensagem = chatInput.value;
            enviarMensagem(mensagem, chatInput, document.querySelector('.chat-container'), sendButton, document.querySelector('#stop-button'));
            e.preventDefault(); // Evita a quebra de linha
        }
    });
}


Conte√∫do de init.js:
import { initializeTheme } from './theme.js';
import { configureEventListeners } from './events.js';

document.addEventListener('DOMContentLoaded', () => {
    initializeTheme();
    configureEventListeners();
});

Conte√∫do de main.js:
import './init.js';
import { 
    iniciarChat,
    mostrarTelaInicial,
    adicionarMensagem,
    enviarMensagem,
    interromperResposta,
    carregarConversa,
    atualizarListaConversas,
    criarNovaConversa,
    adicionarMensagemAoHistorico,
    renomearConversa,
    excluirConversa
} from './chat.js';

// Estado global
window.currentModel = 'gemma2:2b';
window.conversas = [];
window.conversaAtual = null;

document.addEventListener('DOMContentLoaded', () => {
    console.log("P√°gina carregada, iniciando configura√ß√£o...");
    
    const welcomeForm = document.getElementById('welcome-form');
    const chatForm = document.getElementById('chat-form');
    const chatContainer = document.querySelector('.chat-container');
    const welcomeInput = document.getElementById('welcome-input');
    const chatInput = document.getElementById('chat-input');
    const sendBtn = document.getElementById('send-btn');
    const stopBtn = document.getElementById('stop-btn');
    const newChatBtn = document.querySelector('.new-chat-btn');

    console.log("Elementos do DOM carregados:", {
        welcomeForm: !!welcomeForm,
        chatForm: !!chatForm,
        chatContainer: !!chatContainer,
        welcomeInput: !!welcomeInput,
        chatInput: !!chatInput,
        sendBtn: !!sendBtn,
        stopBtn: !!stopBtn,
        newChatBtn: !!newChatBtn
    });

    // Configurar bot√£o de nova conversa
    newChatBtn?.addEventListener('click', () => {
        console.log("Iniciando nova conversa...");
        window.conversaAtual = null;
        mostrarTelaInicial(
            document.querySelector('.welcome-screen'),
            chatContainer,
            document.querySelector('.input-container'),
            welcomeInput,
            chatInput
        );
    });

    welcomeForm?.addEventListener('submit', async (e) => {
        e.preventDefault();
        const message = welcomeInput.value.trim();
        if (!message) return;

        console.log("Processando mensagem inicial:", message);

        if (!window.conversaAtual) {
            console.log("Criando nova conversa...");
            const novaConversa = {
                id: Date.now().toString(),
                titulo: 'Nova conversa',
                mensagens: []
            };
            window.conversas.unshift(novaConversa);
            window.conversaAtual = novaConversa;
            console.log("Nova conversa criada:", novaConversa);
            atualizarListaConversas();
        }

        iniciarChat(
            document.querySelector('.welcome-screen'),
            chatContainer,
            document.querySelector('.input-container')
        );

        adicionarMensagem(chatContainer, message, 'user');
        adicionarMensagemAoHistorico(message, 'user');
        
        await enviarMensagem(message, welcomeInput, chatContainer, sendBtn, stopBtn);
    });

    chatForm?.addEventListener('submit', async (e) => {
        e.preventDefault();
        const message = chatInput.value.trim();
        if (!message) return;

        console.log("Processando mensagem do chat:", message);

        adicionarMensagem(chatContainer, message, 'user');
        adicionarMensagemAoHistorico(message, 'user');
        
        await enviarMensagem(message, chatInput, chatContainer, sendBtn, stopBtn);
    });

    stopBtn?.addEventListener('click', () => {
        console.log("Interrompendo resposta...");
        interromperResposta();
    });

    // Inicializar lista de conversas
    console.log("Inicializando lista de conversas...");
    atualizarListaConversas();
    console.log("Estado inicial das conversas:", window.conversas);
});

// Expor fun√ß√µes globalmente
window.carregarConversa = carregarConversa;
window.criarNovaConversa = criarNovaConversa;
window.adicionarMensagemAoHistorico = adicionarMensagemAoHistorico;
window.interromperResposta = interromperResposta;
window.renomearConversa = renomearConversa;
window.excluirConversa = excluirConversa;

Conte√∫do de sidebar.js:
export function toggleSidebar() {
    const sidebar = document.querySelector('.sidebar');
    const mainContent = document.querySelector('.main-content');
    
    sidebar.classList.toggle('collapsed');
    mainContent.classList.toggle('expanded');
}

Conte√∫do de textarea.js:
export function configureTextarea(textarea) {
    if (!textarea) return;

    textarea.addEventListener('input', function() {
        this.style.height = 'auto';
        this.style.height = (this.scrollHeight) + 'px';
    });

    textarea.addEventListener('keydown', function(e) {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            const form = this.closest('form');
            if (form) {
                const event = new Event('submit', {
                    'bubbles': true,
                    'cancelable': true
                });
                form.dispatchEvent(event);
            }
        }
    });
}

Conte√∫do de theme.js:
// Estado do tema
let currentTheme = 'light';

// Fun√ß√£o para alternar o tema
export function toggleTheme() {
    currentTheme = currentTheme === 'light' ? 'dark' : 'light';
    document.documentElement.setAttribute('data-theme', currentTheme);
    localStorage.setItem('theme', currentTheme);
    
    const themeToggle = document.querySelector('.theme-toggle');
    if (themeToggle) {
        themeToggle.innerHTML = currentTheme === 'light' 
            ? '<i class="fas fa-moon"></i>' 
            : '<i class="fas fa-sun"></i>';
    }
}

// Fun√ß√£o para inicializar o tema
export function initializeTheme() {
    const savedTheme = localStorage.getItem('theme') || 'light';
    if (savedTheme === 'dark') {
        toggleTheme();
    }
}

Conte√∫do de utils.js:
export function escapeHTML(text) {
    const div = document.createElement('div');
    div.innerText = text;
    return div.innerHTML;
}

export function mostrarCarregamento(chatContainer) {
    const loadingDiv = document.createElement('div');
    loadingDiv.className = 'loading message assistant';
    loadingDiv.innerHTML = `
        <span></span>
        <span></span>
        <span></span>
    `;
    chatContainer.appendChild(loadingDiv);
    chatContainer.scrollTop = chatContainer.scrollHeight;
    return loadingDiv;
}

Conte√∫do de index.html:
<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Chat</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='css/styles.css') }}">
    <script>
        // Inicializa as conversas com os dados do backend
        window.conversas = {{ conversations|tojson|safe }};
        console.log("Conversas carregadas do backend:", window.conversas);
    </script>
</head>
<body>
    <div class="container">
        <!-- Barra Lateral -->
        <aside class="sidebar">
            <button class="new-chat-btn">
                <i class="fas fa-plus"></i>
                Novo Chat
            </button>
            <div class="search-box">
                <input type="text" id="search-input" placeholder="Pesquisar conversas...">
            </div>
            <div class="chat-list">
                <!-- Lista de conversas ser√° preenchida via JavaScript -->
            </div>
            <button class="settings-btn">
                <i class="fas fa-cog"></i>
                Configura√ß√µes
            </button>
        </aside>

        <!-- Conte√∫do Principal -->
        <main class="main-content">
            <div class="top-bar">
                <button class="header-sidebar-toggle">
                    <i class="fas fa-bars"></i>
                </button>
                <h1 class="program-name">AI  </h1>
                <div class="top-bar-actions">
                    <button class="theme-toggle">
                        <i class="fas fa-moon"></i>
                    </button>
                    <select class="model-select">
                        <option value="gemma2:2b">gemma2:2b</option>
                    </select>
                </div>
            </div>

            <!-- Tela de Boas-vindas -->
            <div class="welcome-screen">
                <h1>Como posso ajudar?</h1>
                <form class="input-box" id="welcome-form">
                    <textarea id="welcome-input" placeholder="Envie uma mensagem..." rows="1"></textarea>
                    <button type="submit" class="send-btn">
                        <i class="fas fa-paper-plane"></i>
                    </button>
                </form>
                <div class="quick-actions">
                    <button class="quick-action-btn">
                        <i class="fas fa-lightbulb"></i>
                        Sugerir ideias
                    </button>
                    <button class="quick-action-btn">
                        <i class="fas fa-file-alt"></i>
                        Resumir texto
                    </button>
                    <button class="quick-action-btn">
                        <i class="fas fa-code"></i>
                        Ajuda com c√≥digo
                    </button>
                    <button class="quick-action-btn">
                        <i class="fas fa-question-circle"></i>
                        Tirar d√∫vidas
                    </button>
                </div>
            </div>

            <!-- Container de Chat -->
            <div class="chat-container" style="display: none;">
                <!-- Mensagens ser√£o inseridas aqui -->
            </div>

            <!-- Container de Input -->
            <div class="input-container" style="display: none;">
                <form class="input-box" id="chat-form">
                    <textarea id="chat-input" placeholder="Digite sua mensagem..." rows="1"></textarea>
                    <button type="submit" class="send-btn" id="send-btn">
                        <i class="fas fa-paper-plane"></i>
                    </button>
                    <button type="button" class="stop-btn" id="stop-btn" style="display: none;">
                        <i class="fas fa-stop"></i>
                    </button>
                </form>
            </div>
        </main>
    </div>

    <script type="module" src="{{ url_for('static', filename='js/theme.js') }}"></script>
    <script type="module" src="{{ url_for('static', filename='js/main.js') }}"></script>
</body>
</html>

Conte√∫do de chat_history.py:
import json
from datetime import datetime
import os

HISTORY_FILE = 'data/chat_history.json'

def ensure_data_directory():
    os.makedirs('data', exist_ok=True)

def get_conversation_history():
    ensure_data_directory()
    try:
        if os.path.exists(HISTORY_FILE):
            with open(HISTORY_FILE, 'r', encoding='utf-8') as f:
                return json.load(f)
        return []
    except json.JSONDecodeError as e:
        print(f"Erro ao carregar hist√≥rico: {str(e)}")
        return []  # Retorna uma lista vazia em caso de erro
    except Exception as e:
        print(f"Erro ao carregar hist√≥rico: {str(e)}")
        return []  # Retorna uma lista vazia em caso de erro

def get_conversation_by_id(conversation_id):
    """Busca uma conversa espec√≠fica pelo ID"""
    conversations = get_conversation_history()
    for conversation in conversations:
        if conversation['id'] == conversation_id:
            return conversation
    return None
  
def save_conversation(message, response, conversation_id=None):
    """
    Salva ou atualiza uma conversa no hist√≥rico.
    Se conversation_id for fornecido, atualiza a conversa existente.
    Caso contr√°rio, cria uma nova conversa.
    """
    ensure_data_directory()
    try:
        # Carrega o hist√≥rico atual
        conversations = get_conversation_history()
        
        if conversation_id:
            # Atualiza conversa existente
            updated = False
            for conversation in conversations:
                if conversation['id'] == conversation_id:
                    conversation['messages'].extend([
                        {'role': 'user', 'content': message},
                        {'role': 'assistant', 'content': response}
                    ])
                    conversation['timestamp'] = datetime.now().isoformat()
                    updated = True
                    break
            
            # Se n√£o encontrou o ID, cria uma nova conversa (backup seguro)
            if not updated:
                conversation_id = str(len(conversations) + 1)
                new_conversation = {
                    'id': conversation_id,
                    'timestamp': datetime.now().isoformat(),
                    'messages': [
                        {'role': 'user', 'content': message},
                        {'role': 'assistant', 'content': response}
                    ]
                }
                conversations.append(new_conversation)
        else:
            # Cria nova conversa
            conversation_id = str(len(conversations) + 1)
            new_conversation = {
                'id': conversation_id,
                'timestamp': datetime.now().isoformat(),
                'messages': [
                    {'role': 'user', 'content': message},
                    {'role': 'assistant', 'content': response}
                ]
            }
            conversations.append(new_conversation)
        
        # Salva as conversas atualizadas
        with open(HISTORY_FILE, 'w', encoding='utf-8') as f:
            json.dump(conversations, f, ensure_ascii=False, indent=2)
        
        return conversation_id
    except Exception as e:
        print(f"Erro ao salvar conversa: {str(e)}")
        return None
 

Conte√∫do de text_processor.py:
def split_text(text, words_per_chunk=300):
    """
    Divide um texto em chunks menores baseado no n√∫mero de palavras.
    """
    words = text.split()
    chunks = []
    
    for i in range(0, len(words), words_per_chunk):
        chunk = ' '.join(words[i:i + words_per_chunk])
        chunks.append(chunk)
    
    return chunks


==========================================
Estrutura de pastas:
==========================================
persistencia-memoria-html
    app.py
    backend
        database
            database.py
        models
            conversations.py
            messages.py
        routers
            chats.py
        utils
            chat_history.py
            text_processor.py
            __init__.py
        __init__.py
    README.md
    static
        css
            backup.cssx
            base
            components
            layout
            themes
        js
            chat
                chatActions.js
                chatStorage.js
                chatUI.js
                chatUtils.js
            chat.js
            events.js
            init.js
            main.js
            sidebar.js
            textarea.js
            theme.js
            utils.js
    templates
        index.html
    utils
        chat_history.py
        text_processor.py
