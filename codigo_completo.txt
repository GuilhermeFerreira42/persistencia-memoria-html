Conteúdo de app.py:
import init_eventlet

from flask import Flask, render_template, request, jsonify, Response
import json
import os
from datetime import datetime
import requests
from utils.text_processor import split_text, clean_and_format_text
from youtube_handler import YoutubeHandler
from flask_socketio import SocketIO, emit, join_room, leave_room
from utils.chat_storage import (
    create_new_conversation,
    add_message_to_conversation,
    get_conversation_by_id,
    get_conversation_history,
    delete_conversation,
    rename_conversation
)

app = Flask(__name__, static_folder='static')
app.secret_key = 'sua_chave_secreta_aqui'
socketio = SocketIO(app, async_mode='eventlet', cors_allowed_origins="*")

API_URL = "http://localhost:11434/v1/chat/completions"
MODEL_NAME = "gemma2:2b"
youtube_handler = YoutubeHandler()

@app.route('/')
def home():
    conversations = get_conversation_history()
    return render_template('index.html', conversations=conversations)

@app.route('/get_conversation_history')
def conversation_history():
    try:
        conversations = get_conversation_history()
        return jsonify(conversations)
    except Exception as e:
        print(f"[ERRO] Falha ao obter histórico de conversas: {str(e)}")
        return jsonify({'error': str(e)}), 500

@app.route('/get_conversation/<conversation_id>')
def get_conversation(conversation_id):
    try:
        conversation = get_conversation_by_id(conversation_id)
        if conversation:
            return jsonify(conversation)
        print(f"[ERRO] Conversa não encontrada: {conversation_id}")
        return jsonify({'error': 'Conversa não encontrada'}), 404
    except Exception as e:
        print(f"[ERRO] Falha ao obter conversa: {str(e)}")
        return jsonify({'error': str(e)}), 500

@app.route('/get_conversation/<conversation_id>/<int:offset>/<int:limit>')
def get_conversation_batch(conversation_id, offset, limit):
    """Endpoint para carregar mensagens em lotes para lazy loading"""
    try:
        conversation = get_conversation_by_id(conversation_id)
        if conversation:
            messages = conversation['messages']
            # Garantir que offset e limit estão dentro dos limites
            offset = min(offset, len(messages))
            end_index = min(offset + limit, len(messages))
            batch = messages[offset:end_index]
            
            return jsonify({
                'messages': batch,
                'total': len(messages),
                'hasMore': end_index < len(messages)
            })
        
        print(f"[ERRO] Conversa não encontrada para batch loading: {conversation_id}")
        return jsonify({'error': 'Conversa não encontrada'}), 404
    except Exception as e:
        print(f"[ERRO] Falha ao obter lote de mensagens: {str(e)}")
        return jsonify({'error': str(e)}), 500

@app.route('/stream')
def stream():
    """Endpoint para streaming de respostas usando Server-Sent Events (SSE)"""
    conversation_id = request.args.get('conversation_id')
    message = request.args.get('message', '')
    
    if not conversation_id:
        return jsonify({'error': 'ID de conversa não fornecido'}), 400
        
    print(f"[DEBUG] Iniciando streaming para conversa: {conversation_id}")
    
    def event_stream():
        for part in process_with_ai_stream(message, conversation_id):
            if part:
                yield f"data: {part}\n\n"
                
    response = Response(event_stream(), content_type="text/event-stream")
    response.headers['Cache-Control'] = 'no-cache'
    response.headers['X-Accel-Buffering'] = 'no'  # Para Nginx
    return response

@app.route('/send_message', methods=['POST'])
def send_message():
    data = request.json
    message = data.get('message', '')
    conversation_id = data.get('conversation_id')

    if not conversation_id:
        conversation_id = create_new_conversation()
        print(f"[DEBUG] Nova conversa criada com ID: {conversation_id}")
    else:
        print(f"[DEBUG] Usando conversa existente: {conversation_id}")

    # Salvar mensagem do usuário
    add_message_to_conversation(conversation_id, message, "user")
    print(f"[DEBUG] Mensagem do usuário salva na conversa: {conversation_id}")

    # Processar resposta da IA
    accumulated_response = []
    
    def generate_streamed_response():
        for part in process_with_ai_stream(message, conversation_id):
            if part:
                accumulated_response.append(part)
                # Emitir via WebSocket além do SSE
                socketio.emit('message_chunk', {
                    'content': part, 
                    'conversation_id': conversation_id
                }, room=conversation_id)
                yield f"data: {json.dumps({'content': part, 'conversation_id': conversation_id})}\n\n"
        
        # Salvar a resposta completa da IA - APENAS UMA VEZ
        if accumulated_response:
            complete_response = ''.join(accumulated_response)
            print(f"[DEBUG] Salvando resposta única para {conversation_id}")
            add_message_to_conversation(conversation_id, complete_response, "assistant")
            # Notificar todas as abas conectadas que a conversa foi atualizada
            socketio.emit('conversation_updated', {
                'conversation_id': conversation_id
            })
            print(f"[DEBUG] Resposta completa da IA salva na conversa: {conversation_id}")

    response = Response(generate_streamed_response(), content_type="text/event-stream")
    response.headers['Cache-Control'] = 'no-cache'
    return response

@app.route('/save_message', methods=['POST'])
def save_message():
    try:
        data = request.json
        conversation_id = data.get('conversation_id')
        content = data.get('content')
        role = data.get('role')
        
        if not all([conversation_id, content, role]):
            return jsonify({'error': 'Dados incompletos'}), 400
        
        print(f"[DEBUG] Salvando mensagem para conversa: {conversation_id}, role: {role}")
        add_message_to_conversation(conversation_id, content, role)
        
        # Notificar clientes via WebSocket
        socketio.emit('conversation_updated', {
            'conversation_id': conversation_id
        })
        
        return jsonify({'status': 'success', 'conversation_id': conversation_id})
    except Exception as e:
        print(f"Erro ao salvar mensagem: {str(e)}")
        return jsonify({'error': str(e)}), 500

@app.route('/process_youtube', methods=['POST'])
def process_youtube():
    try:
        data = request.json
        video_url = data.get('video_url')
        conversation_id = data.get('conversation_id')
        comando = data.get('comando')  # Novo: pegar o comando original
        
        if not video_url:
            return jsonify({'error': 'URL não fornecida'}), 400
            
        # Baixar legendas e obter título
        subtitle_file, video_title = youtube_handler.download_subtitles(video_url)
        if not subtitle_file:
            return jsonify({'error': 'Não foi possível baixar as legendas deste vídeo'}), 404
            
        # Limpar legendas
        cleaned_text = youtube_handler.clean_subtitles(subtitle_file)
        if not cleaned_text:
            return jsonify({'error': 'Erro ao processar legendas'}), 500

        # Salvar comando do usuário na conversa
        if conversation_id and comando:
            add_message_to_conversation(
                conversation_id,
                comando,
                "user"
            )
            print(f"[DEBUG] Comando do usuário salvo na conversa: {conversation_id}")

        # Salvar transcrição com título na conversa
        formatted_response = f"📹 {video_title}\n\n{cleaned_text}"
        if conversation_id:
            add_message_to_conversation(
                conversation_id,
                formatted_response,
                "assistant"
            )
            print(f"[DEBUG] Resposta do YouTube salva na conversa: {conversation_id}")
            
            # Notificar via WebSocket
            socketio.emit('conversation_updated', {
                'conversation_id': conversation_id
            })
            
        return jsonify({
            'text': formatted_response,
            'title': video_title,
            'conversation_id': conversation_id
        })
        
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/rename_conversation/<conversation_id>', methods=['POST'])
def handle_rename_conversation(conversation_id):
    try:
        print(f"[BACKEND] Recebendo solicitação para renomear conversa: {conversation_id}")
        
        # Forçar decodificação do corpo JSON
        data = request.get_json(force=True, silent=True)
        if not data:
            data = {}
            print("[BACKEND] Request body vazio ou inválido")
        
        new_title = data.get('title', '').strip()
        print(f"[BACKEND] Novo título: '{new_title}'")
        
        if not new_title:
            print("[BACKEND] Título inválido")
            return jsonify({'error': 'Título inválido'}), 400
            
        success = rename_conversation(conversation_id, new_title)
        if success:
            print(f"[BACKEND] Conversa renomeada com sucesso para: {new_title}")
            
            # Notificar via WebSocket
            socketio.emit('conversation_renamed', {
                'conversation_id': conversation_id,
                'new_title': new_title
            })
            
            return jsonify({'success': True, 'new_title': new_title, 'conversation_id': conversation_id})
        else:
            print("[BACKEND] Falha ao renomear conversa")
            return jsonify({'error': 'Falha ao renomear conversa'}), 500
    except Exception as e:
        print(f"[BACKEND] Erro ao renomear conversa: {str(e)}")
        return jsonify({'error': str(e)}), 500

@app.route('/delete_conversation/<conversation_id>', methods=['DELETE'])
def handle_delete_conversation(conversation_id):
    try:
        print(f"[BACKEND] Recebendo solicitação para excluir conversa: {conversation_id}")
        
        success = delete_conversation(conversation_id)
        if success:
            print(f"[BACKEND] Conversa {conversation_id} excluída com sucesso")
            
            # Notificar via WebSocket
            socketio.emit('conversation_deleted', {
                'conversation_id': conversation_id
            })
            
            return jsonify({'success': True, 'conversation_id': conversation_id})
        else:
            print(f"[BACKEND] Falha ao excluir conversa {conversation_id}")
            return jsonify({'error': 'Falha ao excluir conversa'}), 500
    except Exception as e:
        print(f"[BACKEND] Erro ao excluir conversa: {str(e)}")
        return jsonify({'error': str(e)}), 500

# ---- WebSocket event handlers ----

@socketio.on('connect')
def handle_connect():
    print(f"[SOCKET] Cliente conectado: {request.sid}")

@socketio.on('disconnect')
def handle_disconnect():
    print(f"[SOCKET] Cliente desconectado: {request.sid}")

@socketio.on('join_conversation')
def handle_join_conversation(data):
    conversation_id = data.get('conversation_id')
    if conversation_id:
        join_room(conversation_id)
        print(f"[SOCKET] Cliente {request.sid} entrou na sala: {conversation_id}")

@socketio.on('leave_conversation')
def handle_leave_conversation(data):
    conversation_id = data.get('conversation_id')
    if conversation_id:
        leave_room(conversation_id)
        print(f"[SOCKET] Cliente {request.sid} saiu da sala: {conversation_id}")

def process_with_ai(text, conversation_id=None):
    try:
        # Incluir o ID da conversa no contexto para rastreamento
        context_header = f"[Conversa: {conversation_id}] " if conversation_id else ""
        print(f"{context_header}Processando com IA: {text[:50]}...")
        
        payload = {
            "model": MODEL_NAME,
            "messages": [
                {"role": "system", "content": "Você é um assistente útil. Formate suas respostas em Markdown. Use acentos graves triplos (```) APENAS para blocos de código, especificando a linguagem (ex.: ```python). NUNCA coloque texto explicativo dentro de blocos de código."},
                {"role": "user", "content": text}
            ],
            "stream": False
        }
        headers = {"Content-Type": "application/json"}
        response = requests.post(API_URL, json=payload, headers=headers)
        response.raise_for_status()

        response_data = response.json()
        if 'choices' in response_data and len(response_data['choices']) > 0:
            return response_data['choices'][0]['message']['content']
        return "Erro: Nenhuma resposta válida recebida da IA."
    except requests.exceptions.RequestException as e:
        print(f"[Debug] Erro na requisição HTTP: {str(e)}")
        return "Ocorreu um erro ao se conectar com a IA."
    except Exception as e:
        print(f"[Debug] Erro inesperado: {str(e)}")
        return "Ocorreu um erro inesperado ao processar sua mensagem."

def process_with_ai_stream(text, conversation_id=None):
    try:
        # Incluir o ID da conversa no contexto para rastreamento
        context_header = f"[Conversa: {conversation_id}] " if conversation_id else ""
        print(f"{context_header}Iniciando streaming para: {text[:50]}...")
        
        # Opção para incluir histórico de mensagens da conversa específica
        conversation = None
        if conversation_id:
            conversation = get_conversation_by_id(conversation_id)
        
        # Mensagem do sistema é sempre necessária
        messages = [{"role": "system", "content": "Você é um assistente útil. Formate suas respostas em Markdown. Use acentos graves triplos (```) APENAS para blocos de código, especificando a linguagem (ex.: ```python). NUNCA coloque texto explicativo dentro de blocos de código. Exemplo:\nTexto normal aqui.\n```python\nprint('Código aqui')\n```\nMais texto normal aqui."}]
        
        # Adicionar mensagem do usuário
        messages.append({"role": "user", "content": text})
        
        payload = {
            "model": MODEL_NAME,
            "messages": messages,
            "stream": True
        }
        headers = {"Content-Type": "application/json"}
        response = requests.post(API_URL, json=payload, headers=headers, stream=True)
        response.raise_for_status()

        for line in response.iter_lines(decode_unicode=True):
            if line.strip() and line.startswith("data: "):
                line = line[6:].strip()
                try:
                    response_data = json.loads(line)
                    if 'choices' in response_data and len(response_data['choices']) > 0:
                        delta = response_data['choices'][0]['delta']
                        if "content" in delta:
                            content = delta["content"].encode('latin1').decode('utf-8', errors='ignore')
                            print(f"{context_header}Chunk: {len(content)} caracteres")
                            yield content
                except json.JSONDecodeError:
                    print(f"[Debug] Erro ao decodificar JSON: {line}")
    except requests.exceptions.RequestException as e:
        print(f"[Debug] Erro na requisição HTTP: {str(e)}")
    except Exception as e:
        print(f"[Debug] Erro inesperado: {str(e)}")

if __name__ == '__main__':
    print("Iniciando servidor com Eventlet em modo de desenvolvimento...")
    socketio.run(app, debug=True, host='0.0.0.0', port=5000, use_reloader=False)


Conteúdo de atualiza-git.bat:
@echo off

:: Altere para o diretorio onde o script esta localizado
cd /d %~dp0

:menu
cls
echo Diretorio atual: %cd%
echo =====================================
echo     GIT AUTOMATION MENU
echo =====================================
echo 1. Verificar status do repositorio
echo 2. Adicionar todas as alteracoes
echo 3. Fazer commit
echo 4. Fazer push para o GitHub
echo 5. Fazer pull do repositorio
echo 6. Mostrar log de commits
echo 7. Outras opcoes
echo 8. Sair
echo =====================================
set /p escolha="Escolha uma opcao: "

if %escolha%==1 goto status
if %escolha%==2 goto add
if %escolha%==3 goto commit
if %escolha%==4 goto push
if %escolha%==5 goto pull
if %escolha%==6 goto log
if %escolha%==7 goto outras_opcoes
if %escolha%==8 goto fim
goto menu

:status
echo Diretorio atual: %cd%
echo Verificando o status do repositorio...
git status
pause
goto menu

:add
echo Diretorio atual: %cd%
echo Adicionando todas as alteracoes...
git add .
pause
goto menu

:commit
set /p comentario="Digite o comentario do commit: "
echo Diretorio atual: %cd%
git commit -m "%comentario%"
pause
goto menu

:push
echo Diretorio atual: %cd%
echo Fazendo push para o GitHub...
git push
pause
goto menu

:pull
echo Diretorio atual: %cd%
echo Fazendo pull do repositorio...
git pull
pause
goto menu

:log
echo Diretorio atual: %cd%
echo Mostrando log de commits...
git log
pause
goto menu

:outras_opcoes
cls
echo Outras opcoes
echo =====================================
echo 1. Restaurar arquivos deletados
echo 2. Sincronizar com repositorio
echo 3. Fazer fetch do repositorio
echo 4. Fazer merge de branches
echo 5. Inicializar um novo repositorio (git init)
echo 6. Desfazer alteracoes (git reset)
echo 7. Listar branches (git branch)
echo 8. Voltar ao menu principal
echo =====================================
set /p escolha_outras="Escolha uma opcao: "

if %escolha_outras%==1 goto restaurar
if %escolha_outras%==2 goto sincronizar
if %escolha_outras%==3 goto fetch
if %escolha_outras%==4 goto merge
if %escolha_outras%==5 goto init
if %escolha_outras%==6 goto reset
if %escolha_outras%==7 goto branch
if %escolha_outras%==8 goto menu
goto outras_opcoes

:restaurar
echo Restaurando arquivos deletados...
git checkout -- .
pause
goto outras_opcoes

:sincronizar
echo Sincronizando com repositorio...
git fetch origin
pause
goto outras_opcoes

:fetch
echo Fazendo fetch do repositorio...
git fetch
pause
goto outras_opcoes

:merge
echo Fazendo merge de branches...
git merge
pause
goto outras_opcoes

:init
echo Inicializando um novo repositorio...
git init
pause
goto outras_opcoes

:reset
echo Desfazendo alteracoes...
git reset
pause
goto outras_opcoes

:branch
echo Listando branches...
git branch
pause
goto outras_opcoes

:fim
echo Saindo...
pause


Conteúdo de codigo_completo.txt:
Conteúdo de app.py:
import init_eventlet

from flask import Flask, render_template, request, jsonify, Response
import json
import os
from datetime import datetime
import requests
from utils.text_processor import split_text, clean_and_format_text
from youtube_handler import YoutubeHandler
from flask_socketio import SocketIO, emit, join_room, leave_room
from utils.chat_storage import (
    create_new_conversation,
    add_message_to_conversation,
    get_conversation_by_id,
    get_conversation_history,
    delete_conversation,
    rename_conversation
)

app = Flask(__name__, static_folder='static')
app.secret_key = 'sua_chave_secreta_aqui'
socketio = SocketIO(app, async_mode='eventlet', cors_allowed_origins="*")

API_URL = "http://localhost:11434/v1/chat/completions"
MODEL_NAME = "gemma2:2b"
youtube_handler = YoutubeHandler()

@app.route('/')
def home():
    conversations = get_conversation_history()
    return render_template('index.html', conversations=conversations)

@app.route('/get_conversation_history')
def conversation_history():
    try:
        conversations = get_conversation_history()
        return jsonify(conversations)
    except Exception as e:
        print(f"[ERRO] Falha ao obter histórico de conversas: {str(e)}")
        return jsonify({'error': str(e)}), 500

@app.route('/get_conversation/<conversation_id>')
def get_conversation(conversation_id):
    try:
        conversation = get_conversation_by_id(conversation_id)
        if conversation:
            return jsonify(conversation)
        print(f"[ERRO] Conversa não encontrada: {conversation_id}")
        return jsonify({'error': 'Conversa não encontrada'}), 404
    except Exception as e:
        print(f"[ERRO] Falha ao obter conversa: {str(e)}")
        return jsonify({'error': str(e)}), 500

@app.route('/get_conversation/<conversation_id>/<int:offset>/<int:limit>')
def get_conversation_batch(conversation_id, offset, limit):
    """Endpoint para carregar mensagens em lotes para lazy loading"""
    try:
        conversation = get_conversation_by_id(conversation_id)
        if conversation:
            messages = conversation['messages']
            # Garantir que offset e limit estão dentro dos limites
            offset = min(offset, len(messages))
            end_index = min(offset + limit, len(messages))
            batch = messages[offset:end_index]
            
            return jsonify({
                'messages': batch,
                'total': len(messages),
                'hasMore': end_index < len(messages)
            })
        
        print(f"[ERRO] Conversa não encontrada para batch loading: {conversation_id}")
        return jsonify({'error': 'Conversa não encontrada'}), 404
    except Exception as e:
        print(f"[ERRO] Falha ao obter lote de mensagens: {str(e)}")
        return jsonify({'error': str(e)}), 500

@app.route('/stream')
def stream():
    """Endpoint para streaming de respostas usando Server-Sent Events (SSE)"""
    conversation_id = request.args.get('conversation_id')
    message = request.args.get('message', '')
    
    if not conversation_id:
        return jsonify({'error': 'ID de conversa não fornecido'}), 400
        
    print(f"[DEBUG] Iniciando streaming para conversa: {conversation_id}")
    
    def event_stream():
        for part in process_with_ai_stream(message, conversation_id):
            if part:
                yield f"data: {part}\n\n"
                
    response = Response(event_stream(), content_type="text/event-stream")
    response.headers['Cache-Control'] = 'no-cache'
    response.headers['X-Accel-Buffering'] = 'no'  # Para Nginx
    return response

@app.route('/send_message', methods=['POST'])
def send_message():
    data = request.json
    message = data.get('message', '')
    conversation_id = data.get('conversation_id')

    if not conversation_id:
        conversation_id = create_new_conversation()
        print(f"[DEBUG] Nova conversa criada com ID: {conversation_id}")
    else:
        print(f"[DEBUG] Usando conversa existente: {conversation_id}")

    # Salvar mensagem do usuário
    add_message_to_conversation(conversation_id, message, "user")
    print(f"[DEBUG] Mensagem do usuário salva na conversa: {conversation_id}")

    # Processar resposta da IA
    accumulated_response = []
    
    def generate_streamed_response():
        for part in process_with_ai_stream(message, conversation_id):
            if part:
                accumulated_response.append(part)
                # Emitir via WebSocket além do SSE
                socketio.emit('message_chunk', {
                    'content': part, 
                    'conversation_id': conversation_id
                }, room=conversation_id)
                yield f"data: {json.dumps({'content': part, 'conversation_id': conversation_id})}\n\n"
        
        # Salvar a resposta completa da IA - APENAS UMA VEZ
        if accumulated_response:
            complete_response = ''.join(accumulated_response)
            print(f"[DEBUG] Salvando resposta única para {conversation_id}")
            add_message_to_conversation(conversation_id, complete_response, "assistant")
            # Notificar todas as abas conectadas que a conversa foi atualizada
            socketio.emit('conversation_updated', {
                'conversation_id': conversation_id
            })
            print(f"[DEBUG] Resposta completa da IA salva na conversa: {conversation_id}")

    response = Response(generate_streamed_response(), content_type="text/event-stream")
    response.headers['Cache-Control'] = 'no-cache'
    return response

@app.route('/save_message', methods=['POST'])
def save_message():
    try:
        data = request.json
        conversation_id = data.get('conversation_id')
        content = data.get('content')
        role = data.get('role')
        
        if not all([conversation_id, content, role]):
            return jsonify({'error': 'Dados incompletos'}), 400
        
        print(f"[DEBUG] Salvando mensagem para conversa: {conversation_id}, role: {role}")
        add_message_to_conversation(conversation_id, content, role)
        
        # Notificar clientes via WebSocket
        socketio.emit('conversation_updated', {
            'conversation_id': conversation_id
        })
        
        return jsonify({'status': 'success', 'conversation_id': conversation_id})
    except Exception as e:
        print(f"Erro ao salvar mensagem: {str(e)}")
        return jsonify({'error': str(e)}), 500

@app.route('/process_youtube', methods=['POST'])
def process_youtube():
    try:
        data = request.json
        video_url = data.get('video_url')
        conversation_id = data.get('conversation_id')
        comando = data.get('comando')  # Novo: pegar o comando original
        
        if not video_url:
            return jsonify({'error': 'URL não fornecida'}), 400
            
        # Baixar legendas e obter título
        subtitle_file, video_title = youtube_handler.download_subtitles(video_url)
        if not subtitle_file:
            return jsonify({'error': 'Não foi possível baixar as legendas deste vídeo'}), 404
            
        # Limpar legendas
        cleaned_text = youtube_handler.clean_subtitles(subtitle_file)
        if not cleaned_text:
            return jsonify({'error': 'Erro ao processar legendas'}), 500

        # Salvar comando do usuário na conversa
        if conversation_id and comando:
            add_message_to_conversation(
                conversation_id,
                comando,
                "user"
            )
            print(f"[DEBUG] Comando do usuário salvo na conversa: {conversation_id}")

        # Salvar transcrição com título na conversa
        formatted_response = f"📹 {video_title}\n\n{cleaned_text}"
        if conversation_id:
            add_message_to_conversation(
                conversation_id,
                formatted_response,
                "assistant"
            )
            print(f"[DEBUG] Resposta do YouTube salva na conversa: {conversation_id}")
            
            # Notificar via WebSocket
            socketio.emit('conversation_updated', {
                'conversation_id': conversation_id
            })
            
        return jsonify({
            'text': formatted_response,
            'title': video_title,
            'conversation_id': conversation_id
        })
        
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/rename_conversation/<conversation_id>', methods=['POST'])
def handle_rename_conversation(conversation_id):
    try:
        print(f"[BACKEND] Recebendo solicitação para renomear conversa: {conversation_id}")
        
        # Forçar decodificação do corpo JSON
        data = request.get_json(force=True, silent=True)
        if not data:
            data = {}
            print("[BACKEND] Request body vazio ou inválido")
        
        new_title = data.get('title', '').strip()
        print(f"[BACKEND] Novo título: '{new_title}'")
        
        if not new_title:
            print("[BACKEND] Título inválido")
            return jsonify({'error': 'Título inválido'}), 400
            
        success = rename_conversation(conversation_id, new_title)
        if success:
            print(f"[BACKEND] Conversa renomeada com sucesso para: {new_title}")
            
            # Notificar via WebSocket
            socketio.emit('conversation_renamed', {
                'conversation_id': conversation_id,
                'new_title': new_title
            })
            
            return jsonify({'success': True, 'new_title': new_title, 'conversation_id': conversation_id})
        else:
            print("[BACKEND] Falha ao renomear conversa")
            return jsonify({'error': 'Falha ao renomear conversa'}), 500
    except Exception as e:
        print(f"[BACKEND] Erro ao renomear conversa: {str(e)}")
        return jsonify({'error': str(e)}), 500

@app.route('/delete_conversation/<conversation_id>', methods=['DELETE'])
def handle_delete_conversation(conversation_id):
    try:
        print(f"[BACKEND] Recebendo solicitação para excluir conversa: {conversation_id}")
        
        success = delete_conversation(conversation_id)
        if success:
            print(f"[BACKEND] Conversa {conversation_id} excluída com sucesso")
            
            # Notificar via WebSocket
            socketio.emit('conversation_deleted', {
                'conversation_id': conversation_id
            })
            
            return jsonify({'success': True, 'conversation_id': conversation_id})
        else:
            print(f"[BACKEND] Falha ao excluir conversa {conversation_id}")
            return jsonify({'error': 'Falha ao excluir conversa'}), 500
    except Exception as e:
        print(f"[BACKEND] Erro ao excluir conversa: {str(e)}")
        return jsonify({'error': str(e)}), 500

# ---- WebSocket event handlers ----

@socketio.on('connect')
def handle_connect():
    print(f"[SOCKET] Cliente conectado: {request.sid}")

@socketio.on('disconnect')
def handle_disconnect():
    print(f"[SOCKET] Cliente desconectado: {request.sid}")

@socketio.on('join_conversation')
def handle_join_conversation(data):
    conversation_id = data.get('conversation_id')
    if conversation_id:
        join_room(conversation_id)
        print(f"[SOCKET] Cliente {request.sid} entrou na sala: {conversation_id}")

@socketio.on('leave_conversation')
def handle_leave_conversation(data):
    conversation_id = data.get('conversation_id')
    if conversation_id:
        leave_room(conversation_id)
        print(f"[SOCKET] Cliente {request.sid} saiu da sala: {conversation_id}")

def process_with_ai(text, conversation_id=None):
    try:
        # Incluir o ID da conversa no contexto para rastreamento
        context_header = f"[Conversa: {conversation_id}] " if conversation_id else ""
        print(f"{context_header}Processando com IA: {text[:50]}...")
        
        payload = {
            "model": MODEL_NAME,
            "messages": [
                {"role": "system", "content": "Você é um assistente útil. Formate suas respostas em Markdown. Use acentos graves triplos (```) APENAS para blocos de código, especificando a linguagem (ex.: ```python). NUNCA coloque texto explicativo dentro de blocos de código."},
                {"role": "user", "content": text}
            ],
            "stream": False
        }
        headers = {"Content-Type": "application/json"}
        response = requests.post(API_URL, json=payload, headers=headers)
        response.raise_for_status()

        response_data = response.json()
        if 'choices' in response_data and len(response_data['choices']) > 0:
            return response_data['choices'][0]['message']['content']
        return "Erro: Nenhuma resposta válida recebida da IA."
    except requests.exceptions.RequestException as e:
        print(f"[Debug] Erro na requisição HTTP: {str(e)}")
        return "Ocorreu um erro ao se conectar com a IA."
    except Exception as e:
        print(f"[Debug] Erro inesperado: {str(e)}")
        return "Ocorreu um erro inesperado ao processar sua mensagem."

def process_with_ai_stream(text, conversation_id=None):
    try:
        # Incluir o ID da conversa no contexto para rastreamento
        context_header = f"[Conversa: {conversation_id}] " if conversation_id else ""
        print(f"{context_header}Iniciando streaming para: {text[:50]}...")
        
        # Opção para incluir histórico de mensagens da conversa específica
        conversation = None
        if conversation_id:
            conversation = get_conversation_by_id(conversation_id)
        
        # Mensagem do sistema é sempre necessária
        messages = [{"role": "system", "content": "Você é um assistente útil. Formate suas respostas em Markdown. Use acentos graves triplos (```) APENAS para blocos de código, especificando a linguagem (ex.: ```python). NUNCA coloque texto explicativo dentro de blocos de código. Exemplo:\nTexto normal aqui.\n```python\nprint('Código aqui')\n```\nMais texto normal aqui."}]
        
        # Adicionar mensagem do usuário
        messages.append({"role": "user", "content": text})
        
        payload = {
            "model": MODEL_NAME,
            "messages": messages,
            "stream": True
        }
        headers = {"Content-Type": "application/json"}
        response = requests.post(API_URL, json=payload, headers=headers, stream=True)
        response.raise_for_status()

        for line in response.iter_lines(decode_unicode=True):
            if line.strip() and line.startswith("data: "):
                line = line[6:].strip()
                try:
                    response_data = json.loads(line)
                    if 'choices' in response_data and len(response_data['choices']) > 0:
                        delta = response_data['choices'][0]['delta']
                        if "content" in delta:
                            content = delta["content"].encode('latin1').decode('utf-8', errors='ignore')
                            print(f"{context_header}Chunk: {len(content)} caracteres")
                            yield content
                except json.JSONDecodeError:
                    print(f"[Debug] Erro ao decodificar JSON: {line}")
    except requests.exceptions.RequestException as e:
        print(f"[Debug] Erro na requisição HTTP: {str(e)}")
    except Exception as e:
        print(f"[Debug] Erro inesperado: {str(e)}")

if __name__ == '__main__':
    print("Iniciando servidor com Eventlet em modo de desenvolvimento...")
    socketio.run(app, debug=True, host='0.0.0.0', port=5000, use_reloader=False)




Conteúdo de conversation_1741174682053.json:
{
  "id": "1741174682053",
  "title": "faça uma calculadora em py",
  "timestamp": "2025-03-05T08:40:19.825438",
  "messages": [
    {
      "role": "assistant",
      "content": "## Bolo Simples com Canela\n\n**Ingredientes:**\n\n| Item             | Quantidade |\n| --------------- | --------- |\n| Farinha        | 2 xícaras (250g)  |\n| açúcar        | 1 xícara (200g)   |\n| Leite        | 1 xícara (240ml)   |\n| Ovos          | 3                      |\n| Amido de milho | 1 colher de sopa (15g) |\n| Canela em pó   | 1 colher de chá (2g)  | \n\n**Preparo:**\n\n1. **Pré-aqueça o forno:**  A 180°C. Unte uma forma redonda com furo no centro e polvilhe farinha para evitar grudar.\n2. **Misture os ingredientes secos:** Em uma tigela grande, misture a farinha, o açúcar e a canela em pó.\n3. **Junte os ingredientes úmidos:** À batedeira ou fouet, adicione o leite aos ovos batendo até obter um creme homogêneo. \n4. **Adicione os ingredientes molhados:** Despeje a mistura líquida na tigela com os ingredientes secos e misture delicadamente até formar uma massa lisa e uniforme. Não bata muito.\n5. **Asse o bolo:**  Leve ao forno pré-aquecido por  30 minutos ou até que um palito inserido no centro saia limpo. \n6. **Deixe esfriar:** Retire o bolo do forno e deixe esfriar na forma antes de desenformar. \n\n**Dica:** Experimente adicionar uma calda de chocolate à sua base para aumentar a textura! \n\n\n\n",
      "timestamp": "2025-03-05T08:38:56.103283"
    },
    {
      "role": "user",
      "content": "faça uma calculadora em py",
      "timestamp": "2025-03-05T08:39:11.531380"
    },
    {
      "role": "assistant",
      "content": "```python \ndef soma(x, y):\n  \"\"\"Soma dois números.\"\"\"\n  return x + y\n\ndef subtracao(x, y):\n  \"\"\"Subtrai dois números.\"\"\"\n  return x - y\n\ndef multiplicacao(x, y):\n  \"\"\"Multiplica dois números.\"\"\"\n  return x * y\n\ndef divisao(x, y):\n  \"\"\"Divide dois números.\"\"\"\n  if y == 0:\n    return \"Erro! Divisão por zero.\"\n  else:\n    return x / y\n\nwhile True:\n  print(\"Selecione a operação:\")\n  print(\"1. Soma\")\n  print(\"2. Subtração\")\n  print(\"3. Multiplicação\")\n  print(\"4. Divisão\")\n  print(\"5. Sair\") \n\n  escolha = input(\"\\nDigite a opção desejada (1/2/3/4/5): \")\n\n  if escolha in ('1', '2', '3', '4'):\n    try:\n      num1 = float(input(\"\\nDigite o primeiro número: \"))\n      num2 = float(input(\"Digite o segundo número: \"))\n    except ValueError:\n      print(\"Entrada inválida. Digite um valor numérico.\")\n      continue\n\n  op = escolha\n    \n  if op == '1': \n    print(f\"{num1} + {num2} = {soma(num1, num2)}\")\n\n  elif op == '2':\n    print(f\"{num1} - {num2} = {subtracao(num1, num2)}\")\n\n  elif op == '3': \n    print(f\"{num1} * {num2} = {multiplicacao(num1, num2)}\")\n\n  elif op == '4': \n    print(f\"{num1} / {num2} = {divisao(num1, num2)}\")\n\n  elif escolha == '5': \n    break \n\n  else:\n    print(\"Opção inválida. Por favor, digite de 1 a 5.\")  \n```\n\n\nEste código é um programa simples de calculadora que implementa quatro operações básicas: soma, subtração, multiplicação e divisão. Ele aceita dois números como entrada do usuário e realiza as operações correspondentes. \n\nPara executar o código, salve-o em um arquivo `.py` (por exemplo, `calculadora.py`) e, em seguida, utilize o terminal para executá-lo com o comando `python calculadora.py`.",
      "timestamp": "2025-03-05T08:40:19.825438"
    }
  ]
}

Conteúdo de conversation_1741737581748.json:
{
  "id": "1741737581748",
  "title": "imprima oi em py",
  "timestamp": "2025-03-11T21:22:05.823593",
  "messages": [
    {
      "role": "user",
      "content": "imprima oi em py",
      "timestamp": "2025-03-11T20:59:41.756681"
    },
    {
      "role": "assistant",
      "content": "```python\nprint(\"oi\") \n``` \n",
      "timestamp": "2025-03-11T20:59:55.336260"
    },
    {
      "role": "user",
      "content": "oi",
      "timestamp": "2025-03-11T21:21:50.362296"
    },
    {
      "role": "assistant",
      "content": "Olá! 👋  Como posso te ajudar hoje? 😊 \n",
      "timestamp": "2025-03-11T21:22:05.823593"
    }
  ]
}

Conteúdo de index.json:
[
  {
    "id": "1741737581748",
    "title": "imprima oi em py",
    "timestamp": "2025-03-11T21:22:05.823593",
    "filename": "conversation_1741737581748.json"
  },
  {
    "id": "1741174682053",
    "title": "faça uma calculadora em py",
    "timestamp": "2025-03-05T08:40:19.825438",
    "filename": "conversation_1741174682053.json"
  }
]

Conteúdo de DevMenu.bat:
@echo off
setlocal enabledelayedexpansion

goto menu_principal

:menu_principal
cls
echo Diretorio atual: %cd%
echo =====================================
echo MENU PRINCIPAL
echo =====================================
echo 1. Abrir no VS Code
echo 2. Atualizar Git
echo 3. Executar Script Python
echo 4. Sair
echo =====================================
set /p escolha="Escolha uma opcao: "

if "%escolha%"=="1" goto abrir_vscode
if "%escolha%"=="2" goto atualizar_git
if "%escolha%"=="3" goto executar_python
if "%escolha%"=="4" goto fim
goto menu_principal

:abrir_vscode
cls
echo Abrindo no VS Code...
start "" cmd /c "code . && exit /b 0"
echo.
echo VS Code aberto. Pressione qualquer tecla para voltar ao menu principal...
pause >nul
goto menu_principal

:atualizar_git
cd /d %~dp0
cls
echo Diretorio atual: %cd%
echo =====================================
echo GIT AUTOMATION MENU
echo =====================================
echo 1. Verificar status do repositorio
echo 2. Adicionar todas as alteracoes
echo 3. Fazer commit
echo 4. Fazer push para o GitHub
echo 5. Fazer pull do repositorio
echo 6. Mostrar log de commits
echo 7. Outras opcoes
echo 8. Voltar ao menu principal
echo =====================================
set /p escolha="Escolha uma opcao: "

if "%escolha%"=="1" goto status
if "%escolha%"=="2" goto add
if "%escolha%"=="3" goto commit
if "%escolha%"=="4" goto push
if "%escolha%"=="5" goto pull
if "%escolha%"=="6" goto log
if "%escolha%"=="7" goto outras_opcoes
if "%escolha%"=="8" goto menu_principal
goto atualizar_git

:status
echo Verificando o status do repositorio...
git status
pause
goto atualizar_git

:add
echo Adicionando todas as alteracoes...
git add .
pause
goto atualizar_git

:commit
set /p comentario="Digite o comentario do commit: "
git commit -m "%comentario%"
pause
goto atualizar_git

:push
echo Fazendo push para o GitHub...
git push
pause
goto atualizar_git

:pull
echo Fazendo pull do repositorio...
git pull
pause
goto atualizar_git

:log
echo Mostrando log de commits...
git log
pause
goto atualizar_git

:outras_opcoes
cls
echo Outras opcoes
echo =====================================
echo 1. Restaurar arquivos deletados
echo 2. Sincronizar com repositorio
echo 3. Fazer fetch do repositorio
echo 4. Fazer merge de branches
echo 5. Inicializar um novo repositorio (git init)
echo 6. Desfazer alteracoes (git reset)
echo 7. Listar branches (git branch)
echo 8. Voltar ao menu Git
echo =====================================
set /p escolha_outras="Escolha uma opcao: "

if "%escolha_outras%"=="1" goto restaurar
if "%escolha_outras%"=="2" goto sincronizar
if "%escolha_outras%"=="3" goto fetch
if "%escolha_outras%"=="4" goto merge
if "%escolha_outras%"=="5" goto init
if "%escolha_outras%"=="6" goto reset
if "%escolha_outras%"=="7" goto branch
if "%escolha_outras%"=="8" goto atualizar_git
goto outras_opcoes

:restaurar
echo Restaurando arquivos deletados...
git checkout -- .
pause
goto outras_opcoes

:sincronizar
echo Sincronizando com repositorio...
git fetch origin
pause
goto outras_opcoes

:fetch
echo Fazendo fetch do repositorio...
git fetch
pause
goto outras_opcoes

:merge
echo Fazendo merge de branches...
git merge
pause
goto outras_opcoes

:init
echo Inicializando um novo repositorio...
git init
pause
goto outras_opcoes

:reset
echo Desfazendo alteracoes...
git reset
pause
goto outras_opcoes

:branch
echo Listando branches...
git branch
pause
goto outras_opcoes

:executar_python
setlocal enabledelayedexpansion
for /f "delims=" %%P in ('where python 2^>nul') do (
    set "python_path=%%P"
    goto :list_files
)

if not defined python_path (
    echo Python nao encontrado no sistema!
    pause
    goto menu_principal
)

:list_files
cd /d %~dp0
set "counter=0"
echo.
echo Arquivos Python encontrados:
for %%i in (*.py) do (
    set /a counter+=1
    set "file_!counter!=%%i"
    echo [!counter!] %%i
)

if %counter% equ 0 (
    echo Nenhum arquivo Python encontrado neste diretorio.
    pause
    goto menu_principal
)

echo.
set /p "file_num=Digite o numero do arquivo que deseja executar: "
set /a file_num=%file_num%
for /l %%n in (1,1,%counter%) do (
    if %%n equ %file_num% (
        echo Executando: !file_%%n!
        "%python_path%" "!file_%%n!"
        echo.
        echo Pressione qualquer tecla para voltar ao menu principal...
        pause >nul
    )
)
endlocal
goto menu_principal

:fim
echo Saindo...
pause
exit

Conteúdo de DOCUMENTACAO.md:

# Documentação do Projeto - Sistema de Chat com IA

## 1. Visão Geral do Projeto

### Descrição Geral
O projeto é um sistema de chat interativo que utiliza inteligência artificial para gerar respostas contextualizadas. É baseado em uma arquitetura cliente-servidor usando Flask como backend e uma interface web responsiva.

### Objetivo e Funcionalidades Principais
- Fornecer uma interface de chat intuitiva para interação com IA
- Gerenciar histórico de conversas
- Permitir criação de novas conversas
- Suportar temas claro/escuro
- Salvar conversas em arquivos JSON para persistência

### Tecnologias Utilizadas
- **Backend**: Python/Flask
- **Frontend**: HTML, CSS, JavaScript
- **Armazenamento**: Sistema de arquivos (JSON)
- **IA**: Integração com modelo de linguagem

## 2. Árvore de Diretórios

```
Projeto/
├── app.py                     # Aplicação principal Flask
├── static/
│   ├── css/                  # Estilos da aplicação
│   │   ├── styles.css       # Estilos principais
│   │   ├── base/           # Estilos base
│   │   ├── components/     # Estilos de componentes
│   │   ├── layout/        # Estilos de layout
│   │   └── themes/        # Temas claro/escuro
│   │
│   └── js/                   # Scripts JavaScript
│       ├── main.js          # Script principal
│       ├── chat.js         # Lógica do chat
│       ├── sidebar.js      # Controle da barra lateral
│       ├── theme.js        # Controle de tema
│       ├── events.js       # Gerenciamento de eventos
│       ├── init.js         # Inicialização
│       └── utils.js        # Funções utilitárias
│
├── templates/
│   └── index.html            # Template principal
│
├── utils/
│   ├── chat_storage.py      # Gerenciamento de armazenamento
│   ├── chat_history.py      # Manipulação do histórico
│   └── text_processor.py    # Processamento de texto
│
└── data/                     # Diretório de dados
    └── conversations/        # Armazenamento de conversas

```

## 3. Descrição Detalhada das Funções

### Backend (app.py)

#### Rotas Principais:
- `@app.route('/')`: Renderiza a página inicial
- `@app.route('/send_message')`: Processa mensagens e retorna respostas da IA
- `@app.route('/get_conversation_history')`: Retorna histórico de conversas
- `@app.route('/get_conversation/<conversation_id>')`: Obtém conversa específica

#### Funções de Processamento:
- `process_with_ai(text)`: Processa texto com IA
- `process_with_ai_stream(text)`: Versão streaming do processamento

### Utilitários (utils/)

#### chat_storage.py:
- `ensure_directories()`: Garante existência dos diretórios necessários
- `create_new_conversation()`: Cria nova conversa
- `save_conversation()`: Salva conversa em arquivo
- `get_conversation_by_id()`: Recupera conversa por ID

#### chat_history.py:
- `get_conversation_history()`: Obtém histórico completo
- `save_conversation()`: Salva conversa no histórico
- `get_conversation_by_id()`: Busca conversa específica

### Frontend (static/js/)

#### main.js:
- Inicialização da aplicação
- Gerenciamento de estado global
- Configuração de event listeners

#### chat.js:
- `iniciarChat()`: Inicia nova sessão de chat
- `enviarMensagem()`: Envia mensagem para o backend
- `adicionarMensagem()`: Adiciona mensagem na interface
- `carregarConversa()`: Carrega conversa existente

## 4. Fluxo de Execução

1. **Inicialização**:
   - Servidor Flask inicia (app.py)
   - Diretórios são verificados/criados
   - Interface web é carregada

2. **Interação do Usuário**:
   - Usuário inicia nova conversa ou carrega existente
   - Mensagens são enviadas via interface
   - Backend processa com IA
   - Respostas são exibidas em tempo real

3. **Armazenamento**:
   - Conversas são salvas automaticamente
   - Histórico é mantido em arquivos JSON
   - Dados persistem entre sessões

## 5. Estrutura do Código

O projeto segue uma arquitetura MVC simplificada:
- **Modelo**: Gerenciamento de dados em JSON
- **Visão**: Templates HTML e estilos CSS
- **Controlador**: Rotas Flask e lógica JavaScript

### Boas Práticas:
- Separação de responsabilidades
- Modularização do código
- Armazenamento persistente
- Tratamento de erros

## 6. Instruções de Instalação

1. **Preparação do Ambiente**:
```bash
# Criar ambiente virtual
python -m venv venv

# Ativar ambiente
# Windows:
venv\Scripts\activate
# Linux/Mac:
source venv/bin/activate

# Instalar dependências
pip install -r requirements.txt
```

2. **Configuração**:
- Garantir que Python 3.6+ está instalado
- Verificar permissões de escrita no diretório data/

3. **Execução**:
```bash
python app.py
```
- Acessar http://localhost:5000 no navegador

## 7. Considerações Finais

### Melhorias Sugeridas:
1. Implementar autenticação de usuários
2. Adicionar suporte a múltiplos modelos de IA
3. Melhorar sistema de backup de conversas
4. Implementar busca no histórico
5. Adicionar suporte a markdown nas mensagens

### Funcionalidades Futuras:
1. Exportação de conversas em diferentes formatos
2. Compartilhamento de conversas
3. Personalização avançada da interface
4. Integração com APIs externas
5. Sistema de tags para organização



Conteúdo de init_eventlet.py:

# Arquivo de inicialização para garantir que o monkey patching do Eventlet
# seja executado antes de qualquer outro import em todo o projeto
import eventlet
eventlet.monkey_patch()
print("[INFO] Eventlet monkey patching aplicado com sucesso.")


Conteúdo de README.md:
# Projeto Guilherme – Clone de IA Conversacional

## Introdução
O Projeto Guilherme é um sistema de inteligência artificial conversacional inspirado no OpenWebUI. O objetivo principal é criar uma interface de chat interativa e persistente, semelhante ao ChatGPT. O projeto foi desenvolvido com foco na simplicidade e eficiência, eliminando a necessidade de um banco de dados tradicional para armazenamento de histórico.

## Objetivo do Projeto
O objetivo é oferecer uma IA conversacional independente, capaz de interagir com os usuários de forma natural. O histórico das conversas será armazenado em arquivos JSON individuais, garantindo a persistência dos dados entre recarregamentos da página.

## Tecnologias Utilizadas
- **Flask (Python)** → Backend leve e eficiente para gerenciar as requisições e a lógica do chat.
- **JavaScript, HTML5, CSS** → Construção da interface de usuário responsiva e dinâmica.
- **Armazenamento em JSON** → Cada conversa será salva em um arquivo separado dentro do diretório `data/`.

## Estrutura do Projeto
```
Projeto Guilherme/
├── app.py                     # Aplicação principal
├── static/
│   ├── css/                   # Estilos
│   ├── js/                    # Lógica frontend
├── templates/
│   ├── index.html             # Interface principal
├── utils/
│   ├── chat_storage.py        # Gerenciamento de histórico em arquivos JSON
│   ├── text_processor.py      # Utilitários para processamento de texto
├── data/                      # Diretório para armazenar os arquivos JSON das conversas
└── requirements.txt           # Lista de dependências do projeto
```

## Como Executar o Projeto
### 1. Clonar o Repositório
```bash
git clone https://github.com/seu-usuario/chat-ai.git
cd chat-ai
```
### 2. Configurar o Ambiente Virtual
```bash
python -m venv venv
source venv/bin/activate  # Linux/MacOS
venv\Scripts\activate     # Windows
```
### 3. Instalar Dependências
```bash
pip install -r requirements.txt
```
### 4. Executar o Servidor
```bash
python app.py
```
O servidor será iniciado localmente e estará disponível em `http://127.0.0.1:5000/`.

## Funcionalidades
✅ Interface de chat interativa
✅ Histórico de conversa salvo em arquivos JSON
✅ Persistência do histórico entre recarregamentos da página
✅ Processamento de mensagens e resposta dinâmica

## Status Atual
🚀 O projeto está em fase de desenvolvimento, com funcionalidades básicas implementadas e melhorias em andamento.

## Contribuição
Se desejar contribuir, sinta-se à vontade para abrir issues e pull requests no repositório!

## Licença
Este projeto está sob a licença MIT. Veja o arquivo `LICENSE` para mais detalhes.



Conteúdo de requirements.txt:

# Dependências principais
Flask==2.3.3
flask-socketio==5.3.6
eventlet==0.35.2
requests==2.31.0

# Dependências para processamento de texto
markdown==3.4.4
bleach==6.1.0

# Para download de legendas do YouTube
youtube_transcript_api==0.6.1

# Utilitários
python-dotenv==1.0.0


Conteúdo de start_server.bat:

@echo off
echo Iniciando o servidor NarrateNexus com Eventlet e suporte a WebSockets...
echo Certifique-se de ter instalado as dependencias necessarias:
echo pip install flask flask-socketio eventlet

REM Inicia o servidor usando o arquivo app.py diretamente
python app.py

pause


Conteúdo de reset.css:
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    transition: background-color 0.2s, color 0.2s;
}

body {
    font-family: 'Inter', sans-serif;
    background-color: var(--bg-primary);
    color: var(--text-primary);
    overflow: hidden;
}

Conteúdo de typography.css:
body {
    font-family: 'Inter', sans-serif;
    color: var(--text-primary);
}

h1, h2, h3, h4, h5, h6 {
    color: var(--text-primary);
}

Conteúdo de variables.css:

:root {
    --bg-primary: #f7f7f8;
    --text-primary: #000000;
    --text-secondary: rgba(0, 0, 0, 0.7);
    --text-disabled: rgba(0, 0, 0, 0.5);
    --action-active: #000000;
    --action-hover: rgba(0, 0, 0, 0.08);
    --action-selected: rgba(0, 0, 0, 0.16);
    --action-disabled: rgba(0, 0, 0, 0.3);
    --action-disabled-background: rgba(0, 0, 0, 0.12);
    --msg-user: #e6e6e6;
    --msg-bot: #d9d9d9;
    --sidebar-bg: #ffffff;
    --input-bg: #ffffff;
    --border-color: rgba(0, 0, 0, 0.12);
    --code-bg: #f8f8f8;
    --code-header-bg: #f1f1f1;
    --color-success: #4CAF50;
}

[data-theme="dark"] {
    --bg-primary: #343541;
    --text-primary: #fff;
    --text-secondary: rgba(255, 255, 255, 0.7);
    --text-disabled: rgba(255, 255, 255, 0.5);
    --action-active: #fff;
    --action-hover: rgba(255, 255, 255, 0.08);
    --action-selected: rgba(255, 255, 255, 0.16);
    --action-disabled: rgba(255, 255, 255, 0.3);
    --action-disabled-background: rgba(255, 255, 255, 0.12);
    --msg-user: #444654;
    --msg-bot: #444654;
    --sidebar-bg: #202123;
    --input-bg: #40414f;
    --border-color: rgba(255, 255, 255, 0.12);
    --code-bg: #1e1e1e;
    --code-header-bg: #2d2d2d;
    --color-success: #4CAF50;
}


Conteúdo de buttons.css:
.new-chat-btn {
    background-color: #19c37d;
    color: white;
    border: none;
    padding: 12px;
    border-radius: 5px;
    cursor: pointer;
    margin-bottom: 1rem;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.5rem;
}

.new-chat-btn:hover {
    background-color: #15a76c;
}

.settings-btn {
    margin-top: auto;
    padding: 12px;
    border: none;
    border-radius: 5px;
    background-color: transparent;
    color: var(--text-primary);
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 0.5rem;
    transition: background-color 0.2s;
}

.settings-btn:hover {
    background-color: var(--action-hover);
}

.theme-toggle, .header-sidebar-toggle {
    width: 32px;
    height: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: var(--action-hover);
    border: none;
    border-radius: 4px;
    color: var(--text-primary);
    cursor: pointer;
}

.theme-toggle:hover, .header-sidebar-toggle:hover {
    background: var(--action-selected);
}

.quick-action-btn {
    padding: 1rem;
    border: 1px solid var(--border-color);
    border-radius: 0.5rem;
    background-color: var(--input-bg);
    color: var(--text-primary);
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 0.5rem;
    transition: all 0.2s;
}

.quick-action-btn:hover {
    background-color: var(--action-hover);
}

Conteúdo de code-highlight.css:

/* Container para blocos de código */
.code-container {
    position: relative;
    margin: 1rem 0;
    border-radius: 6px;
    overflow: hidden;
    background-color: #1e1e1e !important; /* Fundo fixo escuro */
    border: 1px solid var(--border-color);
}

/* Cabeçalho do bloco de código */
.code-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.5rem 1rem;
    background-color: #2d2d2d !important; /* Cabeçalho um pouco mais claro que o fundo */
    color: #d4d4d4;
    font-family: monospace;
    font-size: 0.875rem;
}

/* Rótulo de linguagem */
.language-label {
    font-weight: 500;
    text-transform: uppercase;
    font-size: 0.75rem;
    letter-spacing: 0.5px;
}

/* Botão de copiar código */
.code-copy-btn {
    background: none;
    border: none;
    color: rgba(255, 255, 255, 0.7);
    cursor: pointer;
    padding: 0.25rem 0.5rem;
    transition: color 0.2s;
    font-size: 0.875rem;
}

.code-copy-btn:hover {
    color: #ffffff;
}

.code-copy-btn.copied {
    color: var(--color-success);
}

/* Bloco de código */
.code-block {
    margin: 0;
    padding: 1rem;
    background-color: #1e1e1e !important; /* Fundo fixo escuro */
    overflow-x: auto;
}

.code-block code {
    display: block;
    background-color: transparent !important; /* Remover fundo do <code> para usar o do .code-block */
    font-family: 'Fira Code', Consolas, Monaco, 'Andale Mono', monospace;
    font-size: 0.875rem;
    line-height: 1.5;
    color: #d4d4d4;
}

/* Forçar o tema de cores highlight.js para os blocos de código */
.hljs {
    background: transparent !important; /* O fundo vem do .code-block */
    color: #d4d4d4 !important; /* Cor base do texto para fundo escuro */
}

/* Forçar fundo escuro em ambos os temas */
[data-theme="light"] .code-container,
[data-theme="light"] .code-block,
[data-theme="light"] pre code,
[data-theme="dark"] .code-container,
[data-theme="dark"] .code-block,
[data-theme="dark"] pre code {
    background-color: #1e1e1e !important;
    color: #d4d4d4 !important;
}

/* Cores de sintaxe para highlight.js - sempre usar cores para tema escuro */
.hljs-keyword { color: #569cd6 !important; }
.hljs-string { color: #ce9178 !important; }
.hljs-comment { color: #6a9955 !important; }
.hljs-function { color: #dcdcaa !important; }
.hljs-number { color: #b5cea8 !important; }


Conteúdo de command-menu.css:

.command-menu {
    position: absolute;
    bottom: 100%;
    left: 0;
    width: 100%;
    max-height: 200px;
    overflow-y: auto;
    background-color: var(--bg-primary);
    border: 1px solid var(--border-color);
    border-radius: 4px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    display: none;
    z-index: 1000;
}

.command-menu.show {
    display: block;
}

.command-menu-item {
    padding: 8px 16px;
    cursor: pointer;
    transition: background-color 0.2s;
}

.command-menu-item:hover {
    background-color: var(--hover-color);
}

.chat-item {
    cursor: pointer;
    transition: all 0.2s;
    user-select: none;
    pointer-events: all;
}

.chat-item * {
    pointer-events: none;
}

.chat-item:hover {
    background-color: var(--hover-color);
}

.chat-item.active {
    background-color: var(--selected-color);
}


Conteúdo de forms.css:
.search-box {
    position: relative;
    margin-bottom: 1rem;
}

.search-box input {
    width: 100%;
    padding: 0.75rem;
    border: 1px solid var(--border-color);
    border-radius: 5px;
    background-color: var(--input-bg);
    color: var(--text-primary);
}

.input-box {
    display: flex;
    gap: 1rem;
    width: 100%;
    max-width: 800px;
    margin-bottom: 2rem;
    position: relative;
}

.input-box textarea {
    width: 100%;
    padding: 1rem;
    padding-right: 3.5rem;
    border: 1px solid var(--border-color);
    border-radius: 0.5rem;
    background-color: var(--input-bg);
    color: var(--text-primary);
    font-size: 1rem;
    resize: none;
    min-height: 56px;
    max-height: 200px;
    line-height: 1.5;
    scrollbar-width: none;
    -ms-overflow-style: none;
}

.input-box textarea::-webkit-scrollbar {
    display: none;
}

.input-box .send-btn,
.input-box .stop-btn {
    position: absolute;
    right: 0.75rem;
    bottom: 0.75rem;
    background: transparent;
    border: none;
    color: var(--text-primary);
    cursor: pointer;
    padding: 0.5rem;
    border-radius: 4px;
    transition: all 0.2s;
    display: flex;
    align-items: center;
    justify-content: center;
}

.input-box .send-btn:hover,
.input-box .stop-btn:hover {
    background-color: var(--action-hover);
}

.input-box .stop-btn {
    right: 5rem;
    bottom: 0.5rem;
}

.quick-actions {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 1rem;
    width: 100%;
    max-width: 600px;
}

.model-select {
    padding: 0.5rem;
    border-radius: 4px;
    border: 1px solid var(--border-color);
    background-color: var(--input-bg);
    color: var(--text-primary);
}

Conteúdo de messages.css:
/* Botões de ação nas mensagens */
.message .action-btn {
    background: transparent;
    border: none;
    color: var(--text-secondary);
    padding: 0.5rem;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.3s ease;
}

.message .action-btn:hover {
    background-color: var(--action-hover);
    color: var(--text-primary);
}

.message .action-btn.copied {
    color: #4CAF50;
    background-color: rgba(76, 175, 80, 0.1);
}

.message .message-actions {
    position: absolute;
    top: 0.5rem;
    right: 0.5rem;
    display: none;
    gap: 0.5rem;
}

.message:hover .message-actions {
    display: flex;
}

/* Estilos para formatação de mensagens com Markdown */
.message-content {
    line-height: 1.6;
}

.message-content h1, 
.message-content h2, 
.message-content h3 {
    margin: 1rem 0 0.5rem 0;
    line-height: 1.2;
}

.message-content h1 {
    font-size: 1.5rem;
    border-bottom: 1px solid var(--border-color);
    padding-bottom: 0.5rem;
}

.message-content h2 {
    font-size: 1.3rem;
}

.message-content h3 {
    font-size: 1.1rem;
}

.message-content code {
    background-color: var(--action-hover);
    padding: 0.2em 0.4em;
    border-radius: 3px;
    font-family: monospace;
    font-size: 0.9em;
}

/* Container para o bloco de código com cabeçalho */
.code-container {
    position: relative;
    margin: 1em 0;
    border-radius: 5px;
    overflow: hidden;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    padding: 0; /* Remove padding extra */
}

.code-header {
    background-color: #2d2d2d !important;
    color: #ffffff;
    padding: 5px 10px;
    font-size: 0.9em;
    font-weight: bold;
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin: 0; /* Remove margens */
    border-bottom: none; /* Remove borda para colar com o bloco */
}

.language-label {
    text-transform: uppercase;
    font-size: 0.8em;
    letter-spacing: 1px;
    flex: 1; /* Expande para empurrar o botão */
}

/* Blocos de código estilo terminal */
.message-content .code-block {
    background-color: #1e1e1e !important; /* Fundo preto estilo terminal */
    color: #f8f8f2; /* Texto branco */
    padding: 15px;
    border-radius: 0; /* Remove bordas arredondadas para colar com o header */
    font-family: 'Consolas', 'Courier New', monospace;
    position: relative;
    overflow-x: auto; /* Para códigos longos */
    border: 1px solid #333;
    margin: 0; /* Remove margem para alinhar com o cabeçalho */
    border-top: none; /* Remove borda superior para colar com o header */
}

.message-content .code-block code {
    background: none !important;
    padding: 0;
    color: #f8f8f2 !important;
    display: block;
    white-space: pre;
}

/* Botão de copiar código */
.code-copy-btn {
    background: transparent;
    color: white;
    border: none;
    padding: 5px 8px;
    cursor: pointer;
    border-radius: 3px;
    font-size: 0.8rem;
    transition: background-color 0.2s;
    margin-left: auto; /* Alinha o botão à direita */
}

.code-copy-btn:hover {
    background: #666;
}

.code-copy-btn.copied {
    background: #4CAF50;
}

/* Estilos para tabelas Markdown */
.chat-container .message-content table {
    width: 100%; /* Ocupa toda a largura disponível */
    border-collapse: collapse; /* Une as bordas das células */
    margin: 0.5rem 0; /* Espaço reduzido acima e abaixo */
    padding: 0;
    table-layout: fixed; /* Evita células desproporcionais */
}

.chat-container .message-content th,
.chat-container .message-content td {
    border: 1px solid var(--border-color); /* Bordas visíveis */
    padding: 0.5rem; /* Espaço interno reduzido */
    text-align: left; /* Alinhamento à esquerda */
    vertical-align: top; /* Evita alinhamentos estranhos */
    word-wrap: break-word; /* Quebra palavras longas */
    overflow-wrap: break-word;
}

.chat-container .message-content th {
    background-color: var(--action-hover); /* Fundo leve para cabeçalhos */
    font-weight: bold; /* Cabeçalhos em negrito */
}

.chat-container .message-content tr:nth-child(even) {
    background-color: rgba(0, 0, 0, 0.05); /* Efeito zebrado nas linhas pares */
}

/* Ajuste para tema escuro, se necessário */
[data-theme="dark"] .chat-container .message-content th {
    background-color: var(--action-hover);
}

[data-theme="dark"] .chat-container .message-content tr:nth-child(even) {
    background-color: rgba(255, 255, 255, 0.05);
}

/* Estilos para citações */
.message-content blockquote {
    border-left: 4px solid var(--text-secondary);
    margin: 0.5rem 0;
    padding: 0.5rem 0 0.5rem 1rem;
    color: var(--text-secondary);
    background-color: rgba(125, 125, 125, 0.1);
    border-radius: 0 4px 4px 0;
}

/* Estilos para listas */
.message-content ul, 
.message-content ol {
    padding-left: 1.5rem;
    margin: 0.5rem 0;
}

.message-content ul li, 
.message-content ol li {
    margin-bottom: 0.25rem;
}

/* Estilos para links */
.message-content a {
    color: #3498db;
    text-decoration: none;
}

.message-content a:hover {
    text-decoration: underline;
}

/* Estilos para mensagens específicas */
.message.assistant .message-content {
    color: var(--text-primary);
}

.message.user .message-content {
    color: var(--text-primary);
}

/* Estilos para highlight.js */
.hljs {
    background: #1e1e1e !important;
    color: #d4d4d4 !important;
    font-family: 'Consolas', 'Courier New', monospace !important;
    line-height: 1.6 !important;
    tab-size: 4 !important;
}

/* Ajustes para temas claro/escuro */
[data-theme="dark"] .hljs {
    background: #1e1e1e !important;
    color: #d4d4d4 !important;
}

/* Forçar tema claro para o highlight.js */
[data-theme="light"] .hljs {
    background: #f8f8f8 !important;
    color: #333;
}

/* Força o fundo escuro para os blocos de código em ambos os temas */
[data-theme="light"] pre code,
[data-theme="dark"] pre code {
    background-color: #1e1e1e !important;
    color: #d4d4d4 !important;
}


Conteúdo de container.css:
.container {
    display: flex;
    height: 100vh;
    position: relative;
}

.input-container {
    padding: 1.5rem;
    border-top: 1px solid var(--border-color);
    max-width: 800px;
    margin: 0 auto;
    width: 100%;
}

/* Loading Animation */
.loading {
    display: flex;
    gap: 0.5rem;
    align-items: center;
    padding: 1rem;
}

.loading span {
    width: 8px;
    height: 8px;
    background-color: var(--text-primary);
    border-radius: 50%;
    animation: bounce 0.5s alternate infinite;
}

.loading span:nth-child(2) {
    animation-delay: 0.1s;
}

.loading span:nth-child(3) {
    animation-delay: 0.2s;
}

@keyframes bounce {
    to {
        transform: translateY(-4px);
    }
}

Conteúdo de main-content.css:
.main-content {
    flex: 1;
    margin-left: 260px;
    transition: margin-left 0.3s ease;
    display: flex;
    flex-direction: column;
    height: 100vh;
}

.main-content.expanded {
    margin-left: 0;
}

.chat-container {
    flex: 1;
    overflow-y: auto;
    padding: 2rem;
    max-width: 800px;
    margin: 0 auto;
    width: 100%;
    scrollbar-width: none;
    -ms-overflow-style: none;
}

.chat-container::-webkit-scrollbar {
    display: none;
}

.message {
    position: relative;
    max-width: 80%;
    margin-bottom: 1.5rem;
    padding: 1rem;
    border-radius: 0.5rem;
    line-height: 1.5;
}

.message.user {
    background-color: var(--msg-user);
    margin-left: auto;
    color: var(--text-primary);
}

.message.assistant {
    background-color: var(--msg-bot);
    margin-right: auto;
    color: var(--text-primary);
}

.message .message-actions {
    position: absolute;
    top: 0.5rem;
    right: 0.5rem;
    display: none;
    gap: 0.5rem;
}

.message:hover .message-actions {
    display: flex;
}

.message .action-btn {
    background: transparent;
    border: none;
    color: var(--text-secondary);
    padding: 0.5rem;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.2s;
}

.message .action-btn:hover {
    background-color: var(--action-hover);
    color: var(--text-primary);
}

/* Top Bar */
.top-bar {
    padding: 1rem;
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 1rem;
    border-bottom: 1px solid var(--border-color);
    background-color: var(--bg-primary);
}

.top-bar-actions {
    display: flex;
    align-items: center;
    gap: 1rem;
}

/* Welcome Screen */
.welcome-screen {
    flex: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 2rem;
    max-width: 800px;
    margin: 0 auto;
    width: 100%;
}

.welcome-screen h1 {
    font-size: 2rem;
    margin-bottom: 2rem;
    color: var(--text-primary);
}

Conteúdo de sidebar.css:

.sidebar {
    position: fixed;
    width: 260px;
    height: 100vh;
    background-color: var(--sidebar-bg);
    padding: 1rem;
    border-right: 1px solid var(--border-color);
    display: flex;
    flex-direction: column;
    transition: transform 0.3s ease;
    z-index: 1000;
}

.sidebar.collapsed {
    transform: translateX(-260px);
}

.chat-list {
    flex: 1;
    overflow-y: auto;
    scrollbar-width: thin;
    scrollbar-color: var(--text-disabled) transparent;
}

.chat-list::-webkit-scrollbar {
    width: 5px;
}

.chat-list::-webkit-scrollbar-track {
    background: transparent;
}

.chat-list::-webkit-scrollbar-thumb {
    background-color: var(--text-disabled);
    border-radius: 20px;
}

.chat-item {
    padding: 0.75rem;
    border-radius: 5px;
    cursor: pointer;
    margin-bottom: 0.5rem;
    display: flex;
    align-items: center;
    justify-content: space-between;
    transition: background-color 0.2s;
    position: relative;
}

.chat-item:hover {
    background-color: var(--action-hover);
}

.chat-item .action-buttons {
    display: none;
    gap: 5px;
    z-index: 100;
    position: absolute;
    right: 8px;
    top: 50%;
    transform: translateY(-50%);
    background: rgba(0, 0, 0, 0.7);
    padding: 3px;
    border-radius: 4px;
    pointer-events: auto;
}

.chat-item:hover .action-buttons {
    display: flex;
}

.chat-item .action-btn {
    background: #333;
    border: none;
    color: white;
    padding: 5px;
    border-radius: 3px;
    cursor: pointer;
    transition: all 0.2s;
    z-index: 200;
    pointer-events: auto;
    font-size: 12px;
    width: 24px;
    height: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.chat-item .action-btn i {
    font-size: 14px;
}

.chat-item .action-btn:hover {
    background-color: #444;
}

.chat-title {
    flex: 1;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    margin-right: 0.5rem;
}

.chat-item.active {
    background-color: var(--action-selected);
    font-weight: 500;
    border-left: 4px solid var(--color-success);
}


Conteúdo de styles.css:

@import './components/command-menu.css';

/* Reset e variáveis base */
@import './base/variables.css';

@import './base/reset.css';
@import './base/typography.css';

/* Layouts principais */
@import './layout/container.css';
@import './layout/sidebar.css';
@import './layout/main-content.css';

/* Componentes */
@import './components/buttons.css';
@import './components/forms.css';
@import './components/messages.css';
@import './components/code-highlight.css';

/* Temas */
@import './themes/light-theme.css';
@import './themes/dark-theme.css';

/* Importando tema do highlight.js */
@import url('https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css');
@import url('https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css') (prefers-color-scheme: dark);

.chat-container table {
  width: 100%; /* Faz a tabela ocupar toda a largura disponível */
  border-collapse: collapse; /* Une as bordas das células */
  margin: 1rem 0; /* Adiciona espaço acima e abaixo da tabela */
}

.chat-container th,
.chat-container td {
  border: 1px solid #ccc; /* Adiciona bordas visíveis às células */
  padding: 0.75rem; /* Dá espaço interno às células */
  text-align: left; /* Alinha o texto à esquerda */
}

.chat-container th {
  background-color: #f5f5f5; /* Fundo leve para os cabeçalhos */
  font-weight: bold; /* Deixa os cabeçalhos em negrito */
}

.chat-container tr:nth-child(even) {
  background-color: #fafafa; /* Efeito zebrado nas linhas pares */
}


.command-menu.visible {
    display: block !important;
}

.command-item {
    padding: 10px;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 8px;
    color: var(--text-primary);
}

.command-item:hover {
    background-color: var(--action-hover);
}

.command-icon {
    color: var(--text-secondary);
    width: 20px;
}

.command-text {
    font-weight: 500;
}

.command-description {
    font-size: 0.875rem;
    color: var(--text-secondary);
}

.command-menu {
    display: none;
    position: absolute;
    /* outras propriedades de estilo */
}
.command-menu.visible {
    display: block;
}


Conteúdo de dark-theme.css:
[data-theme="dark"] {
    --bg-primary: #343541;
    --text-primary: #fff;
    --text-secondary: rgba(255, 255, 255, 0.7);
    --msg-user: #444654;
    --msg-bot: #444654;
    --sidebar-bg: #202123;
    --input-bg: #40414f;
}

Conteúdo de light-theme.css:
:root {
    --bg-primary: #f7f7f8;
    --text-primary: #000000;
    --text-secondary: rgba(0, 0, 0, 0.7);
    --msg-user: #e6e6e6;
    --msg-bot: #d9d9d9;
    --sidebar-bg: #ffffff;
    --input-bg: #ffffff;
}

Conteúdo de variables.css:

:root {
    --bg-primary: #f7f7f8;
    --text-primary: #000000;
    --text-secondary: rgba(0, 0, 0, 0.7);
    --text-disabled: rgba(0, 0, 0, 0.5);
    --action-active: #000000;
    --action-hover: rgba(0, 0, 0, 0.08);
    --action-selected: rgba(0, 0, 0, 0.16);
    --action-disabled: rgba(0, 0, 0, 0.3);
    --action-disabled-background: rgba(0, 0, 0, 0.12);
    --msg-user: #e6e6e6;
    --msg-bot: #d9d9d9;
    --sidebar-bg: #ffffff;
    --input-bg: #ffffff;
    --border-color: rgba(0, 0, 0, 0.12);
    --code-bg: #f8f8f8;
    --code-header-bg: #f1f1f1;
    --color-success: #4CAF50;
}

[data-theme="dark"] {
    --bg-primary: #343541;
    --text-primary: #fff;
    --text-secondary: rgba(255, 255, 255, 0.7);
    --text-disabled: rgba(255, 255, 255, 0.5);
    --action-active: #fff;
    --action-hover: rgba(255, 255, 255, 0.08);
    --action-selected: rgba(255, 255, 255, 0.16);
    --action-disabled: rgba(255, 255, 255, 0.3);
    --action-disabled-background: rgba(255, 255, 255, 0.12);
    --msg-user: #444654;
    --msg-bot: #444654;
    --sidebar-bg: #202123;
    --input-bg: #40414f;
    --border-color: rgba(255, 255, 255, 0.12);
    --code-bg: #1e1e1e;
    --code-header-bg: #2d2d2d;
    --color-success: #4CAF50;
}


Conteúdo de chatActions.js:

import { mostrarCarregamento } from './chatUI.js';
import { adicionarMensagem } from './chatUI.js';
import { adicionarMensagemAoHistorico, criarNovaConversa, atualizarListaConversas } from './chatStorage.js';

let abortControllers = {};

function inicializarConversa(conversationId) {
    if (!window.conversations[conversationId]) {
        // console.log(`[DEBUG] Inicializando estrutura para conversa ${conversationId}`);
        window.conversations[conversationId] = {
            data: { 
                id: conversationId,
                title: "Nova Conversa",
                messages: []
            },
            streaming: false,
            currentResponse: '',
            eventSource: null,
            abortController: null
        };
    }
    return window.conversations[conversationId];
}

// Função para atualizar os botões com base na conversa atual
export function atualizarBotoes(sendBtn, stopBtn) {
    const conversationId = window.conversaAtual?.id;
    if (!conversationId) {
        // Se não houver conversa ativa, mostrar apenas o botão de enviar
        sendBtn.style.display = 'flex';
        stopBtn.style.display = 'none';
        return;
    }
    
    const conversation = window.conversations[conversationId];
    if (conversation && conversation.streaming) {
        sendBtn.style.display = 'none';
        stopBtn.style.display = 'flex';
    } else {
        sendBtn.style.display = 'flex';
        stopBtn.style.display = 'none';
    }
    
    // console.log(`[DEBUG] Botões atualizados para conversa ${conversationId}: streaming=${conversation?.streaming}`);
}

export async function enviarMensagem(mensagem, input, chatContainer, sendBtn, stopBtn) {
    if (!mensagem.trim()) return;

    if (mensagem.startsWith('/youtube ')) {
        const videoUrl = mensagem.split(' ')[1];
        if (!videoUrl) {
            adicionarMensagem(chatContainer, "Por favor, forneça uma URL do YouTube válida", 'assistant');
            return;
        }

        if (!window.conversaAtual) {
            criarNovaConversa();
        }

        adicionarMensagem(chatContainer, mensagem, 'user');
        adicionarMensagemAoHistorico(mensagem, 'user');
        // Atualiza lista de conversas após enviar mensagem
        atualizarListaConversas();

        const loadingDiv = mostrarCarregamento(chatContainer);
        try {
            const response = await fetch('/process_youtube', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ 
                    video_url: videoUrl,
                    conversation_id: window.conversaAtual.id,
                    comando: mensagem
                })
            });

            const data = await response.json();
            loadingDiv.remove();

            if (data.error) {
                adicionarMensagem(chatContainer, `Erro: ${data.error}`, 'assistant');
                adicionarMensagemAoHistorico(`Erro: ${data.error}`, 'assistant');
            } else {
                adicionarMensagem(chatContainer, data.text, 'assistant');
                adicionarMensagemAoHistorico(data.text, 'assistant');
            }
            
            window.dispatchEvent(new CustomEvent('historicoAtualizado'));
            // Atualiza lista de conversas após receber resposta
            atualizarListaConversas();
        } catch (error) {
            loadingDiv.remove();
            const errorMsg = "Erro ao processar o vídeo";
            adicionarMensagem(chatContainer, errorMsg, 'assistant');
            adicionarMensagemAoHistorico(errorMsg, 'assistant');
        }
        return;
    }

    if (!window.conversaAtual) {
        // console.log("[DEBUG] Criando nova conversa...");
        criarNovaConversa();
    }

    const conversationId = window.conversaAtual.id;
    // console.log(`[DEBUG] Enviando mensagem para conversa: ${conversationId}`);

    const conversation = inicializarConversa(conversationId);
    
    adicionarMensagem(chatContainer, mensagem, 'user');
    adicionarMensagemAoHistorico(mensagem, 'user', conversationId);
    // Atualiza lista de conversas após enviar mensagem do usuário
    atualizarListaConversas();

    input.value = '';
    input.style.height = 'auto';
    
    const loadingDiv = mostrarCarregamento(chatContainer);

    // Marcar conversa como streaming e atualizar botões
    conversation.streaming = true;
    atualizarBotoes(sendBtn, stopBtn);
    
    conversation.abortController = new AbortController();
    abortControllers[conversationId] = conversation.abortController;

    conversation.currentResponse = '';

    try {
        const response = await fetch('/send_message', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                message: mensagem,
                conversation_id: conversationId
            }),
            signal: conversation.abortController.signal
        });

        if (!response.ok) {
            throw new Error('Erro na resposta do servidor');
        }

        const reader = response.body.getReader();
        const decoder = new TextDecoder('utf-8');
        
        let streamingDiv = null;

        while (true) {
            const { value, done } = await reader.read();
            if (done) break;

            const chunk = decoder.decode(value, { stream: true });
            const lines = chunk.split('\n');

            for (const line of lines) {
                if (line.startsWith('data: ')) {
                    try {
                        const jsonData = JSON.parse(line.slice(6));
                        if (jsonData.content) {
                            conversation.currentResponse += jsonData.content;
                            
                            if (window.conversaAtual && window.conversaAtual.id === conversationId) {
                                if (!streamingDiv) {
                                    loadingDiv.remove();
                                    streamingDiv = document.createElement('div');
                                    streamingDiv.className = 'message assistant streaming-message';
                                    chatContainer.appendChild(streamingDiv);
                                }
                                
                                streamingDiv.innerHTML = `<div class="message-content"><p>${conversation.currentResponse.replace(/\n/g, '<br>')}</p></div>`;
                                chatContainer.scrollTop = chatContainer.scrollHeight;
                            }
                        }
                    } catch (e) {
                        console.error('Erro ao processar chunk:', e);
                    }
                }
            }
        }

        if (streamingDiv) {
            streamingDiv.remove();
        } else if (window.conversaAtual && window.conversaAtual.id === conversationId) {
            loadingDiv.remove();
        }
        
        if (window.conversaAtual && window.conversaAtual.id === conversationId) {
            adicionarMensagem(chatContainer, conversation.currentResponse, 'assistant');
            window.dispatchEvent(new CustomEvent('historicoAtualizado'));
            window.dispatchEvent(new CustomEvent('mensagemEnviada'));
        } else {
            // console.log(`[DEBUG] Conversa mudou durante streaming. Não atualizando UI.`);
        }
        
        // Sempre salvar a mensagem no histórico local, independentemente da conversa ativa
        adicionarMensagemAoHistorico(conversation.currentResponse, 'assistant', conversationId);
        // Atualiza lista de conversas após receber resposta
        atualizarListaConversas();
        
    } catch (erro) {
        if (erro.name === 'AbortError') {
            // console.log('Geração de resposta interrompida pelo usuário');
            if (window.conversaAtual && window.conversaAtual.id === conversationId) {
                loadingDiv.remove();
            }
        } else {
            console.error('Erro:', erro);
            if (window.conversaAtual && window.conversaAtual.id === conversationId) {
                loadingDiv.remove();
            }
            const errorMsg = 'Erro ao conectar com o servidor. Por favor, tente novamente.';
            
            if (window.conversaAtual && window.conversaAtual.id === conversationId) {
                adicionarMensagem(chatContainer, errorMsg, 'assistant');
            }
            
            adicionarMensagemAoHistorico(errorMsg, 'assistant', conversationId);
        }
    } finally {
        if (conversation) {
            conversation.streaming = false;
            conversation.abortController = null;
        }
        delete abortControllers[conversationId];
        
        // Atualizar os botões apenas se estamos na mesma conversa
        if (window.conversaAtual && window.conversaAtual.id === conversationId) {
            atualizarBotoes(sendBtn, stopBtn);
        }
    }
}

export function interromperResposta() {
    const conversationId = window.conversaAtual?.id;
    if (!conversationId) return;
    
    // console.log(`[DEBUG] Interrompendo resposta para conversa: ${conversationId}`);
    
    if (abortControllers[conversationId]) {
        abortControllers[conversationId].abort();
    }
    
    const conversation = window.conversations[conversationId];
    if (conversation) {
        if (conversation.eventSource) {
            conversation.eventSource.close();
            conversation.eventSource = null;
        }
        conversation.streaming = false;
        
        // Atualizar botões após interromper
        const sendBtn = document.getElementById('send-btn');
        const stopBtn = document.getElementById('stop-btn');
        if (sendBtn && stopBtn) {
            atualizarBotoes(sendBtn, stopBtn);
        }
    }
}


Conteúdo de chatStorage.js:
import { adicionarMensagem } from './chatUI.js';
import { atualizarBotoes } from './chatActions.js';
import { entrarNaSalaDeConversa } from './chatSync.js';
import { melhorarBlocosCodigo, escapeHTML } from './chatUtils.js';
import { renderMessage } from '../messageRenderer.js';

// Cache para conversas já carregadas
const conversationCache = {};

export function carregarConversa(id) {
    // Reset the current view
    const chatContainer = document.querySelector('.chat-container');
    const welcomeScreen = document.querySelector('.welcome-screen');
    const inputContainer = document.querySelector('.input-container');
    
    if (!chatContainer) {
        console.error('[ERRO] Chat container não encontrado');
        return;
    }
    
    // Show loading indicator
    welcomeScreen.style.display = 'none';
    chatContainer.style.display = 'block';
    inputContainer.style.display = 'block';
    chatContainer.innerHTML = '<div class="loading-indicator">Carregando conversa...</div>';
    
    // Primeiro, carregamos apenas os metadados da conversa
    fetch(`/get_conversation/${id}`)
        .then(response => {
            if (!response.ok) throw new Error('HTTP error: ' + response.status);
            return response.json();
        })
        .then(conversa => {
            if (conversa.error) {
                console.error('Erro ao carregar conversa:', conversa.error);
                chatContainer.innerHTML = '<div class="error-message">Erro ao carregar conversa</div>';
                return;
            }
            
            // Normalizar estrutura da conversa
            if (!conversa.messages) {
                conversa.messages = conversa.mensagens || [];
                delete conversa.mensagens;
            }
            
            if (!Array.isArray(conversa.messages)) {
                console.error('[ERRO] Messages não é um array, corrigindo...');
                conversa.messages = [];
            }
            
            if (conversa.titulo) {
                conversa.title = conversa.titulo;
                delete conversa.titulo;
            }
            
            // Armazenar conversa atual e atualizar cache de conversas
            window.conversaAtual = {
                ...conversa,
                messages: [] // Inicialmente vazio, será carregado por lotes
            };
            
            if (!window.conversas) window.conversas = [];
            window.conversas = window.conversas.map(c => 
                c.id === conversa.id ? conversa : c
            );

            // Adicionar à estrutura de conversas global por ID
            if (!window.conversations) window.conversations = {};
            
            // Preservar o estado de streaming se já existir
            const existingConversation = window.conversations[id];
            window.conversations[id] = {
                data: conversa,
                streaming: existingConversation ? existingConversation.streaming : false,
                currentResponse: existingConversation ? existingConversation.currentResponse : '',
                eventSource: existingConversation ? existingConversation.eventSource : null,
                abortController: existingConversation ? existingConversation.abortController : null,
                pendingUpdates: false,
                totalMessages: conversa.messages.length,
                loadedMessages: new Set(), // Limpar o conjunto de mensagens carregadas
                isLoading: false // Controle de estado de carregamento
            };
            
            // Limpar o container e preparar para lazy loading
            chatContainer.innerHTML = '';
            
            console.log(`[DEBUG] Iniciando carregamento da conversa ${id}`);
            
            // Iniciar o carregamento assíncrono das mensagens em lotes
            carregarMensagensEmLotes(id, 0, 20);  // Carrega as primeiras 20 mensagens

            // Entrar na sala de WebSocket para esta conversa
            entrarNaSalaDeConversa(id);
            
            // Atualizar lista de conversas para refletir o chat ativo
            atualizarListaConversas();
            
            window.dispatchEvent(new CustomEvent('conversaCarregada'));
            window.dispatchEvent(new CustomEvent('historicoAtualizado'));
        })
        .catch(error => {
            console.error('Erro ao carregar conversa:', error);
            chatContainer.innerHTML = '<div class="error-message">Erro ao carregar conversa</div>';
        });
}

// Nova função para carregar mensagens em lotes
function carregarMensagensEmLotes(conversationId, offset, limit) {
    const chatContainer = document.querySelector('.chat-container');
    
    if (!chatContainer) {
        console.error('[ERRO] Chat container não encontrado');
        return;
    }
    
    if (!window.conversations || !window.conversations[conversationId]) {
        console.error('[ERRO] Conversa não encontrada na estrutura global');
        return;
    }
    
    const conversation = window.conversations[conversationId];
    if (conversation.isLoading) {
        console.log('[INFO] Carregamento já em andamento, ignorando');
        return;
    }
    
    conversation.isLoading = true;
    
    // Mostrar indicador apenas no primeiro lote
    if (offset === 0 && !chatContainer.querySelector('.loading-indicator')) {
        const loadingIndicator = document.createElement('div');
        loadingIndicator.className = 'loading-indicator';
        loadingIndicator.textContent = 'Carregando mensagens...';
        loadingIndicator.id = 'loading-indicator';
        chatContainer.appendChild(loadingIndicator);
    }
    
    console.log(`[DEBUG] Carregando lote: offset=${offset}, limit=${limit}`);
    
    fetch(`/get_conversation/${conversationId}/${offset}/${limit}`)
        .then(response => response.json())
        .then(data => {
            const loadingIndicator = document.getElementById('loading-indicator');
            if (loadingIndicator) {
                chatContainer.removeChild(loadingIndicator);
            }
            
            if (data.error) {
                console.error('Erro ao carregar mensagens:', data.error);
                conversation.isLoading = false;
                return;
            }
            
            const messages = data.messages || [];
            const hasMore = data.hasMore || false;
            const total = data.total || 0;
            
            console.log(`[DEBUG] Recebido: ${messages.length} mensagens, hasMore=${hasMore}, total=${total}`);
            
            if (offset === 0 && messages.length === 0) {
                const emptyMessage = document.createElement('div');
                emptyMessage.className = 'empty-message';
                emptyMessage.textContent = 'Nenhuma mensagem nesta conversa.';
                chatContainer.appendChild(emptyMessage);
                conversation.isLoading = false;
                return;
            }
            
            const fragment = document.createDocumentFragment();
            const loadedMessages = conversation.loadedMessages;
            
            messages.forEach((msg) => {
                // Criar um ID único para a mensagem baseado em seu conteúdo e timestamp
                const messageId = msg.id || 
                                msg.timestamp || 
                                `${conversationId}_${msg.content.slice(0, 20)}_${Date.now()}`;
                
                if (!loadedMessages.has(messageId)) {
                    console.log(`[DEBUG] Adicionando nova mensagem: ${messageId}`);
                    loadedMessages.add(messageId);
                    
                    const messageDiv = document.createElement('div');
                    messageDiv.className = `message ${msg.role === 'assistant' ? 'assistant' : 'user'}`;
                    messageDiv.dataset.messageId = messageId;
                    
                    const messageContent = document.createElement('div');
                    messageContent.className = 'message-content';
                    messageContent.innerHTML = msg.role === 'assistant' ? 
                        renderMessage(msg.content) : 
                        `<p>${escapeHTML(msg.content).replace(/\n/g, '<br>')}</p>`;
                    
                    const messageActions = document.createElement('div');
                    messageActions.className = 'message-actions';
                    messageActions.innerHTML = `
                        <button class="action-btn copy-btn" onclick="window.copiarMensagem(this)" title="Copiar mensagem">
                            <i class="fas fa-copy"></i>
                        </button>
                        ${msg.role === 'assistant' ? `
                            <button class="action-btn regenerate-btn" onclick="window.regenerarResposta(this)" title="Regenerar resposta">
                                <i class="fas fa-redo"></i>
                            </button>
                        ` : ''}
                    `;
                    
                    messageDiv.appendChild(messageContent);
                    messageDiv.appendChild(messageActions);
                    
                    if (offset === 0) {
                        fragment.appendChild(messageDiv);
                    } else {
                        fragment.insertBefore(messageDiv, fragment.firstChild);
                    }
                } else {
                    console.log(`[DEBUG] Mensagem ${messageId} já carregada, ignorada`);
                }
            });
            
            if (offset === 0) {
                chatContainer.appendChild(fragment);
            } else {
                if (chatContainer.firstChild) {
                    chatContainer.insertBefore(fragment, chatContainer.firstChild);
                } else {
                    chatContainer.appendChild(fragment);
                }
            }
            
            setTimeout(() => melhorarBlocosCodigo(), 100);
            atualizarBotoes(document.getElementById('send-btn'), document.getElementById('stop-btn'));
            
            const oldHeight = chatContainer.scrollHeight;
            const oldScrollTop = chatContainer.scrollTop;
            
            // Configurar scroll apenas se houver mais mensagens
            if (hasMore && loadedMessages.size < total) {
                console.log(`[DEBUG] Configurando scroll listener, mensagens carregadas: ${loadedMessages.size}/${total}`);
                configureScrollListener(conversationId, offset + limit, limit);
            } else {
                console.log(`[DEBUG] Todas as mensagens carregadas (${loadedMessages.size}/${total}), removendo listener`);
                if (chatContainer._scrollListener) {
                    chatContainer.removeEventListener('scroll', chatContainer._scrollListener);
                    chatContainer._scrollListener = null;
                }
            }
            
            if (offset === 0) {
                chatContainer.scrollTop = chatContainer.scrollHeight;
            } else {
                const newHeight = chatContainer.scrollHeight;
                chatContainer.scrollTop = oldScrollTop + (newHeight - oldHeight);
            }
            
            conversation.isLoading = false;
        })
        .catch(error => {
            console.error('Erro ao carregar lote:', error);
            conversation.isLoading = false;
            const loadingIndicator = document.getElementById('loading-indicator');
            if (loadingIndicator) loadingIndicator.textContent = 'Erro ao carregar mensagens.';
        });
}

// Configurar detector de scroll para lazy loading
function configureScrollListener(conversationId, nextOffset, limit) {
    const chatContainer = document.querySelector('.chat-container');
    
    if (!chatContainer) {
        console.error('[ERRO] Chat container não encontrado');
        return;
    }
    
    // Remover listener anterior se existir
    if (chatContainer._scrollListener) {
        chatContainer.removeEventListener('scroll', chatContainer._scrollListener);
        chatContainer._scrollListener = null;
    }
    
    const scrollListener = function() {
        const conversation = window.conversations[conversationId];
        if (!conversation) {
            console.error('[ERRO] Conversa não encontrada na estrutura global');
            return;
        }
        
        if (conversation.isLoading) {
            console.log('[DEBUG] Carregamento em andamento, ignorando scroll');
            return;
        }
        
        // Verificar se estamos próximos do topo e não estamos carregando
        if (chatContainer.scrollTop < 100) {
            console.log(`[DEBUG] Scroll no topo, carregando mais mensagens de offset ${nextOffset}`);
            
            // Remover listener antes de carregar para evitar chamadas múltiplas
            chatContainer.removeEventListener('scroll', scrollListener);
            chatContainer._scrollListener = null;
            
            // Carregar próximo lote
            carregarMensagensEmLotes(conversationId, nextOffset, limit);
        }
    };
    
    // Adicionar novo listener
    chatContainer.addEventListener('scroll', scrollListener);
    chatContainer._scrollListener = scrollListener;
    
    console.log(`[DEBUG] Scroll listener configurado para offset ${nextOffset}`);
}

export function atualizarListaConversas() {
    // console.log('[DEBUG] Atualizando lista de conversas');
    
    const chatList = document.querySelector('.chat-list');
    if (!chatList) {
        console.error('[ERRO] Chat list não encontrada');
        return;
    }

    // Limpar qualquer listener existente para evitar duplicação
    if (chatList._clickListener) {
        chatList.removeEventListener('click', chatList._clickListener);
    }

    fetch('/get_conversation_history')
        .then(response => response.json())
        .then(conversas => {
            chatList.innerHTML = '';
            conversas.forEach(conversa => {
                const conversaElement = document.createElement('div');
                conversaElement.className = 'chat-item';
                if (window.conversaAtual && window.conversaAtual.id === conversa.id) {
                    conversaElement.classList.add('active');
                }
                
                conversaElement.dataset.id = conversa.id;
                
                const titulo = conversa.title || conversa.titulo || 'Nova conversa';
                
                const spanTitulo = document.createElement('span');
                spanTitulo.className = 'chat-title';
                spanTitulo.textContent = titulo;
                conversaElement.appendChild(spanTitulo);
                
                const actionButtons = document.createElement('div');
                actionButtons.className = 'action-buttons';
                actionButtons.style.position = 'relative';
                actionButtons.style.zIndex = '100';
                
                // Botão Renomear com ícone
                const renameBtn = document.createElement('button');
                renameBtn.className = 'action-btn rename-btn';
                renameBtn.dataset.id = conversa.id;
                renameBtn.title = 'Renomear conversa';
                renameBtn.innerHTML = '<i class="fas fa-edit"></i>'; // Ícone de lápis para editar
                renameBtn.style.pointerEvents = 'auto';
                
                // Adicionar listener direto ao botão
                renameBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    // console.log('[DEBUG] Rename clicked diretamente para ID:', conversa.id);
                    renomearConversa(conversa.id);
                });
                
                // Botão Excluir com ícone
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'action-btn delete-btn';
                deleteBtn.dataset.id = conversa.id;
                deleteBtn.title = 'Excluir conversa';
                deleteBtn.innerHTML = '<i class="fas fa-trash"></i>'; // Ícone de lixeira para excluir
                deleteBtn.style.pointerEvents = 'auto';
                
                // Adicionar listener direto ao botão
                deleteBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    // console.log('[DEBUG] Delete clicked diretamente para ID:', conversa.id);
                    excluirConversa(conversa.id);
                });
                
                actionButtons.appendChild(renameBtn);
                actionButtons.appendChild(deleteBtn);
                conversaElement.appendChild(actionButtons);
                
                // Evitar que cliques nos botões disparem o carregamento da conversa
                actionButtons.addEventListener('click', function(e) {
                    e.stopPropagation();
                    // console.log('[DEBUG] Clique capturado em action-buttons');
                });
                
                chatList.appendChild(conversaElement);
            });
            
            // Adicionar listener de delegação também como fallback
            const clickListener = function(e) {
                // console.log('[DEBUG] Clique detectado em:', e.target);
                
                // Se clicar nos botões, não carrega a conversa
                if (e.target.closest('.action-buttons')) {
                    // console.log('[DEBUG] Clique em botões, interrompendo propagação');
                    e.stopPropagation();
                    return;
                }
                
                // Verificar se clicou em um botão de renomear
                const renameBtn = e.target.closest('.rename-btn');
                if (renameBtn) {
                    e.preventDefault();
                    e.stopPropagation();
                    const id = renameBtn.dataset.id;
                    // console.log('[DEBUG] Botão renomear clicado para ID:', id);
                    renomearConversa(id);
                    return;
                }
                
                // Verificar se clicou em um botão de excluir
                const deleteBtn = e.target.closest('.delete-btn');
                if (deleteBtn) {
                    e.preventDefault();
                    e.stopPropagation();
                    const id = deleteBtn.dataset.id;
                    // console.log('[DEBUG] Botão excluir clicado para ID:', id);
                    excluirConversa(id);
                    return;
                }
                
                // Se não clicou em nenhum botão, carrega a conversa
                const chatItem = e.target.closest('.chat-item');
                if (chatItem) {
                    const id = chatItem.dataset.id;
                    // console.log('[DEBUG] Carregando conversa pelo clique:', id);
                    carregarConversa(id);
                }
            };
            
            chatList.addEventListener('click', clickListener);
            chatList._clickListener = clickListener; // Salva a referência para poder remover depois
            
            window.dispatchEvent(new CustomEvent('listaAtualizada'));
        })
        .catch(error => console.error('Erro ao atualizar lista de conversas:', error));
}

export function criarNovaConversa() {
    const novaConversa = {
        id: Date.now().toString(),
        title: "Nova Conversa",
        messages: []
    };
    
    window.conversas = window.conversas || [];
    window.conversas.unshift(novaConversa);
    window.conversaAtual = novaConversa;
    
    // Adicionar à estrutura de conversas global
    if (!window.conversations) window.conversations = {};
    window.conversations[novaConversa.id] = {
        data: novaConversa,
        streaming: false,
        currentResponse: ''
    };
    
    // Atualizar lista de conversas instantaneamente ao criar nova conversa
    atualizarListaConversas();
    window.dispatchEvent(new CustomEvent('historicoAtualizado'));
    
    return novaConversa;
}

export function adicionarMensagemAoHistorico(mensagem, tipo, conversationId = null) {
    // Se não especificado, usa a conversa atual
    conversationId = conversationId || (window.conversaAtual ? window.conversaAtual.id : null);
    
    // console.log(`[DEBUG] Adicionando mensagem à conversa ${conversationId}, tipo: ${tipo}`);
    
    if (!conversationId) {
        // console.log('[CORREÇÃO] Não há conversa atual, criando uma nova');
        const novaConversa = criarNovaConversa();
        conversationId = novaConversa.id;
    }
    
    // Referência à conversa na estrutura global de conversas
    let conversation = window.conversations[conversationId];
    
    if (!conversation) {
        console.log(`[ERRO] Conversa ${conversationId} não encontrada na estrutura global`);
        return;
    }
    
    // Verificar se a estrutura da conversa no estado global está correta
    if (!window.conversaAtual || !Array.isArray(window.conversaAtual.messages)) {
        // console.log('[CORREÇÃO] Estado da conversa atual inválido, corrigindo');
        window.conversaAtual = {
            id: conversationId,
            title: window.conversations[conversationId].data.title || "Nova conversa",
            messages: []
        };
        
        // Atualizar na estrutura global
        window.conversations[conversationId].data = window.conversaAtual;
    }
    
    try {
        const message = {
            content: mensagem,
            role: tipo,
            timestamp: new Date().toISOString()
        };
        
        // Adicionar mensagem ao histórico da conversa atual
        if (window.conversaAtual && window.conversaAtual.id === conversationId) {
            window.conversaAtual.messages.push(message);
        }
        
        // Adicionar também à estrutura de dados de conversas global
        if (!Array.isArray(window.conversations[conversationId].data.messages)) {
            window.conversations[conversationId].data.messages = [];
        }
        
        window.conversations[conversationId].data.messages.push(message);
        
        // console.log(`[DEBUG] Mensagem adicionada com sucesso à conversa ${conversationId}`);
        
        window.dispatchEvent(new CustomEvent('historicoAtualizado'));
        window.dispatchEvent(new CustomEvent('mensagemAdicionada'));
        
    } catch (err) {
        console.error(`[ERRO CRÍTICO] Falha ao adicionar mensagem à conversa ${conversationId}:`, err);
    }
    
    // IMPORTANTE: Removido a chamada fetch para /save_message aqui para evitar duplicação
    // O backend já salva a mensagem ao final do streaming
}

export function renomearConversa(id) {
    // console.log('[DEBUG] Tentando renomear conversa:', id);
    
    const novoTitulo = prompt('Digite o novo título da conversa:');
    if (!novoTitulo || !novoTitulo.trim()) {
        // console.log('[DEBUG] Operação cancelada pelo usuário');
        return;
    }

    fetch(`/rename_conversation/${id}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ title: novoTitulo.trim() })
    })
    .then(response => {
        // console.log('[DEBUG] Status da resposta:', response.status);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        return response.json();
    })
    .then(data => {
        // console.log('[DEBUG] Resposta do servidor:', data);
        
        if (data.success) {
            // console.log('[DEBUG] Conversa renomeada com sucesso');
            
            // Atualizar na conversa atual se for a mesma
            if (window.conversaAtual && window.conversaAtual.id === id) {
                window.conversaAtual.title = novoTitulo.trim();
            }
            
            // Atualizar na estrutura global de conversas
            if (window.conversations && window.conversations[id]) {
                window.conversations[id].data.title = novoTitulo.trim();
            }
            
            // Atualizar na lista de conversas em memória
            if (window.conversas) {
                window.conversas = window.conversas.map(c => 
                    c.id === id ? {...c, title: novoTitulo.trim()} : c
                );
            }
            
            // Atualizar a lista de conversas na UI
            atualizarListaConversas();
            
            // Notificar sistema sobre alteração
            window.dispatchEvent(new CustomEvent('conversaAtualizada', { 
                detail: { id, newTitle: novoTitulo.trim() } 
            }));
        } else {
            throw new Error(data.error || 'Erro desconhecido');
        }
    })
    .catch(error => {
        console.error('[ERRO] Falha ao renomear:', error);
        alert('Erro ao renomear conversa: ' + error.message);
    });
}

export function excluirConversa(id) {
    // console.log('[DEBUG] Tentando excluir conversa:', id);
    
    if (!confirm('Tem certeza que deseja excluir esta conversa?')) {
        // console.log('[DEBUG] Operação cancelada pelo usuário');
        return;
    }

    fetch(`/delete_conversation/${id}`, {
        method: 'DELETE',
        headers: { 'Content-Type': 'application/json' }
    })
    .then(response => {
        // console.log('[DEBUG] Status da resposta:', response.status);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        return response.json();
    })
    .then(data => {
        // console.log('[DEBUG] Resposta do servidor:', data);
        
        if (data.success) {
            // console.log('[DEBUG] Conversa excluída com sucesso');
            
            // Remover da memória
            if (window.conversas) {
                window.conversas = window.conversas.filter(c => c.id !== id);
            }
            
            // Remover da estrutura global de conversas e finalizar qualquer streaming em andamento
            if (window.conversations && window.conversations[id]) {
                // Interromper streaming se existir
                if (window.conversations[id].abortController) {
                    window.conversations[id].abortController.abort();
                }
                if (window.conversations[id].eventSource) {
                    window.conversations[id].eventSource.close();
                }
                delete window.conversations[id];
            }
            
            // Se a conversa atual foi excluída, voltar para a tela inicial
            if (window.conversaAtual && window.conversaAtual.id === id) {
                window.conversaAtual = null;
                const welcomeScreen = document.querySelector('.welcome-screen');
                const chatContainer = document.querySelector('.chat-container');
                const inputContainer = document.querySelector('.input-container');
                
                welcomeScreen.style.display = 'flex';
                chatContainer.style.display = 'none';
                inputContainer.style.display = 'none';
                
                // Atualizar botões para estado inicial
                const sendBtn = document.getElementById('send-btn');
                const stopBtn = document.getElementById('stop-btn');
                if (sendBtn && stopBtn) {
                    sendBtn.style.display = 'flex';
                    stopBtn.style.display = 'none';
                }
            }
            
            // Atualizar a lista de conversas
            atualizarListaConversas();
            
            // Notificar sistema sobre exclusão
            window.dispatchEvent(new CustomEvent('conversaExcluida', { 
                detail: { id } 
            }));
        } else {
            throw new Error(data.error || 'Erro desconhecido');
        }
    })
    .catch(error => {
        console.error('[ERRO] Falha na requisição:', error);
        alert('Erro ao excluir conversa: ' + error.message);
    });
}


Conteúdo de chatSync.js:
/**
 * chatSync.js
 * Responsável pela sincronização entre sessões do chat via WebSockets
 */

let socket = null;
let isConnected = false;
let reconnectAttempts = 0;
const MAX_RECONNECT_ATTEMPTS = 5;
const RECONNECT_DELAY = 3000; // 3 segundos

/**
 * Inicializa a conexão com WebSocket e configura os listeners
 */
export function inicializarSync() {
    // Tentar obter uma sessionId do localStorage ou criar uma nova
    const sessionId = localStorage.getItem('sessionId') || gerarSessionId();
    localStorage.setItem('sessionId', sessionId);
    
    // Inicializar socket.io
    try {
        // URL atual do documento no navegador para evitar problemas de CORS
        const url = window.location.origin;
        socket = io(url);
        
        // Configurar listeners de conexão
        setupConnectionListeners(sessionId);
        
        // Configurar listeners de eventos
        setupEventListeners();
        
        return true;
    } catch (error) {
        console.error("Erro ao inicializar WebSocket:", error);
        return false;
    }
}

/**
 * Configura os listeners para eventos de conexão
 */
function setupConnectionListeners(sessionId) {
    if (!socket) return;
    
    socket.on('connect', () => {
        isConnected = true;
        reconnectAttempts = 0;
        // Registrar sessão do usuário para notificações
        socket.emit('register_session', { session_id: sessionId });
        
        // Registrar conversa atual (se existir)
        if (window.conversaAtual && window.conversaAtual.id) {
            entrarNaSalaDeConversa(window.conversaAtual.id);
        }
    });
    
    socket.on('disconnect', () => {
        isConnected = false;
    });
    
    socket.on('connect_error', (error) => {
        if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
            reconnectAttempts++;
            setTimeout(() => {
                socket.connect();
            }, RECONNECT_DELAY);
        }
    });
}

/**
 * Configura os listeners para eventos específicos do chat
 */
function setupEventListeners() {
    if (!socket) return;
    
    // Receber fragmento de mensagem em tempo real
    socket.on('message_chunk', (data) => {
        if (!window.conversaAtual || window.conversaAtual.id !== data.conversation_id) {
            // Se não for a conversa atual, apenas atualizar o buffer da conversa
            atualizarBufferDaConversa(data.conversation_id, data.content);
            return;
        }
        
        // Se for a conversa atual e estiver visível, atualizar a UI
        if (document.visibilityState === 'visible') {
            atualizarMensagemEmStream(data.content);
        }
    });
    
    // Receber notificação de que uma conversa foi atualizada
    socket.on('conversation_updated', (data) => {
        // Atualizar lista de conversas
        atualizarListaConversas();
        
        // Se for a conversa atual, atualizar a UI
        if (window.conversaAtual && window.conversaAtual.id === data.conversation_id) {
            // Se a aba estiver inativa, recarregar a conversa quando se tornar ativa
            if (document.visibilityState !== 'visible') {
                marcarParaRecarregar(data.conversation_id);
            } else {
                // Finalizar o streaming removendo a classe streaming-message
                const streamingMessage = document.querySelector('.streaming-message');
                if (streamingMessage) {
                    streamingMessage.classList.remove('streaming-message');
                }
            }
        }
    });
    
    // Receber notificação de que uma conversa foi renomeada
    socket.on('conversation_renamed', (data) => {
        // Atualizar no estado local
        if (window.conversas) {
            window.conversas = window.conversas.map(c => 
                c.id === data.conversation_id ? {...c, title: data.new_title} : c
            );
        }
        
        if (window.conversations && window.conversations[data.conversation_id]) {
            window.conversations[data.conversation_id].data.title = data.new_title;
        }
        
        // Atualizar lista de conversas
        atualizarListaConversas();
    });
    
    // Receber notificação de que uma conversa foi excluída
    socket.on('conversation_deleted', (data) => {
        // Remover do estado local
        if (window.conversas) {
            window.conversas = window.conversas.filter(c => c.id !== data.conversation_id);
        }
        
        if (window.conversations && window.conversations[data.conversation_id]) {
            delete window.conversations[data.conversation_id];
        }
        
        // Se for a conversa atual, voltar para a tela inicial
        if (window.conversaAtual && window.conversaAtual.id === data.conversation_id) {
            window.conversaAtual = null;
            mostrarTelaInicial();
        }
        
        // Atualizar lista de conversas
        atualizarListaConversas();
    });
}

/**
 * Entra na sala de uma conversa específica para receber atualizações
 */
export function entrarNaSalaDeConversa(conversationId) {
    if (!socket || !isConnected) return;
    
    // Sair de todas as salas anteriores primeiro
    if (window.salaAtual) {
        socket.emit('leave_conversation', { conversation_id: window.salaAtual });
    }
    
    // Entrar na nova sala
    socket.emit('join_conversation', { conversation_id: conversationId });
    window.salaAtual = conversationId;
}

/**
 * Atualiza o buffer de uma conversa com um novo fragmento de mensagem
 */
function atualizarBufferDaConversa(conversationId, fragmento) {
    if (!window.conversations) window.conversations = {};
    if (!window.conversations[conversationId]) {
        window.conversations[conversationId] = {
            data: { 
                id: conversationId,
                title: "Nova Conversa",
                messages: []
            },
            streaming: true,
            currentResponse: fragmento,
            pendingUpdates: true
        };
    } else {
        window.conversations[conversationId].currentResponse += fragmento;
        window.conversations[conversationId].pendingUpdates = true;
    }
}

/**
 * Atualiza a mensagem que está sendo exibida em stream na conversa atual
 * Versão melhorada para garantir que o streaming seja exibido em tempo real
 */
function atualizarMensagemEmStream(fragmento) {
    const chatContainer = document.querySelector('.chat-container');
    if (!chatContainer) return;
    
    // Encontrar a mensagem em streaming atual ou criar uma nova
    let streamingMessage = chatContainer.querySelector('.streaming-message');
    
    // Se não existir, criar uma nova mensagem para streaming
    if (!streamingMessage) {
        streamingMessage = document.createElement('div');
        streamingMessage.className = 'message assistant streaming-message';
        streamingMessage.innerHTML = '<div class="message-content"></div>';
        chatContainer.appendChild(streamingMessage);
    }
    
    // Atualizar a mensagem com o novo fragmento
    const messageContent = streamingMessage.querySelector('.message-content');
    if (messageContent) {
        // Inicializar currentResponse se não existir
        const conversation = window.conversations[window.conversaAtual.id];
        if (!conversation.currentResponse) conversation.currentResponse = '';
        
        // Acumular o fragmento
        conversation.currentResponse += fragmento;
        
        // Usar importação dinâmica para renderizar markdown em tempo real
        try {
            const { renderStreamingMessage } = window.messageRenderer || { renderStreamingMessage: (text) => text };
            const renderedHtml = renderStreamingMessage(conversation.currentResponse);
            messageContent.innerHTML = renderedHtml;
        } catch (error) {
            // Fallback para texto simples se houver erro
            messageContent.innerHTML = `<p>${conversation.currentResponse}</p>`;
        }
        
        // Melhorar blocos de código quando apropriado
        setTimeout(() => {
            if (typeof window.melhorarBlocosCodigo === 'function') {
                window.melhorarBlocosCodigo(streamingMessage);
            }
        }, 100);
        
        // Rolar para o final
        chatContainer.scrollTop = chatContainer.scrollHeight;
    }
}

/**
 * Marcar uma conversa para ser recarregada quando a aba ficar visível
 */
function marcarParaRecarregar(conversationId) {
    localStorage.setItem('conversaParaRecarregar', conversationId);
}

/**
 * Verificar se há conversas para recarregar quando a aba ficar visível
 */
function verificarRecarregamento() {
    const conversaParaRecarregar = localStorage.getItem('conversaParaRecarregar');
    if (conversaParaRecarregar) {
        localStorage.removeItem('conversaParaRecarregar');
        if (window.conversaAtual && window.conversaAtual.id === conversaParaRecarregar) {
            carregarConversa(conversaParaRecarregar);
        }
    }
}

/**
 * Gera um ID de sessão único
 */
function gerarSessionId() {
    return Date.now().toString() + '-' + Math.random().toString(36).substr(2, 9);
}

// Configurar o listener de visibilidade para sincronização
document.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'visible') {
        verificarRecarregamento();
        
        // Recarregar lista de conversas
        atualizarListaConversas();
        
        // Se houver uma conversa aberta com atualizações pendentes, recarregá-la
        if (window.conversaAtual && window.conversations && 
            window.conversations[window.conversaAtual.id] && 
            window.conversations[window.conversaAtual.id].pendingUpdates) {
            
            carregarConversa(window.conversaAtual.id);
            window.conversations[window.conversaAtual.id].pendingUpdates = false;
        }
    }
});

// Funções importadas de outros módulos que serão definidas no escopo global
const melhorarBlocosCodigo = window.melhorarBlocosCodigo || function() {};
const carregarConversa = window.carregarConversa || function() {};
const atualizarListaConversas = window.atualizarListaConversas || function() {};
const mostrarTelaInicial = window.mostrarTelaInicial || function() {};


Conteúdo de chatUI.js:
import { escapeHTML } from './chatUtils.js';
import { renderMessage } from '../messageRenderer.js';
import { melhorarBlocosCodigo } from './chatUtils.js';

export function iniciarChat(welcomeScreen, chatContainer, inputContainer) {
    welcomeScreen.style.display = 'none';
    chatContainer.style.display = 'block';
    inputContainer.style.display = 'block';
    chatContainer.innerHTML = '';
    
    // Verificar se há uma conversa carregada na estrutura global
    const conversationId = window.conversaAtual?.id;
    if (conversationId && window.conversations && window.conversations[conversationId]) {
        // console.log(`[DEBUG] Iniciando chat para conversa: ${conversationId}`);
    } else {
        // console.log('[DEBUG] Iniciando chat sem conversa ativa');
    }
}

export function mostrarTelaInicial(welcomeScreen, chatContainer, inputContainer, welcomeInput, chatInput) {
    welcomeScreen.style.display = 'flex';
    chatContainer.style.display = 'none';
    inputContainer.style.display = 'none';
    welcomeInput.value = '';
    if (chatInput) chatInput.value = '';
    
    // Limpar referência da conversa atual para evitar mistura de contextos
    window.conversaAtual = null;
    // console.log('[DEBUG] Retornando para tela inicial, conversa atual limpa');
    
    // Remover qualquer listener de scroll
    if (chatContainer._scrollListener) {
        chatContainer.removeEventListener('scroll', chatContainer._scrollListener);
        chatContainer._scrollListener = null;
    }
}

export function adicionarMensagem(chatContainer, texto, tipo) {
    // Verificar se o contêiner de chat existe
    if (!chatContainer) {
        console.error('[ERRO] Contêiner de chat não encontrado ao adicionar mensagem');
        return;
    }
    
    // Verificar se há uma conversa ativa
    const conversationId = window.conversaAtual?.id;
    if (!conversationId) {
        console.warn('[AVISO] Tentando adicionar mensagem sem conversa ativa');
    } else {
        // console.log(`[DEBUG] Adicionando mensagem à conversa ${conversationId}, tipo: ${tipo}`);
    }
    
    const mensagemDiv = document.createElement('div');
    mensagemDiv.className = `message ${tipo}`;
    
    // Associar ID da conversa para garantir isolamento
    if (conversationId) {
        mensagemDiv.dataset.conversationId = conversationId;
    }
    
    // Processamento de Markdown para mensagens do assistente
    let conteudoHtml;
    if (tipo === 'assistant') {
        // Aplicar formatação Markdown apenas nas mensagens do assistente
        conteudoHtml = renderMessage(texto);
        // console.log('[DEBUG] HTML renderizado (primeiros 150 caracteres):', conteudoHtml.substring(0, 150) + '...');
    } else {
        // Para mensagens do usuário, apenas escape HTML e quebras de linha
        conteudoHtml = `<p>${escapeHTML(texto).replace(/\n/g, '<br>')}</p>`;
    }
    
    const conteudo = `
        <div class="message-content">${conteudoHtml}</div>
        <div class="message-actions">
            <button class="action-btn copy-btn" onclick="window.copiarMensagem(this)" title="Copiar mensagem">
                <i class="fas fa-copy"></i>
            </button>
            ${tipo === 'assistant' ? `
                <button class="action-btn regenerate-btn" onclick="window.regenerarResposta(this)" title="Regenerar resposta">
                    <i class="fas fa-redo"></i>
                </button>
            ` : ''}
        </div>
    `;
    
    mensagemDiv.innerHTML = conteudo;
    chatContainer.appendChild(mensagemDiv);
    chatContainer.scrollTop = chatContainer.scrollHeight;
    
    // Melhorar os blocos de código imediatamente após adicionar a mensagem
    if (tipo === 'assistant') {
        setTimeout(() => {
            // console.log('[DEBUG] Aplicando melhorias aos blocos de código...');
            melhorarBlocosCodigo();
        }, 0);
    }
}

export function mostrarCarregamento(chatContainer) {
    // Verificar se o contêiner de chat existe
    if (!chatContainer) {
        console.error('[ERRO] Contêiner de chat não encontrado ao mostrar carregamento');
        return document.createElement('div'); // Retorna um div vazio como fallback
    }
    
    const loadingDiv = document.createElement('div');
    loadingDiv.className = 'loading message assistant';
    
    // Associar ID da conversa para garantir isolamento
    const conversationId = window.conversaAtual?.id;
    if (conversationId) {
        loadingDiv.dataset.conversationId = conversationId;
        // console.log(`[DEBUG] Mostrando carregamento para conversa: ${conversationId}`);
    } else {
        console.warn('[AVISO] Mostrando carregamento sem conversa ativa');
    }
    
    loadingDiv.innerHTML = `
        <span></span>
        <span></span>
        <span></span>
    `;
    chatContainer.appendChild(loadingDiv);
    chatContainer.scrollTop = chatContainer.scrollHeight;
    return loadingDiv;
}

// Adicionar CSS para os novos elementos
const style = document.createElement('style');
style.textContent = `
.loading-indicator {
    padding: 1rem;
    text-align: center;
    color: var(--text-secondary);
    font-style: italic;
}

.error-message {
    padding: 1rem;
    text-align: center;
    color: var(--error);
    font-weight: bold;
}

.empty-message {
    padding: 1rem;
    text-align: center;
    color: var(--text-secondary);
    font-style: italic;
}
`;
document.head.appendChild(style);


Conteúdo de chatUtils.js:
export function escapeHTML(text) {
    const div = document.createElement('div');
    div.innerText = text;
    return div.innerHTML;
}

export function copiarMensagem(button) {
    console.log('[DEBUG] Copiando mensagem...');
    const mensagem = button.closest('.message').querySelector('.message-content').innerText; // Usando innerText para preservar formatação
    navigator.clipboard.writeText(mensagem)
        .then(() => {
            button.innerHTML = '<i class="fas fa-check"></i>';
            button.classList.add('copied');
            
            setTimeout(() => {
                button.innerHTML = '<i class="fas fa-copy"></i>';
                button.classList.remove('copied');
            }, 2000);
        })
        .catch(err => {
            console.error('[ERRO] Falha ao copiar mensagem:', err);
            alert('Não foi possível copiar a mensagem. Por favor, tente novamente.');
        });
}

export function regenerarResposta(button) {
    console.log('[DEBUG] Regenerando resposta...');
    const mensagemOriginal = button.closest('.message').previousElementSibling;
    if (!mensagemOriginal) {
        console.error('Mensagem original não encontrada');
        return;
    }

    const texto = mensagemOriginal.querySelector('.message-content').textContent;
    const chatInput = document.getElementById('chat-input');
    const chatForm = document.getElementById('chat-form');

    if (chatInput && chatForm) {
        chatInput.value = texto;
        chatForm.dispatchEvent(new Event('submit'));
    } else {
        console.error('Elementos do formulário não encontrados');
    }
}

export function copiarCodigo(button) {
    console.log('[DEBUG] Copiando código...');
    const codeContainer = button.closest('.code-container');
    if (!codeContainer) {
        console.error('[ERRO] Container de código não encontrado');
        return;
    }
    
    const codeBlock = codeContainer.querySelector('.code-block code') || codeContainer.querySelector('code');
    if (!codeBlock) {
        console.error('[ERRO] Bloco de código não encontrado');
        return;
    }
    
    const code = codeBlock.textContent
        .replace(/&lt;/g, '<')
        .replace(/&gt;/g, '>')
        .replace(/&amp;/g, '&');
    
    navigator.clipboard.writeText(code)
        .then(() => {
            button.innerHTML = '<i class="fas fa-check"></i>';
            button.classList.add('copied');
            
            setTimeout(() => {
                button.innerHTML = '<i class="fas fa-copy"></i>';
                button.classList.remove('copied');
            }, 2000);
        })
        .catch(err => {
            console.error('[ERRO] Falha ao copiar código:', err);
            alert('Não foi possível copiar o código. Por favor, tente novamente.');
        });
}

/**
 * Adiciona barras de títulos e botões de copiar aos blocos de código
 */
export function melhorarBlocosCodigo() {
    // console.log('[DEBUG] Melhorando blocos de código...');
    const temaAtual = document.documentElement.getAttribute('data-theme');
    // console.log('[DEBUG] Tema atual:', temaAtual);
    
    document.querySelectorAll('pre code').forEach((block) => {
        // Evitar duplicação se já tiver sido processado
        if (block.parentElement.parentElement.classList.contains('code-container')) {
            return;
        }

        // Extrair a linguagem da classe - melhorada para capturar apenas letras/números
        // console.log('[DEBUG] Classes do bloco:', block.className);
        const langMatch = block.className.match(/language-([a-zA-Z0-9]+)/i);
        let language = langMatch ? langMatch[1] : 'plaintext';
        
        // Capitalizar apenas a primeira letra para exibição mais elegante
        language = language.charAt(0).toUpperCase() + language.slice(1).toLowerCase();
        // console.log('[DEBUG] Linguagem detectada:', language);

        // Criar container principal
        const container = document.createElement('div');
        container.className = 'code-container';

        // Criar barra de título com botão de copiar
        const header = document.createElement('div');
        header.className = 'code-header';
        header.innerHTML = `
            <span class="language-label">${language.toUpperCase()}</span>
            <button class="code-copy-btn" title="Copiar código">
                <i class="fas fa-copy"></i>
            </button>
        `;

        // Adicionar manipulador de eventos para o botão de copiar
        const copyBtn = header.querySelector('.code-copy-btn');
        copyBtn.addEventListener('click', function() {
            copiarCodigo(this);
        });

        // Reorganizar a estrutura do DOM
        const pre = block.parentElement;
        pre.classList.add('code-block');
        
        // Inserir elementos na DOM
        const parent = pre.parentElement;
        parent.insertBefore(container, pre);
        container.appendChild(header);
        container.appendChild(pre);
        
        // Reaplicar o highlight para garantir que o destaque de sintaxe seja mantido
        hljs.highlightElement(block);
    });
}

// Expor função globalmente para o onclick
window.copiarCodigo = copiarCodigo;
window.melhorarBlocosCodigo = melhorarBlocosCodigo;


Conteúdo de chat.js:

import { 
    iniciarChat,
    mostrarTelaInicial,
    adicionarMensagem,
    mostrarCarregamento
} from './chat/chatUI.js';

import {
    enviarMensagem,
    interromperResposta,
    atualizarBotoes
} from './chat/chatActions.js';

import {
    carregarConversa,
    atualizarListaConversas,
    criarNovaConversa,
    adicionarMensagemAoHistorico,
    renomearConversa,
    excluirConversa
} from './chat/chatStorage.js';

import {
    copiarCodigo,
    copiarMensagem,
    melhorarBlocosCodigo
} from './chat/chatUtils.js';

import {
    inicializarSync,
    entrarNaSalaDeConversa
} from './chat/chatSync.js';

// Estado global das conversas
window.conversations = {};

// Função para inicializar uma conversa na estrutura global
window.inicializarConversa = function(conversationId) {
    if (!window.conversations[conversationId]) {
        // Inicializando estrutura para conversa
        window.conversations[conversationId] = {
            data: { 
                id: conversationId,
                title: "Nova Conversa",
                messages: []
            },
            streaming: false,
            currentResponse: '',
            eventSource: null,
            abortController: null,
            pendingUpdates: false
        };
    }
    return window.conversations[conversationId];
};

// Função para copiar código - melhorada para preservar indentação
window.copiarCodigo = function(button) {
    const codeContainer = button.closest('.code-container');
    const codeBlock = codeContainer.querySelector('.code-block code');
    const code = codeBlock.innerText; // Usa innerText para preservar indentação
    
    navigator.clipboard.writeText(code).then(() => {
        // Feedback visual
        button.innerHTML = '<i class="fas fa-check"></i>';
        button.classList.add('copied');
        
        // Restaurar o ícone original após 2 segundos
        setTimeout(() => {
            button.innerHTML = '<i class="fas fa-copy"></i>';
            button.classList.remove('copied');
        }, 2000);
    }).catch(err => {
        console.error('Erro ao copiar código:', err);
        alert('Não foi possível copiar o código. Por favor, tente novamente.');
    });
};

// Função para copiar mensagem completa
window.copiarMensagem = function(button) {
    const messageDiv = button.closest('.message');
    const content = messageDiv.querySelector('.message-content').innerText; // Também usa innerText aqui
    
    navigator.clipboard.writeText(content).then(() => {
        // Feedback visual
        button.innerHTML = '<i class="fas fa-check"></i>';
        button.classList.add('copied');
        
        // Restaurar o ícone original após 2 segundos
        setTimeout(() => {
            button.innerHTML = '<i class="fas fa-copy"></i>';
            button.classList.remove('copied');
        }, 2000);
    }).catch(err => {
        console.error('Erro ao copiar mensagem:', err);
        alert('Não foi possível copiar a mensagem. Por favor, tente novamente.');
    });
};

// Função para regenerar resposta (útil para depuração)
window.regenerarResposta = function(button) {
    if (!window.conversaAtual) {
        console.error('[ERRO] Sem conversa ativa para regenerar resposta');
        return;
    }
    
    const messageDiv = button.closest('.message');
    const conversationId = window.conversaAtual.id;
    
    // Encontrar a última mensagem do usuário na conversa atual
    if (window.conversations[conversationId] && 
        window.conversations[conversationId].data && 
        window.conversations[conversationId].data.messages) {
        
        const messages = window.conversations[conversationId].data.messages;
        let lastUserMessage = null;
        
        // Percorrer mensagens de trás para frente para encontrar a última do usuário
        for (let i = messages.length - 1; i >= 0; i--) {
            if (messages[i].role === 'user') {
                lastUserMessage = messages[i].content;
                break;
            }
        }
        
        if (lastUserMessage) {
            // Remover a mensagem atual da IA
            messageDiv.remove();
            
            // Re-enviar a mensagem do usuário para gerar nova resposta
            const chatContainer = document.querySelector('.chat-container');
            const sendBtn = document.getElementById('send-btn');
            const stopBtn = document.getElementById('stop-btn');
            const dummyInput = { value: '' };
            
            enviarMensagem(lastUserMessage, dummyInput, chatContainer, sendBtn, stopBtn);
        } else {
            console.error('[ERRO] Não foi possível encontrar a última mensagem do usuário');
        }
    }
};

// Inicializar a sincronização via WebSockets quando o DOM estiver carregado
document.addEventListener('DOMContentLoaded', () => {
    // Inicializar WebSocket para sincronização entre abas
    inicializarSync();
    
    // Configurar o listener de visibilidade para sincronização
    document.addEventListener('visibilitychange', () => {
        if (document.visibilityState === 'visible') {
            // Atualizar a lista de conversas quando a aba ficar visível
            atualizarListaConversas();
        }
    });
});

export {
    iniciarChat,
    mostrarTelaInicial,
    adicionarMensagem,
    enviarMensagem,
    interromperResposta,
    carregarConversa,
    atualizarListaConversas,
    criarNovaConversa,
    adicionarMensagemAoHistorico,
    renomearConversa,
    excluirConversa,
    melhorarBlocosCodigo,
    atualizarBotoes,
    inicializarSync,
    entrarNaSalaDeConversa
};


Conteúdo de commandMenu.js:
export function initCommandMenu(inputElement, menuElement, commands = ['/youtube', '/google', '/help', '/settings']) {
    let selectedIndex = -1;
    const items = [];

    // Garantir que o menu esteja no body para evitar problemas de posicionamento
    if (menuElement.parentNode !== document.body) {
        menuElement.parentNode.removeChild(menuElement);
        document.body.appendChild(menuElement);
    }

    // Resetar estilos inline que podem estar causando problemas
    menuElement.style.display = 'none';
    menuElement.style.visibility = 'hidden';
    menuElement.style.position = 'absolute';
    menuElement.classList.remove('visible');

    if (!inputElement || !menuElement) {
        console.error('Elementos de input ou menu não foram fornecidos.');
        return;
    }

    function updateMenuPosition() {
        requestAnimationFrame(() => {
            const rect = inputElement.getBoundingClientRect();
            const menuHeight = menuElement.offsetHeight || 200;
            const spaceAbove = rect.top - menuHeight;

            // Se não tem espaço acima, abre pra baixo
            if (spaceAbove < 10) {
                menuElement.style.bottom = 'auto';
                menuElement.style.top = `${rect.bottom + 5}px`;
            } else {
                menuElement.style.top = 'auto';
                menuElement.style.bottom = `${window.innerHeight - rect.top + 5}px`;
            }
            
            menuElement.style.left = `${rect.left}px`;
            menuElement.style.width = `${rect.width}px`;
            menuElement.style.visibility = 'visible';
        });
    }

    // Quando o usuário digitar, verifica se o texto começa com '/'
    inputElement.addEventListener('input', function() {
        const text = this.value;
        
        if (text.startsWith('/')) {
            const filtered = commands.filter(cmd => 
                cmd.toLowerCase().startsWith(text.toLowerCase())
            );

            if (filtered.length > 0) {
                menuElement.innerHTML = filtered.map(cmd => `
                    <div class="command-item" role="option" data-command="${cmd}">
                        <div>
                            <div class="command-text">${cmd}</div>
                            <div class="command-description">Descrição para ${cmd}</div>
                        </div>
                    </div>
                `).join('');

                menuElement.querySelectorAll('.command-item').forEach(item => {
                    item.addEventListener('click', function(e) {
                        e.stopPropagation();
                        const command = this.dataset.command;
                        inputElement.value = command + ' ';
                        menuElement.classList.remove('visible');
                        menuElement.style.display = 'none';
                        inputElement.focus();
                        inputElement.selectionStart = inputElement.selectionEnd = inputElement.value.length;
                    });
                });

                menuElement.style.display = 'block';
                menuElement.classList.add('visible');
                updateMenuPosition();
            } else {
                menuElement.classList.remove('visible');
                menuElement.style.display = 'none';
            }
        } else {
            menuElement.classList.remove('visible');
            menuElement.style.display = 'none';
        }
    });

    // Atualizar posição do menu ao rolar a página
    window.addEventListener('scroll', () => {
        if (menuElement.classList.contains('visible')) {
            updateMenuPosition();
        }
    });

    // Atualizar posição do menu ao redimensionar a janela
    window.addEventListener('resize', () => {
        if (menuElement.classList.contains('visible')) {
            updateMenuPosition();
        }
    });

    function updateSelectedItem() {
        items.forEach((item, index) => {
            item.classList.toggle('selected', index === selectedIndex);
            item.setAttribute('aria-selected', index === selectedIndex);
        });
        
        if (items[selectedIndex]) {
            items[selectedIndex].scrollIntoView({
                block: 'nearest',
                behavior: 'auto'
            });
        }
    }

    inputElement.addEventListener('keydown', function(e) {
        if (!menuElement.classList.contains('visible')) return;

        switch(e.key) {
            case 'Escape':
                e.preventDefault();
                menuElement.classList.remove('visible');
                menuElement.style.display = 'none';
                selectedIndex = -1;
                updateSelectedItem();
                break;
                
            case 'Enter':
                e.preventDefault();
                if (selectedIndex > -1 && items[selectedIndex]) {
                    items[selectedIndex].click();
                }
                break;

            case 'ArrowDown':
                e.preventDefault();
                selectedIndex = Math.min(selectedIndex + 1, items.length - 1);
                if (selectedIndex === -1 && items.length > 0) selectedIndex = 0;
                updateSelectedItem();
                break;
                
            case 'ArrowUp':
                e.preventDefault();
                selectedIndex = Math.max(selectedIndex - 1, -1);
                updateSelectedItem();
                break;
        }
    });

    // Observer para atualizar itens quando o conteúdo do menu mudar
    const observer = new MutationObserver(() => {
        items.length = 0;
        menuElement.querySelectorAll('.command-item').forEach(item => items.push(item));
        selectedIndex = -1;
        updateSelectedItem();
    });

    observer.observe(menuElement, { childList: true, subtree: true });

    // Clicar fora fecha o menu
    document.addEventListener('click', (e) => {
        if (!menuElement.contains(e.target) && e.target !== inputElement) {
            menuElement.classList.remove('visible');
            menuElement.style.display = 'none';
        }
    });
}


Conteúdo de events.js:
// Importações necessárias
import { toggleTheme } from './theme.js';
import { toggleSidebar } from './sidebar.js';
import { configureTextarea } from './textarea.js';

export function configureEventListeners() {
    const themeToggle = document.querySelector('.theme-toggle');
    const modelSelect = document.querySelector('.model-select');
    const sidebarToggle = document.querySelector('.sidebar-toggle');
    const headerSidebarToggle = document.querySelector('.header-sidebar-toggle');

    // Event Listeners
    themeToggle?.addEventListener('click', toggleTheme);
    sidebarToggle?.addEventListener('click', toggleSidebar);
    headerSidebarToggle?.addEventListener('click', toggleSidebar);

    modelSelect?.addEventListener('change', (e) => {
        window.currentModel = e.target.value;
    });

    // Configurar textareas
    configureTextarea(document.querySelector('#chat-input'));
    configureTextarea(document.querySelector('#welcome-input'));
}

Conteúdo de init.js:
import { initializeTheme } from './theme.js';
import { configureEventListeners } from './events.js';

document.addEventListener('DOMContentLoaded', () => {
    initializeTheme();
    configureEventListeners();
});

Conteúdo de main.js:

import './init.js';
import { 
    iniciarChat,
    mostrarTelaInicial,
    adicionarMensagem,
    melhorarBlocosCodigo,
    inicializarSync
} from './chat.js';
import { enviarMensagem, interromperResposta } from './chat/chatActions.js';
import { 
    carregarConversa,
    atualizarListaConversas,
    criarNovaConversa,
    adicionarMensagemAoHistorico,
    renomearConversa,
    excluirConversa
} from './chat/chatStorage.js';
import { initializeInputBar, destroyInputBar } from './modules/inputBar.js';
import { copiarMensagem, regenerarResposta } from './chat/chatUtils.js';

// Estado global
window.currentModel = 'gemma2:2b';
window.conversas = [];
window.conversaAtual = null;
window.conversations = {}; // Nova estrutura global para mapear conversas por ID
window.copiarMensagem = copiarMensagem;
window.regenerarResposta = regenerarResposta;

let welcomeBar = null;
let chatBar = null;

document.addEventListener('DOMContentLoaded', () => {
    // Inicializar WebSocket para sincronização entre abas
    inicializarSync();
    
    const welcomeForm = document.getElementById('welcome-form');
    const chatForm = document.getElementById('chat-form');
    const chatContainer = document.querySelector('.chat-container');
    const welcomeInput = document.getElementById('welcome-input');
    const chatInput = document.getElementById('chat-input');
    const sendBtn = document.getElementById('send-btn');
    const stopBtn = document.getElementById('stop-btn');
    const newChatBtn = document.querySelector('.new-chat-btn');

    // Configurar menu de comando usando o módulo criado
    const welcomeCommandMenu = document.getElementById('command-menu');
    const chatCommandMenu = document.getElementById('chat-command-menu');

    const COMMANDS = [
        { command: '/youtube', description: 'Processar vídeo do YouTube' },
        { command: '/salvar', description: 'Salvar conversa atual' },
        { command: '/historico', description: 'Ver histórico completo' },
        { command: '/config', description: 'Abrir configurações' }
    ];

    // Prevenir submit padrão dos formulários
    document.querySelectorAll('form').forEach(form => {
        form.addEventListener('submit', (e) => {
            e.preventDefault();
        });
    });

    // Inicializar barra de entrada da tela inicial
    if (welcomeInput && welcomeCommandMenu) {
        welcomeBar = initializeInputBar(
            welcomeInput, 
            welcomeCommandMenu, 
            COMMANDS.map(c => c.command)
        );

        welcomeForm?.addEventListener('submit', async (e) => {
            e.preventDefault();
            const message = welcomeInput.value.trim();
            if (!message) return;
            
            // Criar nova conversa se não existir
            if (!window.conversaAtual) {
                criarNovaConversa();
            }

            // Limpar barra de boas-vindas antes de trocar de tela
            welcomeBar?.destroy();

            iniciarChat(
                document.querySelector('.welcome-screen'),
                chatContainer,
                document.querySelector('.input-container')
            );
            
            await enviarMensagem(message, welcomeInput, chatContainer, sendBtn, stopBtn);
            atualizarListaConversas(); // Atualizar histórico após enviar mensagem
            
            // Adicionar barras de título aos blocos de código
            setTimeout(() => {
                melhorarBlocosCodigo();
            }, 100);
        });
    }

    // Inicializar barra de entrada do chat
    if (chatInput && chatCommandMenu) {
        chatBar = initializeInputBar(
            chatInput, 
            chatCommandMenu, 
            COMMANDS.map(c => c.command)
        );

        chatForm?.addEventListener('submit', async (e) => {
            e.preventDefault();
            const message = chatInput.value.trim();
            if (!message) return;
            
            // Verificar se há uma conversa ativa
            if (!window.conversaAtual) {
                criarNovaConversa();
            }
            
            // Armazenar o ID da conversa atual para garantir que estamos na mesma conversa após o streaming
            const currentConversationId = window.conversaAtual.id;
            
            chatBar.clear();
            await enviarMensagem(message, chatInput, chatContainer, sendBtn, stopBtn);
            
            // Verificar se ainda estamos na mesma conversa
            if (window.conversaAtual && window.conversaAtual.id === currentConversationId) {
                atualizarListaConversas(); // Atualizar histórico após enviar mensagem
                
                // Adicionar barras de título aos blocos de código
                setTimeout(() => {
                    melhorarBlocosCodigo();
                }, 100);
            }
        });
    }

    // Configurar botão de nova conversa
    newChatBtn?.addEventListener('click', () => {
        if (window.conversaAtual) {
            atualizarListaConversas(); // Atualizar histórico antes de criar nova conversa
        }
        
        // Limpar barra do chat antes de trocar de tela
        chatBar?.destroy();
        
        window.conversaAtual = null;
        mostrarTelaInicial(
            document.querySelector('.welcome-screen'),
            chatContainer,
            document.querySelector('.input-container'),
            welcomeInput,
            chatInput
        );

        // Reinicializar barra de boas-vindas
        if (welcomeInput && welcomeCommandMenu) {
            welcomeBar = initializeInputBar(
                welcomeInput, 
                welcomeCommandMenu, 
                COMMANDS.map(c => c.command)
            );
        }
    });

    // Configurar botão de parar resposta
    stopBtn?.addEventListener('click', () => {
        interromperResposta();
    });

    // Inicializar lista de conversas
    atualizarListaConversas();

    // Eventos para gerenciamento de estado isolado
    window.addEventListener('conversaCarregada', (e) => {
        if (e.detail && e.detail.id) {
            // Conversa carregada
        }
    });
    
    window.addEventListener('conversaAtualizada', (e) => {
        if (e.detail && e.detail.id) {
            // Conversa atualizada
        }
        atualizarListaConversas();
    });
    
    window.addEventListener('mensagemEnviada', (e) => {
        if (window.conversaAtual) {
            // Mensagem enviada 
        }
    });
    
    // Processar blocos de código já existentes (ao carregar uma conversa)
    melhorarBlocosCodigo();
    
    // Observar mudanças no DOM para processar novos blocos de código
    const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
            if (mutation.addedNodes.length > 0) {
                setTimeout(() => {
                    melhorarBlocosCodigo();
                }, 100);
            }
        });
    });
    
    observer.observe(chatContainer, { childList: true, subtree: true });
    
    // Configurar o listener de visibilidade para sincronização
    document.addEventListener('visibilitychange', () => {
        if (document.visibilityState === 'visible') {
            // Atualizar o estado quando a aba ficar visível
            atualizarListaConversas();
            
            // Se houver uma conversa atual, verificar se há atualizações pendentes
            if (window.conversaAtual && window.conversations[window.conversaAtual.id]?.pendingUpdates) {
                carregarConversa(window.conversaAtual.id);
                window.conversations[window.conversaAtual.id].pendingUpdates = false;
            }
        }
    });
});

// Expor funções globalmente
window.carregarConversa = carregarConversa;
window.criarNovaConversa = criarNovaConversa;
window.adicionarMensagemAoHistorico = adicionarMensagemAoHistorico;
window.interromperResposta = interromperResposta;
window.renomearConversa = renomearConversa;
window.excluirConversa = excluirConversa;
window.melhorarBlocosCodigo = melhorarBlocosCodigo;



Conteúdo de messageRenderer.js:

/**
 * Renderiza uma mensagem formatada com Markdown usando marked.js e highlight.js
 * @param {string} text - Texto em formato Markdown
 * @returns {string} HTML formatado
 */
export function renderMessage(text) {
    // Verificar dependências
    if (typeof marked === 'undefined') {
        console.error('[ERRO] marked.js não está definido.');
        return `<p>${text}</p>`;
    }
    if (typeof hljs === 'undefined') {
        console.error('[ERRO] highlight.js não está definido.');
        return `<pre>${text}</pre>`;
    }

    // Capturar ID da conversa atual para contexto
    const conversationId = window.conversaAtual?.id;

    // Configurar highlight.js
    hljs.configure({
        cssSelector: 'pre code',
        ignoreUnescapedHTML: true
    });

    // Configurar marked.js com destaque simples
    marked.setOptions({
        gfm: true,               // Suporte a GitHub Flavored Markdown
        breaks: false,           // Não converter \n em <br>
        pedantic: false,         // Não ser extremamente rígido
        sanitize: false,         // Não sanitizar (usaremos DOMPurify)
        smartLists: true,        // Listas inteligentes
        smartypants: false,      // Não usar tipografia avançada
        highlight: function(code, lang) {
            try {
                // Identificar a linguagem correta ou usar plaintext como fallback
                const language = lang && hljs.getLanguage(lang) ? lang : 'plaintext';
                
                // Aplicar highlight.js ao código
                const highlighted = hljs.highlight(code, { language }).value;
                
                // Retornar o código com a classe de linguagem para detecção posterior
                return `<code class="language-${language} hljs">${highlighted}</code>`;
            } catch (error) {
                return code;
            }
        }
    });

    try {
        // Verificar DOMPurify
        if (typeof DOMPurify === 'undefined') {
            return marked.parse(text);
        }

        // Configurar sanitização para preservar a estrutura do código
        const allowedTags = ['pre', 'code', 'span', 'div', 'p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
                            'ul', 'ol', 'li', 'blockquote', 'a', 'strong', 'em', 'del', 'table',
                            'thead', 'tbody', 'tr', 'th', 'td', 'hr', 'br', 'img'];

        const allowedAttributes = {
            'code': ['class'],  // Permitir classes em <code> para detectar a linguagem
            'span': ['class'],
            'a': ['href', 'target', 'rel'],
            'img': ['src', 'alt'],
            // Adicionar data-* attributes para manter isolamento de contexto
            '*': ['data-conversation-id']
        };

        // Parsear o Markdown
        const htmlContent = marked.parse(text);

        // Sanitizar o HTML preservando a estrutura
        const finalHtml = DOMPurify.sanitize(htmlContent, {
            ALLOWED_TAGS: allowedTags,
            ALLOWED_ATTR: allowedAttributes,
            ADD_ATTR: ['target', 'data-conversation-id'],
        });
        
        return finalHtml;
    } catch (error) {
        return `<p>${text.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</p>`;
    }
}

/**
 * Renderiza incrementalmente mensagens durante o streaming
 * Versão otimizada para atualizações rápidas durante streaming
 */
export function renderStreamingMessage(text) {
    // Para streaming, usamos uma versão simplificada para melhor performance
    try {
        if (typeof marked === 'undefined' || typeof DOMPurify === 'undefined') {
            return `<p>${text.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</p>`;
        }
        
        // Sanitizar o texto em Markdown
        const htmlContent = marked.parse(text);
        const finalHtml = DOMPurify.sanitize(htmlContent, {
            ALLOWED_TAGS: ['p', 'strong', 'em', 'code', 'pre', 'br', 'ul', 'ol', 'li'],
        });
        
        return finalHtml;
    } catch (error) {
        // Fallback seguro se houver erro
        return `<p>${text.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</p>`;
    }
}


Conteúdo de commandHandler.js:
(function() { // IIFE para isolamento de escopo
    const COMMAND_PREFIX = '/';
    const COMMANDS = ['/youtube', '/google', '/help', '/settings'];
    
    class CommandMenu {
        constructor() {
            this.input = document.getElementById('chat-input');
            if (!this.input) {
                console.error('[Erro] Elemento #chat-input não encontrado');
                return;
            }
            
            this.initMenu();
            this.setupListeners();
        }

        initMenu() {
            this.menu = document.createElement('div');
            this.menu.className = 'cmd-menu';
            document.body.appendChild(this.menu);
        }

        setupListeners() {
            this.input.addEventListener('input', () => this.handleInput());
            document.addEventListener('click', (e) => this.handleOutsideClick(e));
            this.menu.addEventListener('click', (e) => this.handleMenuClick(e));
        }

        handleInput() {
            const text = this.input.value.trim();
            
            if (text.startsWith(COMMAND_PREFIX)) {
                this.positionMenu();
                this.filterCommands(text);
            } else {
                this.hideMenu();
            }
        }

        positionMenu() {
            const rect = this.input.getBoundingClientRect();
            this.menu.style.top = `${rect.bottom + window.scrollY}px`;
            this.menu.style.left = `${rect.left}px`;
            this.menu.classList.add('visible');
        }

        filterCommands(text) {
            this.menu.innerHTML = COMMANDS
                .filter(cmd => cmd.toLowerCase().startsWith(text.toLowerCase()))
                .map(cmd => `<div class="cmd-item" data-cmd="${cmd}">${cmd}</div>`)
                .join('');
        }

        handleMenuClick(e) {
            const item = e.target.closest('.cmd-item');
            if (item) {
                this.input.value = `${item.dataset.cmd} `;
                this.hideMenu();
                this.input.focus();
            }
        }

        handleOutsideClick(e) {
            if (!this.input.contains(e.target) && !this.menu.contains(e.target)) {
                this.hideMenu();
            }
        }

        hideMenu() {
            this.menu.classList.remove('visible');
        }
    }

    // Inicialização segura após DOM carregado
    document.addEventListener('DOMContentLoaded', () => {
        new CommandMenu();
    });
})();


Conteúdo de inputBar.js:

import { initCommandMenu } from '../commandMenu.js';
import { configureTextarea } from '../textarea.js';

const activeListeners = new WeakMap();

function handleSubmit(e, inputElement) {
    e.preventDefault();
    const message = inputElement.value.trim();
    
    // Não enviar se for comando incompleto
    if (message.startsWith('/') && !message.includes(' ')) {
        return;
    }

    if (message) {
        const submitEvent = new CustomEvent('customSubmit', { 
            detail: { message },
            bubbles: true 
        });
        e.target.dispatchEvent(submitEvent);
    }
}

export function initializeInputBar(inputElement, menuElement, commands) {
    if (!inputElement || !menuElement) {
        console.error('Elementos necessários não fornecidos para initializeInputBar');
        return;
    }

    // Limpar listeners antigos se existirem
    destroyInputBar(inputElement);

    // Configurar textarea (autoajuste de altura e eventos)
    configureTextarea(inputElement);

    // Configurar menu de comandos
    initCommandMenu(inputElement, menuElement, commands);

    // Adicionar evento de submit unificado
    const form = inputElement.closest('form');
    if (form) {
        const boundSubmitHandler = (e) => handleSubmit(e, inputElement);
        form.addEventListener('submit', boundSubmitHandler);
        
        // Armazenar referência ao listener para limpeza posterior
        activeListeners.set(form, boundSubmitHandler);
    }

    // Adicionar atributos de acessibilidade
    inputElement.setAttribute('aria-label', 'Campo de mensagem');
    inputElement.setAttribute('aria-describedby', 'message-instructions');

    return {
        focus: () => inputElement.focus(),
        clear: () => {
            inputElement.value = '';
            inputElement.style.height = 'auto';
        },
        getValue: () => inputElement.value,
        setValue: (value) => {
            inputElement.value = value;
            inputElement.style.height = 'auto';
            inputElement.style.height = inputElement.scrollHeight + 'px';
        },
        destroy: () => destroyInputBar(inputElement)
    };
}

export function destroyInputBar(inputElement) {
    const form = inputElement.closest('form');
    if (form) {
        // Remover listener específico se existir
        const listener = activeListeners.get(form);
        if (listener) {
            form.removeEventListener('submit', listener);
            activeListeners.delete(form);
        }
    }
}


Conteúdo de sidebar.js:
export function toggleSidebar() {
    const sidebar = document.querySelector('.sidebar');
    const mainContent = document.querySelector('.main-content');
    
    sidebar.classList.toggle('collapsed');
    mainContent.classList.toggle('expanded');
}

Conteúdo de textarea.js:

export function configureTextarea(textarea) {
    if (!textarea) return;

    textarea.addEventListener('input', function() {
        this.style.height = 'auto';
        this.style.height = (this.scrollHeight) + 'px';
    });

    textarea.addEventListener('keydown', function(e) {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            const form = this.closest('form');
            if (form) {
                const event = new Event('submit', {
                    'bubbles': true,
                    'cancelable': true
                });
                form.dispatchEvent(event);
            }
        }
    });
}


Conteúdo de theme.js:
// Estado do tema
let currentTheme = 'light';

// Função para alternar o tema
export function toggleTheme() {
    currentTheme = currentTheme === 'light' ? 'dark' : 'light';
    document.documentElement.setAttribute('data-theme', currentTheme);
    localStorage.setItem('theme', currentTheme);
    
    const themeToggle = document.querySelector('.theme-toggle');
    if (themeToggle) {
        themeToggle.innerHTML = currentTheme === 'light' 
            ? '<i class="fas fa-moon"></i>' 
            : '<i class="fas fa-sun"></i>';
    }
}

// Função para inicializar o tema
export function initializeTheme() {
    const savedTheme = localStorage.getItem('theme') || 'light';
    if (savedTheme === 'dark') {
        toggleTheme();
    }
}

Conteúdo de utils.js:
export function escapeHTML(text) {
    const div = document.createElement('div');
    div.innerText = text;
    return div.innerHTML;
}

export function mostrarCarregamento(chatContainer) {
    const loadingDiv = document.createElement('div');
    loadingDiv.className = 'loading message assistant';
    loadingDiv.innerHTML = `
        <span></span>
        <span></span>
        <span></span>
    `;
    chatContainer.appendChild(loadingDiv);
    chatContainer.scrollTop = chatContainer.scrollHeight;
    return loadingDiv;
}

Conteúdo de index.html:

<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Chat</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;500&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    
    <!-- Bibliotecas para Markdown e Code Highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.0.6/purify.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    
    <!-- Socket.IO para sincronização em tempo real -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.5/socket.io.min.js"></script>
    
    <!-- CSS do projeto -->
    <link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='css/styles.css') }}">

</head>
<body>
    <div class="container">
        <!-- Barra Lateral -->
        <aside class="sidebar">
            <button class="new-chat-btn">
                <i class="fas fa-plus"></i>
                Novo Chat
            </button>
            <div class="search-box">
                <input type="text" id="search-input" placeholder="Pesquisar conversas...">
            </div>
            <div class="chat-list">
                <!-- Lista de conversas será preenchida via JavaScript -->
            </div>
            <button class="settings-btn">
                <i class="fas fa-cog"></i>
                Configurações
            </button>
        </aside>

        <!-- Conteúdo Principal -->
        <main class="main-content">
            <div class="top-bar">
                <button class="header-sidebar-toggle">
                    <i class="fas fa-bars"></i>
                </button>
                <h1 class="program-name">AI Chat</h1>
                <div class="top-bar-actions">
                    <button class="theme-toggle">
                        <i class="fas fa-moon"></i>
                    </button>
                    <select class="model-select">
                        <option value="gemma2:2b">gemma2:2b</option>
                    </select>
                </div>
            </div>

            <!-- Tela de Boas-vindas -->
            <div class="welcome-screen">
                <h1>Como posso ajudar?</h1>
                <form class="input-box" id="welcome-form">
                    <textarea 
                        id="welcome-input" 
                        placeholder="Digite / para ver os comandos..." 
                        rows="1"
                    ></textarea>
                    <!-- Área para o menu de comandos na tela de boas-vindas -->
                    <div id="command-menu" class="command-menu">
                        <div class="command-item" data-command="/youtube">
                            <i class="fas fa-youtube command-icon"></i>
                            <div>
                                <div class="command-text">/youtube</div>
                                <div class="command-description">Resumir vídeo do YouTube</div>
                            </div>
                        </div>
                    </div>
                    <button type="submit" class="send-btn">
                        <i class="fas fa-paper-plane"></i>
                    </button>
                </form>
                <div class="quick-actions">
                    <button class="quick-action-btn">
                        <i class="fas fa-lightbulb"></i>
                        Sugerir ideias
                    </button>
                    <button class="quick-action-btn">
                        <i class="fas fa-file-alt"></i>
                        Resumir texto
                    </button>
                    <button class="quick-action-btn">
                        <i class="fas fa-code"></i>
                        Ajuda com código
                    </button>
                    <button class="quick-action-btn">
                        <i class="fas fa-question-circle"></i>
                        Tirar dúvidas
                    </button>
                </div>
            </div>

            <!-- Container de Chat -->
            <div class="chat-container" style="display: none;">
                <!-- Mensagens serão inseridas aqui -->
            </div>

            <!-- Container de Input -->
            <div class="input-container" style="display: none;">
                <form class="input-box" id="chat-form">
                    <textarea 
                        id="chat-input" 
                        placeholder="Digite / para ver os comandos..." 
                        rows="1"
                    ></textarea>
                    <!-- Área para o menu de comandos no chat ativo -->
                    <div id="chat-command-menu" class="command-menu">
                        <div class="command-item" data-command="/youtube">
                            <i class="fas fa-youtube command-icon"></i>
                            <div>
                                <div class="command-text">/youtube</div>
                                <div class="command-description">Resumir vídeo do YouTube</div>
                            </div>
                        </div>
                    </div>
                    <button type="submit" class="send-btn" id="send-btn">
                        <i class="fas fa-paper-plane"></i>
                    </button>
                    <button type="button" class="stop-btn" id="stop-btn" style="display: none;">
                        <i class="fas fa-stop"></i>
                    </button>
                </form>
            </div>
        </main>
    </div>

    <!-- Inicialização do highlight.js -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Configurar highlight.js
            hljs.configure({
                ignoreUnescapedHTML: true
            });
            
            // Aplicar highlight.js em todos os blocos de código
            document.querySelectorAll('pre code').forEach((block) => {
                hljs.highlightElement(block);
            });
            
            // Expor copiarCodigo globalmente
            window.copiarCodigo = function(button) {
                const codeContainer = button.closest('.code-container');
                const codeBlock = codeContainer.querySelector('.code-block code');
                
                const tempTextarea = document.createElement('textarea');
                tempTextarea.value = codeBlock.innerText
                    .replace(/&lt;/g, '<')
                    .replace(/&gt;/g, '>')
                    .replace(/&amp;/g, '&')
                    .trim();
                
                document.body.appendChild(tempTextarea);
                tempTextarea.select();
                
                try {
                    document.execCommand('copy');
                    button.innerHTML = '<i class="fas fa-check"></i>';
                    button.classList.add('copied');
                    
                    setTimeout(() => {
                        button.innerHTML = '<i class="fas fa-copy"></i>';
                        button.classList.remove('copied');
                    }, 2000);
                } catch (err) {
                    console.error('Erro ao copiar código:', err);
                    alert('Não foi possível copiar o código. Por favor, tente novamente.');
                } finally {
                    document.body.removeChild(tempTextarea);
                }
            };
        });
    </script>

    <!-- Scripts do projeto -->
    <script type="module" src="{{ url_for('static', filename='js/theme.js') }}"></script>
    <script type="module" src="{{ url_for('static', filename='js/main.js') }}"></script>
</body>
</html>


Conteúdo de chat_history.py:
import json
from datetime import datetime
import os

HISTORY_FILE = 'data/chat_history.json'

def ensure_data_directory():
    os.makedirs('data', exist_ok=True)

def get_conversation_history():
    ensure_data_directory()
    try:
        if os.path.exists(HISTORY_FILE):
            with open(HISTORY_FILE, 'r', encoding='utf-8') as f:
                return json.load(f)
        return []
    except json.JSONDecodeError as e:
        print(f"Erro ao carregar histórico: {str(e)}")
        return []  # Retorna uma lista vazia em caso de erro
    except Exception as e:
        print(f"Erro ao carregar histórico: {str(e)}")
        return []  # Retorna uma lista vazia em caso de erro

def get_conversation_by_id(conversation_id):
    """Busca uma conversa específica pelo ID"""
    conversations = get_conversation_history()
    for conversation in conversations:
        if conversation['id'] == conversation_id:
            return conversation
    return None
  
def save_conversation(message, response, conversation_id=None):
    """
    Salva ou atualiza uma conversa no histórico.
    Se conversation_id for fornecido, atualiza a conversa existente.
    Caso contrário, cria uma nova conversa.
    """
    ensure_data_directory()
    try:
        # Carrega o histórico atual
        conversations = get_conversation_history()
        
        if conversation_id:
            # Atualiza conversa existente
            updated = False
            for conversation in conversations:
                if conversation['id'] == conversation_id:
                    conversation['messages'].extend([
                        {'role': 'user', 'content': message},
                        {'role': 'assistant', 'content': response}
                    ])
                    conversation['timestamp'] = datetime.now().isoformat()
                    updated = True
                    break
            
            # Se não encontrou o ID, cria uma nova conversa (backup seguro)
            if not updated:
                conversation_id = str(len(conversations) + 1)
                new_conversation = {
                    'id': conversation_id,
                    'timestamp': datetime.now().isoformat(),
                    'messages': [
                        {'role': 'user', 'content': message},
                        {'role': 'assistant', 'content': response}
                    ]
                }
                conversations.append(new_conversation)
        else:
            # Cria nova conversa
            conversation_id = str(len(conversations) + 1)
            new_conversation = {
                'id': conversation_id,
                'timestamp': datetime.now().isoformat(),
                'messages': [
                    {'role': 'user', 'content': message},
                    {'role': 'assistant', 'content': response}
                ]
            }
            conversations.append(new_conversation)
        
        # Salva as conversas atualizadas
        with open(HISTORY_FILE, 'w', encoding='utf-8') as f:
            json.dump(conversations, f, ensure_ascii=False, indent=2)
        
        return conversation_id
    except Exception as e:
        print(f"Erro ao salvar conversa: {str(e)}")
        return None
 

Conteúdo de chat_storage.py:

import json
import os
from datetime import datetime

DATA_DIR = "data"
CONVERSATIONS_DIR = os.path.join(DATA_DIR, "conversations")
INDEX_FILE = os.path.join(DATA_DIR, "index.json")

def ensure_directories():
    """Garante que os diretórios necessários existam"""
    os.makedirs(CONVERSATIONS_DIR, exist_ok=True)

def create_new_conversation():
    """Cria uma nova conversa e retorna seu ID"""
    ensure_directories()
    
    conversation_id = str(int(datetime.now().timestamp() * 1000))
    conversation = {
        "id": conversation_id,
        "title": "Nova conversa",
        "timestamp": datetime.now().isoformat(),
        "messages": []
    }
    
    save_conversation(conversation)
    update_index(conversation)
    
    return conversation_id

def save_conversation(conversation):
    """Salva uma conversa em seu arquivo JSON"""
    filename = f"conversation_{conversation['id']}.json"
    filepath = os.path.join(CONVERSATIONS_DIR, filename)
    
    # print(f"[DEBUG] Salvando conversa em: {filepath}")
    
    try:
        with open(filepath, 'w', encoding='utf-8') as f:
            json.dump(conversation, f, ensure_ascii=False, indent=2)
        # print("[DEBUG] Conversa salva com sucesso")
        return True
    except Exception as e:
        print(f"[ERRO] Falha ao salvar conversa: {str(e)}")
        return False

def update_index(conversation):
    """Atualiza o arquivo de índice com os metadados da conversa"""
    ensure_directories()
    
    # print(f"[DEBUG] Atualizando índice para conversa: {conversation['id']}")
    
    try:
        with open(INDEX_FILE, 'r', encoding='utf-8') as f:
            index = json.load(f)
    except (FileNotFoundError, json.JSONDecodeError):
        # print("[DEBUG] Arquivo de índice não encontrado ou inválido, criando novo")
        index = []
    
    entry = {
        "id": conversation["id"],
        "title": conversation.get("title", "Nova conversa"),
        "timestamp": conversation["timestamp"],
        "filename": f"conversation_{conversation['id']}.json"
    }
    
    # Remover entrada antiga se existir
    index = [item for item in index if item["id"] != conversation["id"]]
    index.append(entry)
    index.sort(key=lambda x: x["timestamp"], reverse=True)
    
    try:
        with open(INDEX_FILE, 'w', encoding='utf-8') as f:
            json.dump(index, f, ensure_ascii=False, indent=2)
        # print("[DEBUG] Índice atualizado com sucesso")
        return True
    except Exception as e:
        print(f"[ERRO] Falha ao atualizar índice: {str(e)}")
        return False

def get_conversation_by_id(conversation_id):
    """Recupera uma conversa específica pelo ID"""
    filename = f"conversation_{conversation_id}.json"
    filepath = os.path.join(CONVERSATIONS_DIR, filename)
    
    # print(f"[DEBUG] Buscando conversa: {conversation_id}")
    
    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            return json.load(f)
    except FileNotFoundError:
        # print(f"[DEBUG] Conversa não encontrada: {conversation_id}")
        return None
    except json.JSONDecodeError:
        print(f"[ERRO] Arquivo de conversa corrompido: {conversation_id}")
        return None
    except Exception as e:
        print(f"[ERRO] Erro ao carregar conversa: {str(e)}")
        return None

def get_conversation_history():
    """Recupera o histórico de todas as conversas"""
    ensure_directories()
    
    # print("[DEBUG] Carregando histórico de conversas")
    
    try:
        with open(INDEX_FILE, 'r', encoding='utf-8') as f:
            index = json.load(f)
            
        # Verificar se todos os arquivos ainda existem
        valid_entries = []
        for entry in index:
            filepath = os.path.join(CONVERSATIONS_DIR, entry.get("filename", ""))
            if os.path.exists(filepath):
                valid_entries.append(entry)
            else:
                # print(f"[DEBUG] Arquivo não encontrado para conversa {entry.get('id')}: {filepath}")
                pass
                
        return valid_entries
    except (FileNotFoundError, json.JSONDecodeError):
        # print("[DEBUG] Arquivo de índice não encontrado ou inválido")
        return []
    except Exception as e:
        print(f"[ERRO] Erro ao carregar histórico: {str(e)}")
        return []

def add_message_to_conversation(conversation_id, content, role):
    """Adiciona uma mensagem a uma conversa existente"""
    # print(f"[DEBUG] Adicionando mensagem tipo '{role}' à conversa {conversation_id}")
    
    conversation = get_conversation_by_id(conversation_id)
    
    if not conversation:
        # print(f"[DEBUG] Criando nova conversa para ID: {conversation_id}")
        conversation = {
            "id": conversation_id,
            "title": "Nova conversa",
            "timestamp": datetime.now().isoformat(),
            "messages": []
        }
    
    message = {
        "role": role,
        "content": content,
        "timestamp": datetime.now().isoformat()
    }
    
    conversation["messages"].append(message)
    conversation["timestamp"] = datetime.now().isoformat()
    
    # Definir título automaticamente com base na primeira mensagem do usuário
    if role == "user" and len([m for m in conversation["messages"] if m["role"] == "user"]) == 1:
        conversation["title"] = content[:30] + "..." if len(content) > 30 else content
        # print(f"[DEBUG] Título da conversa atualizado para: {conversation['title']}")
    
    save_conversation(conversation)
    update_index(conversation)
    
    return True

def delete_conversation(conversation_id):
    """Exclui uma conversa e sua entrada no índice"""
    filename = f"conversation_{conversation_id}.json"
    filepath = os.path.join(CONVERSATIONS_DIR, filename)
    
    # print(f"[DEBUG] Tentando excluir conversa: {conversation_id}")
    
    try:
        # Remove o arquivo da conversa se existir
        if os.path.exists(filepath):
            os.remove(filepath)
            # print(f"[DEBUG] Arquivo da conversa removido: {filepath}")
        else:
            # print(f"[DEBUG] Arquivo não encontrado: {filepath}")
            pass
            
        # Remove a entrada do índice
        try:
            with open(INDEX_FILE, 'r', encoding='utf-8') as f:
                index = json.load(f)
        except (FileNotFoundError, json.JSONDecodeError):
            # print("[DEBUG] Arquivo de índice não encontrado ou inválido")
            index = []
            
        # Filtra a conversa do índice
        index = [item for item in index if item["id"] != conversation_id]
        
        # Salva o índice atualizado
        with open(INDEX_FILE, 'w', encoding='utf-8') as f:
            json.dump(index, f, ensure_ascii=False, indent=2)
        
        # print("[DEBUG] Conversa excluída com sucesso")
        return True
    except Exception as e:
        print(f"[ERRO] Falha ao excluir conversa: {str(e)}")
        return False

def rename_conversation(conversation_id, new_title):
    """Renomeia uma conversa existente"""
    # print(f"[DEBUG] Tentando renomear conversa {conversation_id} para: {new_title}")
    
    conversation = get_conversation_by_id(conversation_id)
    if not conversation:
        print(f"[ERRO] Conversa {conversation_id} não existe")
        return False
        
    try:
        # Atualiza o título com validação
        new_title = new_title.strip()
        if not new_title or len(new_title) > 100:
            print("[ERRO] Título inválido ou muito longo")
            return False
            
        conversation["title"] = new_title
        conversation["timestamp"] = datetime.now().isoformat() # Atualiza timestamp
        
        # print(f"[DEBUG] Novo título salvo: {conversation['title']}")
        
        # Salva as alterações
        save_success = save_conversation(conversation)
        if not save_success:
            print("[ERRO] Falha ao salvar conversa")
            return False
            
        index_success = update_index(conversation)
        if not index_success:
            print("[ERRO] Falha ao atualizar índice")
            return False
        
        # print("[DEBUG] Conversa renomeada com sucesso")
        return True
    except Exception as e:
        print(f"[ERRO] Falha ao renomear conversa: {str(e)}")
        return False


Conteúdo de text_processor.py:

def split_text(text: str, words_per_chunk: int = 300) -> list[str]:
    """
    Divide um texto em chunks menores baseado no número de palavras.
    """
    words = text.split()
    chunks = []
    
    for i in range(0, len(words), words_per_chunk):
        chunk = ' '.join(words[i:i + words_per_chunk])
        chunks.append(chunk)
    
    return chunks

def clean_and_format_text(text: str) -> str:
    """
    Limpa e formata o texto removendo caracteres especiais e formatação desnecessária
    """
    import re
    
    # Remove múltiplos espaços
    text = re.sub(r'\s+', ' ', text)
    # Remove caracteres especiais mantendo pontuação básica
    text = re.sub(r'[^\w\s.,!?-]', '', text)
    # Remove espaços antes de pontuação
    text = re.sub(r'\s+([.,!?])', r'\1', text)
    
    return text.strip()



Conteúdo de __init__.py:

# Este arquivo pode ficar vazio


Conteúdo de youtube_handler.py:

import os
import json
import yt_dlp
import re
from typing import Optional, Dict, Any, Tuple

class YoutubeHandler:
    def __init__(self, download_path: str = "./temp"):
        self.download_path = download_path
        if not os.path.exists(download_path):
            os.makedirs(download_path)

    def download_subtitles(self, video_url: str) -> Tuple[Optional[str], Optional[str]]:
        """
        Baixa as legendas de um vídeo do YouTube, priorizando PT-BR
        Retorna uma tupla (caminho_do_arquivo, título_do_vídeo)
        """
        ydl_opts = {
            'writesubtitles': True,
            'writeautomaticsub': True,  # Aceita legendas automáticas como fallback
            'subtitleslangs': ['pt-BR', 'pt', 'en'],  # Prioridade: PT-BR > PT > EN
            'skip_download': True,
            'outtmpl': os.path.join(self.download_path, '%(id)s.%(ext)s'),
            'quiet': True
        }

        try:
            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                info = ydl.extract_info(video_url, download=True)
                video_id = info['id']
                video_title = info.get('title', 'Vídeo sem título')
                
                # Procura primeiro por legendas em PT-BR
                pt_br_files = ['.pt-BR.vtt', '.pt_BR.vtt', '.pt-br.vtt']
                for suffix in pt_br_files:
                    file = os.path.join(self.download_path, f"{video_id}{suffix}")
                    if os.path.exists(file):
                        print(f"Encontradas legendas em PT-BR: {file}")
                        return file, video_title
                
                # Procura por legendas em PT
                pt_files = ['.pt.vtt', '.pt-PT.vtt']
                for suffix in pt_files:
                    file = os.path.join(self.download_path, f"{video_id}{suffix}")
                    if os.path.exists(file):
                        print(f"Encontradas legendas em PT: {file}")
                        return file, video_title
                
                # Fallback para EN
                en_file = os.path.join(self.download_path, f"{video_id}.en.vtt")
                if os.path.exists(en_file):
                    print("Usando legendas em inglês como fallback")
                    return en_file, video_title
                
                # Último recurso: qualquer arquivo .vtt disponível
                for file in os.listdir(self.download_path):
                    if file.startswith(video_id) and file.endswith('.vtt'):
                        print(f"Usando legendas disponíveis: {file}")
                        return os.path.join(self.download_path, file), video_title
                
                return None, None
                
        except Exception as e:
            print(f"Erro ao baixar legendas: {str(e)}")
            return None, None

    def clean_subtitles(self, subtitle_file: str) -> Optional[str]:
        """
        Limpa as legendas removendo timestamps, formatação e repetições
        Retorna o texto limpo
        """
        if not os.path.exists(subtitle_file):
            return None

        try:
            # Tenta diferentes codificações
            content = None
            for encoding in ['utf-8', 'latin1', 'cp1252']:
                try:
                    with open(subtitle_file, 'r', encoding=encoding) as f:
                        content = f.read()
                        break
                except UnicodeDecodeError:
                    continue
            
            if content is None:
                raise Exception("Não foi possível ler o arquivo com nenhuma codificação suportada")

            # Remove cabeçalho WEBVTT e metadados
            content = re.sub(r'WEBVTT.*\n', '', content)
            content = re.sub(r'Kind:.*\n', '', content)
            content = re.sub(r'Language:.*\n', '', content)
            
            # Remove timestamps e números de sequência
            content = re.sub(r'\d{2}:\d{2}:\d{2}[\.,]\d{3} --> .*\n', '', content)
            content = re.sub(r'^\d+$', '', content, flags=re.MULTILINE)
            
            # Remove tags HTML e formatação
            content = re.sub(r'<[^>]+>', '', content)
            content = re.sub(r'{\\an\d}', '', content)
            content = re.sub(r'\[.*?\]', '', content)
            
            # Processa linha por linha removendo duplicatas
            seen_lines = set()
            cleaned_lines = []
            
            for line in content.split('\n'):
                line = line.strip()
                if line and not line.startswith(('<', '{', '[')) and line not in seen_lines:
                    cleaned_lines.append(line)
                    seen_lines.add(line)

            # Remove arquivo temporário
            os.remove(subtitle_file)
            
            # Junta as linhas com espaço e remove espaços extras
            return ' '.join(cleaned_lines).strip()
            
        except Exception as e:
            print(f"Erro ao limpar legendas: {str(e)}")
            return None



==========================================
Estrutura de pastas:
==========================================
persistencia-memoria-html
    app.py
    atualiza-git.bat
    codigo_completo.txt
    data
        conversations
            conversation_1741174682053.json
            conversation_1741737581748.json
        index.json
    DevMenu.bat
    DOCUMENTACAO.md
    init_eventlet.py
    README.md
    requirements.txt
    start_server.bat
    static
        css
            base
                reset.css
                typography.css
                variables.css
            components
                buttons.css
                code-highlight.css
                command-menu.css
                forms.css
                messages.css
            layout
                container.css
                main-content.css
                sidebar.css
            styles.css
            themes
                dark-theme.css
                light-theme.css
            variables.css
        js
            chat
                chatActions.js
                chatStorage.js
                chatSync.js
                chatUI.js
                chatUtils.js
            chat.js
            commandMenu.js
            events.js
            init.js
            main.js
            messageRenderer.js
            modules
                commandHandler.js
                inputBar.js
            sidebar.js
            textarea.js
            theme.js
            utils.js
    templates
        index.html
    utils
        chat_history.py
        chat_storage.py
        text_processor.py
        __init__.py
    youtube_handler.py
