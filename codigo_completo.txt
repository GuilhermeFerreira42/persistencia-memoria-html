Conte√∫do de app.py:
import init_eventlet

from flask import Flask, render_template, request, jsonify, Response
import json
import os
from datetime import datetime
import requests
from utils.text_processor import split_text, clean_and_format_text
from youtube_handler import YoutubeHandler
from flask_socketio import SocketIO, emit, join_room, leave_room
from utils.chat_storage import (
    create_new_conversation,
    add_message_to_conversation,
    get_conversation_by_id,
    get_conversation_history,
    delete_conversation,
    rename_conversation
)

app = Flask(__name__, static_folder='static')
app.secret_key = 'sua_chave_secreta_aqui'
socketio = SocketIO(app, async_mode='eventlet', cors_allowed_origins="*")

API_URL = "http://localhost:11434/v1/chat/completions"
MODEL_NAME = "gemma2:2b"
youtube_handler = YoutubeHandler()

@app.route('/')
def home():
    conversations = get_conversation_history()
    return render_template('index.html', conversations=conversations)

@app.route('/get_conversation_history')
def conversation_history():
    try:
        conversations = get_conversation_history()
        return jsonify(conversations)
    except Exception as e:
        print(f"[ERRO] Falha ao obter hist√≥rico de conversas: {str(e)}")
        return jsonify({'error': str(e)}), 500

@app.route('/get_conversation/<conversation_id>')
def get_conversation(conversation_id):
    try:
        conversation = get_conversation_by_id(conversation_id)
        if conversation:
            return jsonify(conversation)
        print(f"[ERRO] Conversa n√£o encontrada: {conversation_id}")
        return jsonify({'error': 'Conversa n√£o encontrada'}), 404
    except Exception as e:
        print(f"[ERRO] Falha ao obter conversa: {str(e)}")
        return jsonify({'error': str(e)}), 500

@app.route('/get_conversation/<conversation_id>/<int:offset>/<int:limit>')
def get_conversation_batch(conversation_id, offset, limit):
    """Endpoint para carregar mensagens em lotes para lazy loading"""
    try:
        conversation = get_conversation_by_id(conversation_id)
        if conversation:
            messages = conversation['messages']
            # Garantir que offset e limit est√£o dentro dos limites
            offset = min(offset, len(messages))
            end_index = min(offset + limit, len(messages))
            batch = messages[offset:end_index]
            
            return jsonify({
                'messages': batch,
                'total': len(messages),
                'hasMore': end_index < len(messages)
            })
        
        print(f"[ERRO] Conversa n√£o encontrada para batch loading: {conversation_id}")
        return jsonify({'error': 'Conversa n√£o encontrada'}), 404
    except Exception as e:
        print(f"[ERRO] Falha ao obter lote de mensagens: {str(e)}")
        return jsonify({'error': str(e)}), 500

@app.route('/stream')
def stream():
    """Endpoint para streaming de respostas usando Server-Sent Events (SSE)"""
    conversation_id = request.args.get('conversation_id')
    message = request.args.get('message', '')
    
    if not conversation_id:
        return jsonify({'error': 'ID de conversa n√£o fornecido'}), 400
        
    print(f"[DEBUG] Iniciando streaming para conversa: {conversation_id}")
    
    def event_stream():
        for part in process_with_ai_stream(message, conversation_id):
            if part:
                yield f"data: {part}\n\n"
                
    response = Response(event_stream(), content_type="text/event-stream")
    response.headers['Cache-Control'] = 'no-cache'
    response.headers['X-Accel-Buffering'] = 'no'  # Para Nginx
    return response

@app.route('/send_message', methods=['POST'])
def send_message():
    data = request.json
    message = data.get('message', '')
    conversation_id = data.get('conversation_id')

    if not conversation_id:
        conversation_id = create_new_conversation()
        print(f"[DEBUG] Nova conversa criada com ID: {conversation_id}")
    else:
        print(f"[DEBUG] Usando conversa existente: {conversation_id}")

    # Salvar mensagem do usu√°rio
    add_message_to_conversation(conversation_id, message, "user")
    print(f"[DEBUG] Mensagem do usu√°rio salva na conversa: {conversation_id}")

    # Processar resposta da IA
    accumulated_response = []
    
    def generate_streamed_response():
        for part in process_with_ai_stream(message, conversation_id):
            if part:
                accumulated_response.append(part)
                # Emitir via WebSocket al√©m do SSE
                socketio.emit('message_chunk', {
                    'content': part, 
                    'conversation_id': conversation_id
                }, room=conversation_id)
                yield f"data: {json.dumps({'content': part, 'conversation_id': conversation_id})}\n\n"
        
        # Salvar a resposta completa da IA - APENAS UMA VEZ
        if accumulated_response:
            complete_response = ''.join(accumulated_response)
            print(f"[DEBUG] Salvando resposta √∫nica para {conversation_id}")
            add_message_to_conversation(conversation_id, complete_response, "assistant")
            # Notificar todas as abas conectadas que a conversa foi atualizada
            socketio.emit('conversation_updated', {
                'conversation_id': conversation_id
            })
            print(f"[DEBUG] Resposta completa da IA salva na conversa: {conversation_id}")

    response = Response(generate_streamed_response(), content_type="text/event-stream")
    response.headers['Cache-Control'] = 'no-cache'
    return response

@app.route('/save_message', methods=['POST'])
def save_message():
    try:
        data = request.json
        conversation_id = data.get('conversation_id')
        content = data.get('content')
        role = data.get('role')
        
        if not all([conversation_id, content, role]):
            return jsonify({'error': 'Dados incompletos'}), 400
        
        print(f"[DEBUG] Salvando mensagem para conversa: {conversation_id}, role: {role}")
        add_message_to_conversation(conversation_id, content, role)
        
        # Notificar clientes via WebSocket
        socketio.emit('conversation_updated', {
            'conversation_id': conversation_id
        })
        
        return jsonify({'status': 'success', 'conversation_id': conversation_id})
    except Exception as e:
        print(f"Erro ao salvar mensagem: {str(e)}")
        return jsonify({'error': str(e)}), 500

@app.route('/process_youtube', methods=['POST'])
def process_youtube():
    try:
        data = request.json
        video_url = data.get('video_url')
        conversation_id = data.get('conversation_id')
        comando = data.get('comando')  # Novo: pegar o comando original
        
        if not video_url:
            return jsonify({'error': 'URL n√£o fornecida'}), 400
            
        # Baixar legendas e obter t√≠tulo
        subtitle_file, video_title = youtube_handler.download_subtitles(video_url)
        if not subtitle_file:
            return jsonify({'error': 'N√£o foi poss√≠vel baixar as legendas deste v√≠deo'}), 404
            
        # Limpar legendas
        cleaned_text = youtube_handler.clean_subtitles(subtitle_file)
        if not cleaned_text:
            return jsonify({'error': 'Erro ao processar legendas'}), 500

        # Salvar comando do usu√°rio na conversa
        if conversation_id and comando:
            add_message_to_conversation(
                conversation_id,
                comando,
                "user"
            )
            print(f"[DEBUG] Comando do usu√°rio salvo na conversa: {conversation_id}")

        # Salvar transcri√ß√£o com t√≠tulo na conversa
        formatted_response = f"üìπ {video_title}\n\n{cleaned_text}"
        if conversation_id:
            add_message_to_conversation(
                conversation_id,
                formatted_response,
                "assistant"
            )
            print(f"[DEBUG] Resposta do YouTube salva na conversa: {conversation_id}")
            
            # Notificar via WebSocket
            socketio.emit('conversation_updated', {
                'conversation_id': conversation_id
            })
            
        return jsonify({
            'text': formatted_response,
            'title': video_title,
            'conversation_id': conversation_id
        })
        
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/rename_conversation/<conversation_id>', methods=['POST'])
def handle_rename_conversation(conversation_id):
    try:
        print(f"[BACKEND] Recebendo solicita√ß√£o para renomear conversa: {conversation_id}")
        
        # For√ßar decodifica√ß√£o do corpo JSON
        data = request.get_json(force=True, silent=True)
        if not data:
            data = {}
            print("[BACKEND] Request body vazio ou inv√°lido")
        
        new_title = data.get('title', '').strip()
        print(f"[BACKEND] Novo t√≠tulo: '{new_title}'")
        
        if not new_title:
            print("[BACKEND] T√≠tulo inv√°lido")
            return jsonify({'error': 'T√≠tulo inv√°lido'}), 400
            
        success = rename_conversation(conversation_id, new_title)
        if success:
            print(f"[BACKEND] Conversa renomeada com sucesso para: {new_title}")
            
            # Notificar via WebSocket
            socketio.emit('conversation_renamed', {
                'conversation_id': conversation_id,
                'new_title': new_title
            })
            
            return jsonify({'success': True, 'new_title': new_title, 'conversation_id': conversation_id})
        else:
            print("[BACKEND] Falha ao renomear conversa")
            return jsonify({'error': 'Falha ao renomear conversa'}), 500
    except Exception as e:
        print(f"[BACKEND] Erro ao renomear conversa: {str(e)}")
        return jsonify({'error': str(e)}), 500

@app.route('/delete_conversation/<conversation_id>', methods=['DELETE'])
def handle_delete_conversation(conversation_id):
    try:
        print(f"[BACKEND] Recebendo solicita√ß√£o para excluir conversa: {conversation_id}")
        
        success = delete_conversation(conversation_id)
        if success:
            print(f"[BACKEND] Conversa {conversation_id} exclu√≠da com sucesso")
            
            # Notificar via WebSocket
            socketio.emit('conversation_deleted', {
                'conversation_id': conversation_id
            })
            
            return jsonify({'success': True, 'conversation_id': conversation_id})
        else:
            print(f"[BACKEND] Falha ao excluir conversa {conversation_id}")
            return jsonify({'error': 'Falha ao excluir conversa'}), 500
    except Exception as e:
        print(f"[BACKEND] Erro ao excluir conversa: {str(e)}")
        return jsonify({'error': str(e)}), 500

# ---- WebSocket event handlers ----

@socketio.on('connect')
def handle_connect():
    print(f"[SOCKET] Cliente conectado: {request.sid}")

@socketio.on('disconnect')
def handle_disconnect():
    print(f"[SOCKET] Cliente desconectado: {request.sid}")

@socketio.on('join_conversation')
def handle_join_conversation(data):
    conversation_id = data.get('conversation_id')
    if conversation_id:
        join_room(conversation_id)
        print(f"[SOCKET] Cliente {request.sid} entrou na sala: {conversation_id}")

@socketio.on('leave_conversation')
def handle_leave_conversation(data):
    conversation_id = data.get('conversation_id')
    if conversation_id:
        leave_room(conversation_id)
        print(f"[SOCKET] Cliente {request.sid} saiu da sala: {conversation_id}")

def process_with_ai(text, conversation_id=None):
    try:
        # Incluir o ID da conversa no contexto para rastreamento
        context_header = f"[Conversa: {conversation_id}] " if conversation_id else ""
        print(f"{context_header}Processando com IA: {text[:50]}...")
        
        payload = {
            "model": MODEL_NAME,
            "messages": [
                {"role": "system", "content": "Voc√™ √© um assistente √∫til. Formate suas respostas em Markdown. Use acentos graves triplos (```) APENAS para blocos de c√≥digo, especificando a linguagem (ex.: ```python). NUNCA coloque texto explicativo dentro de blocos de c√≥digo."},
                {"role": "user", "content": text}
            ],
            "stream": False
        }
        headers = {"Content-Type": "application/json"}
        response = requests.post(API_URL, json=payload, headers=headers)
        response.raise_for_status()

        response_data = response.json()
        if 'choices' in response_data and len(response_data['choices']) > 0:
            return response_data['choices'][0]['message']['content']
        return "Erro: Nenhuma resposta v√°lida recebida da IA."
    except requests.exceptions.RequestException as e:
        print(f"[Debug] Erro na requisi√ß√£o HTTP: {str(e)}")
        return "Ocorreu um erro ao se conectar com a IA."
    except Exception as e:
        print(f"[Debug] Erro inesperado: {str(e)}")
        return "Ocorreu um erro inesperado ao processar sua mensagem."

def process_with_ai_stream(text, conversation_id=None):
    try:
        # Incluir o ID da conversa no contexto para rastreamento
        context_header = f"[Conversa: {conversation_id}] " if conversation_id else ""
        print(f"{context_header}Iniciando streaming para: {text[:50]}...")
        
        # Op√ß√£o para incluir hist√≥rico de mensagens da conversa espec√≠fica
        conversation = None
        if conversation_id:
            conversation = get_conversation_by_id(conversation_id)
        
        # Mensagem do sistema √© sempre necess√°ria
        messages = [{"role": "system", "content": "Voc√™ √© um assistente √∫til. Formate suas respostas em Markdown. Use acentos graves triplos (```) APENAS para blocos de c√≥digo, especificando a linguagem (ex.: ```python). NUNCA coloque texto explicativo dentro de blocos de c√≥digo. Exemplo:\nTexto normal aqui.\n```python\nprint('C√≥digo aqui')\n```\nMais texto normal aqui."}]
        
        # Adicionar mensagem do usu√°rio
        messages.append({"role": "user", "content": text})
        
        payload = {
            "model": MODEL_NAME,
            "messages": messages,
            "stream": True
        }
        headers = {"Content-Type": "application/json"}
        response = requests.post(API_URL, json=payload, headers=headers, stream=True)
        response.raise_for_status()

        for line in response.iter_lines(decode_unicode=True):
            if line.strip() and line.startswith("data: "):
                line = line[6:].strip()
                try:
                    response_data = json.loads(line)
                    if 'choices' in response_data and len(response_data['choices']) > 0:
                        delta = response_data['choices'][0]['delta']
                        if "content" in delta:
                            content = delta["content"].encode('latin1').decode('utf-8', errors='ignore')
                            print(f"{context_header}Chunk: {len(content)} caracteres")
                            yield content
                except json.JSONDecodeError:
                    print(f"[Debug] Erro ao decodificar JSON: {line}")
    except requests.exceptions.RequestException as e:
        print(f"[Debug] Erro na requisi√ß√£o HTTP: {str(e)}")
    except Exception as e:
        print(f"[Debug] Erro inesperado: {str(e)}")

if __name__ == '__main__':
    print("Iniciando servidor com Eventlet em modo de desenvolvimento...")
    socketio.run(app, debug=True, host='0.0.0.0', port=5000, use_reloader=False)


Conte√∫do de atualiza-git.bat:
@echo off

:: Altere para o diretorio onde o script esta localizado
cd /d %~dp0

:menu
cls
echo Diretorio atual: %cd%
echo =====================================
echo     GIT AUTOMATION MENU
echo =====================================
echo 1. Verificar status do repositorio
echo 2. Adicionar todas as alteracoes
echo 3. Fazer commit
echo 4. Fazer push para o GitHub
echo 5. Fazer pull do repositorio
echo 6. Mostrar log de commits
echo 7. Outras opcoes
echo 8. Sair
echo =====================================
set /p escolha="Escolha uma opcao: "

if %escolha%==1 goto status
if %escolha%==2 goto add
if %escolha%==3 goto commit
if %escolha%==4 goto push
if %escolha%==5 goto pull
if %escolha%==6 goto log
if %escolha%==7 goto outras_opcoes
if %escolha%==8 goto fim
goto menu

:status
echo Diretorio atual: %cd%
echo Verificando o status do repositorio...
git status
pause
goto menu

:add
echo Diretorio atual: %cd%
echo Adicionando todas as alteracoes...
git add .
pause
goto menu

:commit
set /p comentario="Digite o comentario do commit: "
echo Diretorio atual: %cd%
git commit -m "%comentario%"
pause
goto menu

:push
echo Diretorio atual: %cd%
echo Fazendo push para o GitHub...
git push
pause
goto menu

:pull
echo Diretorio atual: %cd%
echo Fazendo pull do repositorio...
git pull
pause
goto menu

:log
echo Diretorio atual: %cd%
echo Mostrando log de commits...
git log
pause
goto menu

:outras_opcoes
cls
echo Outras opcoes
echo =====================================
echo 1. Restaurar arquivos deletados
echo 2. Sincronizar com repositorio
echo 3. Fazer fetch do repositorio
echo 4. Fazer merge de branches
echo 5. Inicializar um novo repositorio (git init)
echo 6. Desfazer alteracoes (git reset)
echo 7. Listar branches (git branch)
echo 8. Voltar ao menu principal
echo =====================================
set /p escolha_outras="Escolha uma opcao: "

if %escolha_outras%==1 goto restaurar
if %escolha_outras%==2 goto sincronizar
if %escolha_outras%==3 goto fetch
if %escolha_outras%==4 goto merge
if %escolha_outras%==5 goto init
if %escolha_outras%==6 goto reset
if %escolha_outras%==7 goto branch
if %escolha_outras%==8 goto menu
goto outras_opcoes

:restaurar
echo Restaurando arquivos deletados...
git checkout -- .
pause
goto outras_opcoes

:sincronizar
echo Sincronizando com repositorio...
git fetch origin
pause
goto outras_opcoes

:fetch
echo Fazendo fetch do repositorio...
git fetch
pause
goto outras_opcoes

:merge
echo Fazendo merge de branches...
git merge
pause
goto outras_opcoes

:init
echo Inicializando um novo repositorio...
git init
pause
goto outras_opcoes

:reset
echo Desfazendo alteracoes...
git reset
pause
goto outras_opcoes

:branch
echo Listando branches...
git branch
pause
goto outras_opcoes

:fim
echo Saindo...
pause


Conte√∫do de codigo_completo.txt:
Conte√∫do de app.py:
import init_eventlet

from flask import Flask, render_template, request, jsonify, Response
import json
import os
from datetime import datetime
import requests
from utils.text_processor import split_text, clean_and_format_text
from youtube_handler import YoutubeHandler
from flask_socketio import SocketIO, emit, join_room, leave_room
from utils.chat_storage import (
    create_new_conversation,
    add_message_to_conversation,
    get_conversation_by_id,
    get_conversation_history,
    delete_conversation,
    rename_conversation
)

app = Flask(__name__, static_folder='static')
app.secret_key = 'sua_chave_secreta_aqui'
socketio = SocketIO(app, async_mode='eventlet', cors_allowed_origins="*")

API_URL = "http://localhost:11434/v1/chat/completions"
MODEL_NAME = "gemma2:2b"
youtube_handler = YoutubeHandler()

@app.route('/')
def home():
    conversations = get_conversation_history()
    return render_template('index.html', conversations=conversations)

@app.route('/get_conversation_history')
def conversation_history():
    try:
        conversations = get_conversation_history()
        return jsonify(conversations)
    except Exception as e:
        print(f"[ERRO] Falha ao obter hist√≥rico de conversas: {str(e)}")
        return jsonify({'error': str(e)}), 500

@app.route('/get_conversation/<conversation_id>')
def get_conversation(conversation_id):
    try:
        conversation = get_conversation_by_id(conversation_id)
        if conversation:
            return jsonify(conversation)
        print(f"[ERRO] Conversa n√£o encontrada: {conversation_id}")
        return jsonify({'error': 'Conversa n√£o encontrada'}), 404
    except Exception as e:
        print(f"[ERRO] Falha ao obter conversa: {str(e)}")
        return jsonify({'error': str(e)}), 500

@app.route('/get_conversation/<conversation_id>/<int:offset>/<int:limit>')
def get_conversation_batch(conversation_id, offset, limit):
    """Endpoint para carregar mensagens em lotes para lazy loading"""
    try:
        conversation = get_conversation_by_id(conversation_id)
        if conversation:
            messages = conversation['messages']
            # Garantir que offset e limit est√£o dentro dos limites
            offset = min(offset, len(messages))
            end_index = min(offset + limit, len(messages))
            batch = messages[offset:end_index]
            
            return jsonify({
                'messages': batch,
                'total': len(messages),
                'hasMore': end_index < len(messages)
            })
        
        print(f"[ERRO] Conversa n√£o encontrada para batch loading: {conversation_id}")
        return jsonify({'error': 'Conversa n√£o encontrada'}), 404
    except Exception as e:
        print(f"[ERRO] Falha ao obter lote de mensagens: {str(e)}")
        return jsonify({'error': str(e)}), 500

@app.route('/stream')
def stream():
    """Endpoint para streaming de respostas usando Server-Sent Events (SSE)"""
    conversation_id = request.args.get('conversation_id')
    message = request.args.get('message', '')
    
    if not conversation_id:
        return jsonify({'error': 'ID de conversa n√£o fornecido'}), 400
        
    print(f"[DEBUG] Iniciando streaming para conversa: {conversation_id}")
    
    def event_stream():
        for part in process_with_ai_stream(message, conversation_id):
            if part:
                yield f"data: {part}\n\n"
                
    response = Response(event_stream(), content_type="text/event-stream")
    response.headers['Cache-Control'] = 'no-cache'
    response.headers['X-Accel-Buffering'] = 'no'  # Para Nginx
    return response

@app.route('/send_message', methods=['POST'])
def send_message():
    data = request.json
    message = data.get('message', '')
    conversation_id = data.get('conversation_id')

    if not conversation_id:
        conversation_id = create_new_conversation()
        print(f"[DEBUG] Nova conversa criada com ID: {conversation_id}")
    else:
        print(f"[DEBUG] Usando conversa existente: {conversation_id}")

    # Salvar mensagem do usu√°rio
    add_message_to_conversation(conversation_id, message, "user")
    print(f"[DEBUG] Mensagem do usu√°rio salva na conversa: {conversation_id}")

    # Processar resposta da IA
    accumulated_response = []
    
    def generate_streamed_response():
        for part in process_with_ai_stream(message, conversation_id):
            if part:
                accumulated_response.append(part)
                # Emitir via WebSocket al√©m do SSE
                socketio.emit('message_chunk', {
                    'content': part, 
                    'conversation_id': conversation_id
                }, room=conversation_id)
                yield f"data: {json.dumps({'content': part, 'conversation_id': conversation_id})}\n\n"
        
        # Salvar a resposta completa da IA - APENAS UMA VEZ
        if accumulated_response:
            complete_response = ''.join(accumulated_response)
            print(f"[DEBUG] Salvando resposta √∫nica para {conversation_id}")
            add_message_to_conversation(conversation_id, complete_response, "assistant")
            # Notificar todas as abas conectadas que a conversa foi atualizada
            socketio.emit('conversation_updated', {
                'conversation_id': conversation_id
            })
            print(f"[DEBUG] Resposta completa da IA salva na conversa: {conversation_id}")

    response = Response(generate_streamed_response(), content_type="text/event-stream")
    response.headers['Cache-Control'] = 'no-cache'
    return response

@app.route('/save_message', methods=['POST'])
def save_message():
    try:
        data = request.json
        conversation_id = data.get('conversation_id')
        content = data.get('content')
        role = data.get('role')
        
        if not all([conversation_id, content, role]):
            return jsonify({'error': 'Dados incompletos'}), 400
        
        print(f"[DEBUG] Salvando mensagem para conversa: {conversation_id}, role: {role}")
        add_message_to_conversation(conversation_id, content, role)
        
        # Notificar clientes via WebSocket
        socketio.emit('conversation_updated', {
            'conversation_id': conversation_id
        })
        
        return jsonify({'status': 'success', 'conversation_id': conversation_id})
    except Exception as e:
        print(f"Erro ao salvar mensagem: {str(e)}")
        return jsonify({'error': str(e)}), 500

@app.route('/process_youtube', methods=['POST'])
def process_youtube():
    try:
        data = request.json
        video_url = data.get('video_url')
        conversation_id = data.get('conversation_id')
        comando = data.get('comando')  # Novo: pegar o comando original
        
        if not video_url:
            return jsonify({'error': 'URL n√£o fornecida'}), 400
            
        # Baixar legendas e obter t√≠tulo
        subtitle_file, video_title = youtube_handler.download_subtitles(video_url)
        if not subtitle_file:
            return jsonify({'error': 'N√£o foi poss√≠vel baixar as legendas deste v√≠deo'}), 404
            
        # Limpar legendas
        cleaned_text = youtube_handler.clean_subtitles(subtitle_file)
        if not cleaned_text:
            return jsonify({'error': 'Erro ao processar legendas'}), 500

        # Salvar comando do usu√°rio na conversa
        if conversation_id and comando:
            add_message_to_conversation(
                conversation_id,
                comando,
                "user"
            )
            print(f"[DEBUG] Comando do usu√°rio salvo na conversa: {conversation_id}")

        # Salvar transcri√ß√£o com t√≠tulo na conversa
        formatted_response = f"üìπ {video_title}\n\n{cleaned_text}"
        if conversation_id:
            add_message_to_conversation(
                conversation_id,
                formatted_response,
                "assistant"
            )
            print(f"[DEBUG] Resposta do YouTube salva na conversa: {conversation_id}")
            
            # Notificar via WebSocket
            socketio.emit('conversation_updated', {
                'conversation_id': conversation_id
            })
            
        return jsonify({
            'text': formatted_response,
            'title': video_title,
            'conversation_id': conversation_id
        })
        
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/rename_conversation/<conversation_id>', methods=['POST'])
def handle_rename_conversation(conversation_id):
    try:
        print(f"[BACKEND] Recebendo solicita√ß√£o para renomear conversa: {conversation_id}")
        
        # For√ßar decodifica√ß√£o do corpo JSON
        data = request.get_json(force=True, silent=True)
        if not data:
            data = {}
            print("[BACKEND] Request body vazio ou inv√°lido")
        
        new_title = data.get('title', '').strip()
        print(f"[BACKEND] Novo t√≠tulo: '{new_title}'")
        
        if not new_title:
            print("[BACKEND] T√≠tulo inv√°lido")
            return jsonify({'error': 'T√≠tulo inv√°lido'}), 400
            
        success = rename_conversation(conversation_id, new_title)
        if success:
            print(f"[BACKEND] Conversa renomeada com sucesso para: {new_title}")
            
            # Notificar via WebSocket
            socketio.emit('conversation_renamed', {
                'conversation_id': conversation_id,
                'new_title': new_title
            })
            
            return jsonify({'success': True, 'new_title': new_title, 'conversation_id': conversation_id})
        else:
            print("[BACKEND] Falha ao renomear conversa")
            return jsonify({'error': 'Falha ao renomear conversa'}), 500
    except Exception as e:
        print(f"[BACKEND] Erro ao renomear conversa: {str(e)}")
        return jsonify({'error': str(e)}), 500

@app.route('/delete_conversation/<conversation_id>', methods=['DELETE'])
def handle_delete_conversation(conversation_id):
    try:
        print(f"[BACKEND] Recebendo solicita√ß√£o para excluir conversa: {conversation_id}")
        
        success = delete_conversation(conversation_id)
        if success:
            print(f"[BACKEND] Conversa {conversation_id} exclu√≠da com sucesso")
            
            # Notificar via WebSocket
            socketio.emit('conversation_deleted', {
                'conversation_id': conversation_id
            })
            
            return jsonify({'success': True, 'conversation_id': conversation_id})
        else:
            print(f"[BACKEND] Falha ao excluir conversa {conversation_id}")
            return jsonify({'error': 'Falha ao excluir conversa'}), 500
    except Exception as e:
        print(f"[BACKEND] Erro ao excluir conversa: {str(e)}")
        return jsonify({'error': str(e)}), 500

# ---- WebSocket event handlers ----

@socketio.on('connect')
def handle_connect():
    print(f"[SOCKET] Cliente conectado: {request.sid}")

@socketio.on('disconnect')
def handle_disconnect():
    print(f"[SOCKET] Cliente desconectado: {request.sid}")

@socketio.on('join_conversation')
def handle_join_conversation(data):
    conversation_id = data.get('conversation_id')
    if conversation_id:
        join_room(conversation_id)
        print(f"[SOCKET] Cliente {request.sid} entrou na sala: {conversation_id}")

@socketio.on('leave_conversation')
def handle_leave_conversation(data):
    conversation_id = data.get('conversation_id')
    if conversation_id:
        leave_room(conversation_id)
        print(f"[SOCKET] Cliente {request.sid} saiu da sala: {conversation_id}")

def process_with_ai(text, conversation_id=None):
    try:
        # Incluir o ID da conversa no contexto para rastreamento
        context_header = f"[Conversa: {conversation_id}] " if conversation_id else ""
        print(f"{context_header}Processando com IA: {text[:50]}...")
        
        payload = {
            "model": MODEL_NAME,
            "messages": [
                {"role": "system", "content": "Voc√™ √© um assistente √∫til. Formate suas respostas em Markdown. Use acentos graves triplos (```) APENAS para blocos de c√≥digo, especificando a linguagem (ex.: ```python). NUNCA coloque texto explicativo dentro de blocos de c√≥digo."},
                {"role": "user", "content": text}
            ],
            "stream": False
        }
        headers = {"Content-Type": "application/json"}
        response = requests.post(API_URL, json=payload, headers=headers)
        response.raise_for_status()

        response_data = response.json()
        if 'choices' in response_data and len(response_data['choices']) > 0:
            return response_data['choices'][0]['message']['content']
        return "Erro: Nenhuma resposta v√°lida recebida da IA."
    except requests.exceptions.RequestException as e:
        print(f"[Debug] Erro na requisi√ß√£o HTTP: {str(e)}")
        return "Ocorreu um erro ao se conectar com a IA."
    except Exception as e:
        print(f"[Debug] Erro inesperado: {str(e)}")
        return "Ocorreu um erro inesperado ao processar sua mensagem."

def process_with_ai_stream(text, conversation_id=None):
    try:
        # Incluir o ID da conversa no contexto para rastreamento
        context_header = f"[Conversa: {conversation_id}] " if conversation_id else ""
        print(f"{context_header}Iniciando streaming para: {text[:50]}...")
        
        # Op√ß√£o para incluir hist√≥rico de mensagens da conversa espec√≠fica
        conversation = None
        if conversation_id:
            conversation = get_conversation_by_id(conversation_id)
        
        # Mensagem do sistema √© sempre necess√°ria
        messages = [{"role": "system", "content": "Voc√™ √© um assistente √∫til. Formate suas respostas em Markdown. Use acentos graves triplos (```) APENAS para blocos de c√≥digo, especificando a linguagem (ex.: ```python). NUNCA coloque texto explicativo dentro de blocos de c√≥digo. Exemplo:\nTexto normal aqui.\n```python\nprint('C√≥digo aqui')\n```\nMais texto normal aqui."}]
        
        # Adicionar mensagem do usu√°rio
        messages.append({"role": "user", "content": text})
        
        payload = {
            "model": MODEL_NAME,
            "messages": messages,
            "stream": True
        }
        headers = {"Content-Type": "application/json"}
        response = requests.post(API_URL, json=payload, headers=headers, stream=True)
        response.raise_for_status()

        for line in response.iter_lines(decode_unicode=True):
            if line.strip() and line.startswith("data: "):
                line = line[6:].strip()
                try:
                    response_data = json.loads(line)
                    if 'choices' in response_data and len(response_data['choices']) > 0:
                        delta = response_data['choices'][0]['delta']
                        if "content" in delta:
                            content = delta["content"].encode('latin1').decode('utf-8', errors='ignore')
                            print(f"{context_header}Chunk: {len(content)} caracteres")
                            yield content
                except json.JSONDecodeError:
                    print(f"[Debug] Erro ao decodificar JSON: {line}")
    except requests.exceptions.RequestException as e:
        print(f"[Debug] Erro na requisi√ß√£o HTTP: {str(e)}")
    except Exception as e:
        print(f"[Debug] Erro inesperado: {str(e)}")

if __name__ == '__main__':
    print("Iniciando servidor com Eventlet em modo de desenvolvimento...")
    socketio.run(app, debug=True, host='0.0.0.0', port=5000, use_reloader=False)




Conte√∫do de conversation_1741174682053.json:
{
  "id": "1741174682053",
  "title": "fa√ßa uma calculadora em py",
  "timestamp": "2025-03-05T08:40:19.825438",
  "messages": [
    {
      "role": "assistant",
      "content": "## Bolo Simples com Canela\n\n**Ingredientes:**\n\n| Item             | Quantidade |\n| --------------- | --------- |\n| Farinha        | 2 x√≠caras (250g)  |\n| a√ß√∫car        | 1 x√≠cara (200g)   |\n| Leite        | 1 x√≠cara (240ml)   |\n| Ovos          | 3                      |\n| Amido de milho | 1 colher de sopa (15g) |\n| Canela em p√≥   | 1 colher de ch√° (2g)  | \n\n**Preparo:**\n\n1. **Pr√©-aque√ßa o forno:**  A 180¬∞C. Unte uma forma redonda com furo no centro e polvilhe farinha para evitar grudar.\n2. **Misture os ingredientes secos:** Em uma tigela grande, misture a farinha, o a√ß√∫car e a canela em p√≥.\n3. **Junte os ingredientes √∫midos:** √Ä batedeira ou fouet, adicione o leite aos ovos batendo at√© obter um creme homog√™neo. \n4. **Adicione os ingredientes molhados:** Despeje a mistura l√≠quida na tigela com os ingredientes secos e misture delicadamente at√© formar uma massa lisa e uniforme. N√£o bata muito.\n5. **Asse o bolo:**  Leve ao forno pr√©-aquecido por  30 minutos ou at√© que um palito inserido no centro saia limpo. \n6. **Deixe esfriar:** Retire o bolo do forno e deixe esfriar na forma antes de desenformar. \n\n**Dica:** Experimente adicionar uma calda de chocolate √† sua base para aumentar a textura! \n\n\n\n",
      "timestamp": "2025-03-05T08:38:56.103283"
    },
    {
      "role": "user",
      "content": "fa√ßa uma calculadora em py",
      "timestamp": "2025-03-05T08:39:11.531380"
    },
    {
      "role": "assistant",
      "content": "```python \ndef soma(x, y):\n  \"\"\"Soma dois n√∫meros.\"\"\"\n  return x + y\n\ndef subtracao(x, y):\n  \"\"\"Subtrai dois n√∫meros.\"\"\"\n  return x - y\n\ndef multiplicacao(x, y):\n  \"\"\"Multiplica dois n√∫meros.\"\"\"\n  return x * y\n\ndef divisao(x, y):\n  \"\"\"Divide dois n√∫meros.\"\"\"\n  if y == 0:\n    return \"Erro! Divis√£o por zero.\"\n  else:\n    return x / y\n\nwhile True:\n  print(\"Selecione a opera√ß√£o:\")\n  print(\"1. Soma\")\n  print(\"2. Subtra√ß√£o\")\n  print(\"3. Multiplica√ß√£o\")\n  print(\"4. Divis√£o\")\n  print(\"5. Sair\") \n\n  escolha = input(\"\\nDigite a op√ß√£o desejada (1/2/3/4/5): \")\n\n  if escolha in ('1', '2', '3', '4'):\n    try:\n      num1 = float(input(\"\\nDigite o primeiro n√∫mero: \"))\n      num2 = float(input(\"Digite o segundo n√∫mero: \"))\n    except ValueError:\n      print(\"Entrada inv√°lida. Digite um valor num√©rico.\")\n      continue\n\n  op = escolha\n    \n  if op == '1': \n    print(f\"{num1} + {num2} = {soma(num1, num2)}\")\n\n  elif op == '2':\n    print(f\"{num1} - {num2} = {subtracao(num1, num2)}\")\n\n  elif op == '3': \n    print(f\"{num1} * {num2} = {multiplicacao(num1, num2)}\")\n\n  elif op == '4': \n    print(f\"{num1} / {num2} = {divisao(num1, num2)}\")\n\n  elif escolha == '5': \n    break \n\n  else:\n    print(\"Op√ß√£o inv√°lida. Por favor, digite de 1 a 5.\")  \n```\n\n\nEste c√≥digo √© um programa simples de calculadora que implementa quatro opera√ß√µes b√°sicas: soma, subtra√ß√£o, multiplica√ß√£o e divis√£o. Ele aceita dois n√∫meros como entrada do usu√°rio e realiza as opera√ß√µes correspondentes. \n\nPara executar o c√≥digo, salve-o em um arquivo `.py` (por exemplo, `calculadora.py`) e, em seguida, utilize o terminal para execut√°-lo com o comando `python calculadora.py`.",
      "timestamp": "2025-03-05T08:40:19.825438"
    }
  ]
}

Conte√∫do de conversation_1741737581748.json:
{
  "id": "1741737581748",
  "title": "imprima oi em py",
  "timestamp": "2025-03-11T21:22:05.823593",
  "messages": [
    {
      "role": "user",
      "content": "imprima oi em py",
      "timestamp": "2025-03-11T20:59:41.756681"
    },
    {
      "role": "assistant",
      "content": "```python\nprint(\"oi\") \n``` \n",
      "timestamp": "2025-03-11T20:59:55.336260"
    },
    {
      "role": "user",
      "content": "oi",
      "timestamp": "2025-03-11T21:21:50.362296"
    },
    {
      "role": "assistant",
      "content": "Ol√°! üëã  Como posso te ajudar hoje? üòä \n",
      "timestamp": "2025-03-11T21:22:05.823593"
    }
  ]
}

Conte√∫do de index.json:
[
  {
    "id": "1741737581748",
    "title": "imprima oi em py",
    "timestamp": "2025-03-11T21:22:05.823593",
    "filename": "conversation_1741737581748.json"
  },
  {
    "id": "1741174682053",
    "title": "fa√ßa uma calculadora em py",
    "timestamp": "2025-03-05T08:40:19.825438",
    "filename": "conversation_1741174682053.json"
  }
]

Conte√∫do de DevMenu.bat:
@echo off
setlocal enabledelayedexpansion

goto menu_principal

:menu_principal
cls
echo Diretorio atual: %cd%
echo =====================================
echo MENU PRINCIPAL
echo =====================================
echo 1. Abrir no VS Code
echo 2. Atualizar Git
echo 3. Executar Script Python
echo 4. Sair
echo =====================================
set /p escolha="Escolha uma opcao: "

if "%escolha%"=="1" goto abrir_vscode
if "%escolha%"=="2" goto atualizar_git
if "%escolha%"=="3" goto executar_python
if "%escolha%"=="4" goto fim
goto menu_principal

:abrir_vscode
cls
echo Abrindo no VS Code...
start "" cmd /c "code . && exit /b 0"
echo.
echo VS Code aberto. Pressione qualquer tecla para voltar ao menu principal...
pause >nul
goto menu_principal

:atualizar_git
cd /d %~dp0
cls
echo Diretorio atual: %cd%
echo =====================================
echo GIT AUTOMATION MENU
echo =====================================
echo 1. Verificar status do repositorio
echo 2. Adicionar todas as alteracoes
echo 3. Fazer commit
echo 4. Fazer push para o GitHub
echo 5. Fazer pull do repositorio
echo 6. Mostrar log de commits
echo 7. Outras opcoes
echo 8. Voltar ao menu principal
echo =====================================
set /p escolha="Escolha uma opcao: "

if "%escolha%"=="1" goto status
if "%escolha%"=="2" goto add
if "%escolha%"=="3" goto commit
if "%escolha%"=="4" goto push
if "%escolha%"=="5" goto pull
if "%escolha%"=="6" goto log
if "%escolha%"=="7" goto outras_opcoes
if "%escolha%"=="8" goto menu_principal
goto atualizar_git

:status
echo Verificando o status do repositorio...
git status
pause
goto atualizar_git

:add
echo Adicionando todas as alteracoes...
git add .
pause
goto atualizar_git

:commit
set /p comentario="Digite o comentario do commit: "
git commit -m "%comentario%"
pause
goto atualizar_git

:push
echo Fazendo push para o GitHub...
git push
pause
goto atualizar_git

:pull
echo Fazendo pull do repositorio...
git pull
pause
goto atualizar_git

:log
echo Mostrando log de commits...
git log
pause
goto atualizar_git

:outras_opcoes
cls
echo Outras opcoes
echo =====================================
echo 1. Restaurar arquivos deletados
echo 2. Sincronizar com repositorio
echo 3. Fazer fetch do repositorio
echo 4. Fazer merge de branches
echo 5. Inicializar um novo repositorio (git init)
echo 6. Desfazer alteracoes (git reset)
echo 7. Listar branches (git branch)
echo 8. Voltar ao menu Git
echo =====================================
set /p escolha_outras="Escolha uma opcao: "

if "%escolha_outras%"=="1" goto restaurar
if "%escolha_outras%"=="2" goto sincronizar
if "%escolha_outras%"=="3" goto fetch
if "%escolha_outras%"=="4" goto merge
if "%escolha_outras%"=="5" goto init
if "%escolha_outras%"=="6" goto reset
if "%escolha_outras%"=="7" goto branch
if "%escolha_outras%"=="8" goto atualizar_git
goto outras_opcoes

:restaurar
echo Restaurando arquivos deletados...
git checkout -- .
pause
goto outras_opcoes

:sincronizar
echo Sincronizando com repositorio...
git fetch origin
pause
goto outras_opcoes

:fetch
echo Fazendo fetch do repositorio...
git fetch
pause
goto outras_opcoes

:merge
echo Fazendo merge de branches...
git merge
pause
goto outras_opcoes

:init
echo Inicializando um novo repositorio...
git init
pause
goto outras_opcoes

:reset
echo Desfazendo alteracoes...
git reset
pause
goto outras_opcoes

:branch
echo Listando branches...
git branch
pause
goto outras_opcoes

:executar_python
setlocal enabledelayedexpansion
for /f "delims=" %%P in ('where python 2^>nul') do (
    set "python_path=%%P"
    goto :list_files
)

if not defined python_path (
    echo Python nao encontrado no sistema!
    pause
    goto menu_principal
)

:list_files
cd /d %~dp0
set "counter=0"
echo.
echo Arquivos Python encontrados:
for %%i in (*.py) do (
    set /a counter+=1
    set "file_!counter!=%%i"
    echo [!counter!] %%i
)

if %counter% equ 0 (
    echo Nenhum arquivo Python encontrado neste diretorio.
    pause
    goto menu_principal
)

echo.
set /p "file_num=Digite o numero do arquivo que deseja executar: "
set /a file_num=%file_num%
for /l %%n in (1,1,%counter%) do (
    if %%n equ %file_num% (
        echo Executando: !file_%%n!
        "%python_path%" "!file_%%n!"
        echo.
        echo Pressione qualquer tecla para voltar ao menu principal...
        pause >nul
    )
)
endlocal
goto menu_principal

:fim
echo Saindo...
pause
exit

Conte√∫do de DOCUMENTACAO.md:

# Documenta√ß√£o do Projeto - Sistema de Chat com IA

## 1. Vis√£o Geral do Projeto

### Descri√ß√£o Geral
O projeto √© um sistema de chat interativo que utiliza intelig√™ncia artificial para gerar respostas contextualizadas. √â baseado em uma arquitetura cliente-servidor usando Flask como backend e uma interface web responsiva.

### Objetivo e Funcionalidades Principais
- Fornecer uma interface de chat intuitiva para intera√ß√£o com IA
- Gerenciar hist√≥rico de conversas
- Permitir cria√ß√£o de novas conversas
- Suportar temas claro/escuro
- Salvar conversas em arquivos JSON para persist√™ncia

### Tecnologias Utilizadas
- **Backend**: Python/Flask
- **Frontend**: HTML, CSS, JavaScript
- **Armazenamento**: Sistema de arquivos (JSON)
- **IA**: Integra√ß√£o com modelo de linguagem

## 2. √Årvore de Diret√≥rios

```
Projeto/
‚îú‚îÄ‚îÄ app.py                     # Aplica√ß√£o principal Flask
‚îú‚îÄ‚îÄ static/
‚îÇ   ‚îú‚îÄ‚îÄ css/                  # Estilos da aplica√ß√£o
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ styles.css       # Estilos principais
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ base/           # Estilos base
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ components/     # Estilos de componentes
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ layout/        # Estilos de layout
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ themes/        # Temas claro/escuro
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ js/                   # Scripts JavaScript
‚îÇ       ‚îú‚îÄ‚îÄ main.js          # Script principal
‚îÇ       ‚îú‚îÄ‚îÄ chat.js         # L√≥gica do chat
‚îÇ       ‚îú‚îÄ‚îÄ sidebar.js      # Controle da barra lateral
‚îÇ       ‚îú‚îÄ‚îÄ theme.js        # Controle de tema
‚îÇ       ‚îú‚îÄ‚îÄ events.js       # Gerenciamento de eventos
‚îÇ       ‚îú‚îÄ‚îÄ init.js         # Inicializa√ß√£o
‚îÇ       ‚îî‚îÄ‚îÄ utils.js        # Fun√ß√µes utilit√°rias
‚îÇ
‚îú‚îÄ‚îÄ templates/
‚îÇ   ‚îî‚îÄ‚îÄ index.html            # Template principal
‚îÇ
‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îú‚îÄ‚îÄ chat_storage.py      # Gerenciamento de armazenamento
‚îÇ   ‚îú‚îÄ‚îÄ chat_history.py      # Manipula√ß√£o do hist√≥rico
‚îÇ   ‚îî‚îÄ‚îÄ text_processor.py    # Processamento de texto
‚îÇ
‚îî‚îÄ‚îÄ data/                     # Diret√≥rio de dados
    ‚îî‚îÄ‚îÄ conversations/        # Armazenamento de conversas

```

## 3. Descri√ß√£o Detalhada das Fun√ß√µes

### Backend (app.py)

#### Rotas Principais:
- `@app.route('/')`: Renderiza a p√°gina inicial
- `@app.route('/send_message')`: Processa mensagens e retorna respostas da IA
- `@app.route('/get_conversation_history')`: Retorna hist√≥rico de conversas
- `@app.route('/get_conversation/<conversation_id>')`: Obt√©m conversa espec√≠fica

#### Fun√ß√µes de Processamento:
- `process_with_ai(text)`: Processa texto com IA
- `process_with_ai_stream(text)`: Vers√£o streaming do processamento

### Utilit√°rios (utils/)

#### chat_storage.py:
- `ensure_directories()`: Garante exist√™ncia dos diret√≥rios necess√°rios
- `create_new_conversation()`: Cria nova conversa
- `save_conversation()`: Salva conversa em arquivo
- `get_conversation_by_id()`: Recupera conversa por ID

#### chat_history.py:
- `get_conversation_history()`: Obt√©m hist√≥rico completo
- `save_conversation()`: Salva conversa no hist√≥rico
- `get_conversation_by_id()`: Busca conversa espec√≠fica

### Frontend (static/js/)

#### main.js:
- Inicializa√ß√£o da aplica√ß√£o
- Gerenciamento de estado global
- Configura√ß√£o de event listeners

#### chat.js:
- `iniciarChat()`: Inicia nova sess√£o de chat
- `enviarMensagem()`: Envia mensagem para o backend
- `adicionarMensagem()`: Adiciona mensagem na interface
- `carregarConversa()`: Carrega conversa existente

## 4. Fluxo de Execu√ß√£o

1. **Inicializa√ß√£o**:
   - Servidor Flask inicia (app.py)
   - Diret√≥rios s√£o verificados/criados
   - Interface web √© carregada

2. **Intera√ß√£o do Usu√°rio**:
   - Usu√°rio inicia nova conversa ou carrega existente
   - Mensagens s√£o enviadas via interface
   - Backend processa com IA
   - Respostas s√£o exibidas em tempo real

3. **Armazenamento**:
   - Conversas s√£o salvas automaticamente
   - Hist√≥rico √© mantido em arquivos JSON
   - Dados persistem entre sess√µes

## 5. Estrutura do C√≥digo

O projeto segue uma arquitetura MVC simplificada:
- **Modelo**: Gerenciamento de dados em JSON
- **Vis√£o**: Templates HTML e estilos CSS
- **Controlador**: Rotas Flask e l√≥gica JavaScript

### Boas Pr√°ticas:
- Separa√ß√£o de responsabilidades
- Modulariza√ß√£o do c√≥digo
- Armazenamento persistente
- Tratamento de erros

## 6. Instru√ß√µes de Instala√ß√£o

1. **Prepara√ß√£o do Ambiente**:
```bash
# Criar ambiente virtual
python -m venv venv

# Ativar ambiente
# Windows:
venv\Scripts\activate
# Linux/Mac:
source venv/bin/activate

# Instalar depend√™ncias
pip install -r requirements.txt
```

2. **Configura√ß√£o**:
- Garantir que Python 3.6+ est√° instalado
- Verificar permiss√µes de escrita no diret√≥rio data/

3. **Execu√ß√£o**:
```bash
python app.py
```
- Acessar http://localhost:5000 no navegador

## 7. Considera√ß√µes Finais

### Melhorias Sugeridas:
1. Implementar autentica√ß√£o de usu√°rios
2. Adicionar suporte a m√∫ltiplos modelos de IA
3. Melhorar sistema de backup de conversas
4. Implementar busca no hist√≥rico
5. Adicionar suporte a markdown nas mensagens

### Funcionalidades Futuras:
1. Exporta√ß√£o de conversas em diferentes formatos
2. Compartilhamento de conversas
3. Personaliza√ß√£o avan√ßada da interface
4. Integra√ß√£o com APIs externas
5. Sistema de tags para organiza√ß√£o



Conte√∫do de init_eventlet.py:

# Arquivo de inicializa√ß√£o para garantir que o monkey patching do Eventlet
# seja executado antes de qualquer outro import em todo o projeto
import eventlet
eventlet.monkey_patch()
print("[INFO] Eventlet monkey patching aplicado com sucesso.")


Conte√∫do de README.md:
# Projeto Guilherme ‚Äì Clone de IA Conversacional

## Introdu√ß√£o
O Projeto Guilherme √© um sistema de intelig√™ncia artificial conversacional inspirado no OpenWebUI. O objetivo principal √© criar uma interface de chat interativa e persistente, semelhante ao ChatGPT. O projeto foi desenvolvido com foco na simplicidade e efici√™ncia, eliminando a necessidade de um banco de dados tradicional para armazenamento de hist√≥rico.

## Objetivo do Projeto
O objetivo √© oferecer uma IA conversacional independente, capaz de interagir com os usu√°rios de forma natural. O hist√≥rico das conversas ser√° armazenado em arquivos JSON individuais, garantindo a persist√™ncia dos dados entre recarregamentos da p√°gina.

## Tecnologias Utilizadas
- **Flask (Python)** ‚Üí Backend leve e eficiente para gerenciar as requisi√ß√µes e a l√≥gica do chat.
- **JavaScript, HTML5, CSS** ‚Üí Constru√ß√£o da interface de usu√°rio responsiva e din√¢mica.
- **Armazenamento em JSON** ‚Üí Cada conversa ser√° salva em um arquivo separado dentro do diret√≥rio `data/`.

## Estrutura do Projeto
```
Projeto Guilherme/
‚îú‚îÄ‚îÄ app.py                     # Aplica√ß√£o principal
‚îú‚îÄ‚îÄ static/
‚îÇ   ‚îú‚îÄ‚îÄ css/                   # Estilos
‚îÇ   ‚îú‚îÄ‚îÄ js/                    # L√≥gica frontend
‚îú‚îÄ‚îÄ templates/
‚îÇ   ‚îú‚îÄ‚îÄ index.html             # Interface principal
‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îú‚îÄ‚îÄ chat_storage.py        # Gerenciamento de hist√≥rico em arquivos JSON
‚îÇ   ‚îú‚îÄ‚îÄ text_processor.py      # Utilit√°rios para processamento de texto
‚îú‚îÄ‚îÄ data/                      # Diret√≥rio para armazenar os arquivos JSON das conversas
‚îî‚îÄ‚îÄ requirements.txt           # Lista de depend√™ncias do projeto
```

## Como Executar o Projeto
### 1. Clonar o Reposit√≥rio
```bash
git clone https://github.com/seu-usuario/chat-ai.git
cd chat-ai
```
### 2. Configurar o Ambiente Virtual
```bash
python -m venv venv
source venv/bin/activate  # Linux/MacOS
venv\Scripts\activate     # Windows
```
### 3. Instalar Depend√™ncias
```bash
pip install -r requirements.txt
```
### 4. Executar o Servidor
```bash
python app.py
```
O servidor ser√° iniciado localmente e estar√° dispon√≠vel em `http://127.0.0.1:5000/`.

## Funcionalidades
‚úÖ Interface de chat interativa
‚úÖ Hist√≥rico de conversa salvo em arquivos JSON
‚úÖ Persist√™ncia do hist√≥rico entre recarregamentos da p√°gina
‚úÖ Processamento de mensagens e resposta din√¢mica

## Status Atual
üöÄ O projeto est√° em fase de desenvolvimento, com funcionalidades b√°sicas implementadas e melhorias em andamento.

## Contribui√ß√£o
Se desejar contribuir, sinta-se √† vontade para abrir issues e pull requests no reposit√≥rio!

## Licen√ßa
Este projeto est√° sob a licen√ßa MIT. Veja o arquivo `LICENSE` para mais detalhes.



Conte√∫do de requirements.txt:

# Depend√™ncias principais
Flask==2.3.3
flask-socketio==5.3.6
eventlet==0.35.2
requests==2.31.0

# Depend√™ncias para processamento de texto
markdown==3.4.4
bleach==6.1.0

# Para download de legendas do YouTube
youtube_transcript_api==0.6.1

# Utilit√°rios
python-dotenv==1.0.0


Conte√∫do de start_server.bat:

@echo off
echo Iniciando o servidor NarrateNexus com Eventlet e suporte a WebSockets...
echo Certifique-se de ter instalado as dependencias necessarias:
echo pip install flask flask-socketio eventlet

REM Inicia o servidor usando o arquivo app.py diretamente
python app.py

pause


Conte√∫do de reset.css:
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    transition: background-color 0.2s, color 0.2s;
}

body {
    font-family: 'Inter', sans-serif;
    background-color: var(--bg-primary);
    color: var(--text-primary);
    overflow: hidden;
}

Conte√∫do de typography.css:
body {
    font-family: 'Inter', sans-serif;
    color: var(--text-primary);
}

h1, h2, h3, h4, h5, h6 {
    color: var(--text-primary);
}

Conte√∫do de variables.css:

:root {
    --bg-primary: #f7f7f8;
    --text-primary: #000000;
    --text-secondary: rgba(0, 0, 0, 0.7);
    --text-disabled: rgba(0, 0, 0, 0.5);
    --action-active: #000000;
    --action-hover: rgba(0, 0, 0, 0.08);
    --action-selected: rgba(0, 0, 0, 0.16);
    --action-disabled: rgba(0, 0, 0, 0.3);
    --action-disabled-background: rgba(0, 0, 0, 0.12);
    --msg-user: #e6e6e6;
    --msg-bot: #d9d9d9;
    --sidebar-bg: #ffffff;
    --input-bg: #ffffff;
    --border-color: rgba(0, 0, 0, 0.12);
    --code-bg: #f8f8f8;
    --code-header-bg: #f1f1f1;
    --color-success: #4CAF50;
}

[data-theme="dark"] {
    --bg-primary: #343541;
    --text-primary: #fff;
    --text-secondary: rgba(255, 255, 255, 0.7);
    --text-disabled: rgba(255, 255, 255, 0.5);
    --action-active: #fff;
    --action-hover: rgba(255, 255, 255, 0.08);
    --action-selected: rgba(255, 255, 255, 0.16);
    --action-disabled: rgba(255, 255, 255, 0.3);
    --action-disabled-background: rgba(255, 255, 255, 0.12);
    --msg-user: #444654;
    --msg-bot: #444654;
    --sidebar-bg: #202123;
    --input-bg: #40414f;
    --border-color: rgba(255, 255, 255, 0.12);
    --code-bg: #1e1e1e;
    --code-header-bg: #2d2d2d;
    --color-success: #4CAF50;
}


Conte√∫do de buttons.css:
.new-chat-btn {
    background-color: #19c37d;
    color: white;
    border: none;
    padding: 12px;
    border-radius: 5px;
    cursor: pointer;
    margin-bottom: 1rem;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.5rem;
}

.new-chat-btn:hover {
    background-color: #15a76c;
}

.settings-btn {
    margin-top: auto;
    padding: 12px;
    border: none;
    border-radius: 5px;
    background-color: transparent;
    color: var(--text-primary);
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 0.5rem;
    transition: background-color 0.2s;
}

.settings-btn:hover {
    background-color: var(--action-hover);
}

.theme-toggle, .header-sidebar-toggle {
    width: 32px;
    height: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: var(--action-hover);
    border: none;
    border-radius: 4px;
    color: var(--text-primary);
    cursor: pointer;
}

.theme-toggle:hover, .header-sidebar-toggle:hover {
    background: var(--action-selected);
}

.quick-action-btn {
    padding: 1rem;
    border: 1px solid var(--border-color);
    border-radius: 0.5rem;
    background-color: var(--input-bg);
    color: var(--text-primary);
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 0.5rem;
    transition: all 0.2s;
}

.quick-action-btn:hover {
    background-color: var(--action-hover);
}

Conte√∫do de code-highlight.css:

/* Container para blocos de c√≥digo */
.code-container {
    position: relative;
    margin: 1rem 0;
    border-radius: 6px;
    overflow: hidden;
    background-color: #1e1e1e !important; /* Fundo fixo escuro */
    border: 1px solid var(--border-color);
}

/* Cabe√ßalho do bloco de c√≥digo */
.code-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.5rem 1rem;
    background-color: #2d2d2d !important; /* Cabe√ßalho um pouco mais claro que o fundo */
    color: #d4d4d4;
    font-family: monospace;
    font-size: 0.875rem;
}

/* R√≥tulo de linguagem */
.language-label {
    font-weight: 500;
    text-transform: uppercase;
    font-size: 0.75rem;
    letter-spacing: 0.5px;
}

/* Bot√£o de copiar c√≥digo */
.code-copy-btn {
    background: none;
    border: none;
    color: rgba(255, 255, 255, 0.7);
    cursor: pointer;
    padding: 0.25rem 0.5rem;
    transition: color 0.2s;
    font-size: 0.875rem;
}

.code-copy-btn:hover {
    color: #ffffff;
}

.code-copy-btn.copied {
    color: var(--color-success);
}

/* Bloco de c√≥digo */
.code-block {
    margin: 0;
    padding: 1rem;
    background-color: #1e1e1e !important; /* Fundo fixo escuro */
    overflow-x: auto;
}

.code-block code {
    display: block;
    background-color: transparent !important; /* Remover fundo do <code> para usar o do .code-block */
    font-family: 'Fira Code', Consolas, Monaco, 'Andale Mono', monospace;
    font-size: 0.875rem;
    line-height: 1.5;
    color: #d4d4d4;
}

/* For√ßar o tema de cores highlight.js para os blocos de c√≥digo */
.hljs {
    background: transparent !important; /* O fundo vem do .code-block */
    color: #d4d4d4 !important; /* Cor base do texto para fundo escuro */
}

/* For√ßar fundo escuro em ambos os temas */
[data-theme="light"] .code-container,
[data-theme="light"] .code-block,
[data-theme="light"] pre code,
[data-theme="dark"] .code-container,
[data-theme="dark"] .code-block,
[data-theme="dark"] pre code {
    background-color: #1e1e1e !important;
    color: #d4d4d4 !important;
}

/* Cores de sintaxe para highlight.js - sempre usar cores para tema escuro */
.hljs-keyword { color: #569cd6 !important; }
.hljs-string { color: #ce9178 !important; }
.hljs-comment { color: #6a9955 !important; }
.hljs-function { color: #dcdcaa !important; }
.hljs-number { color: #b5cea8 !important; }


Conte√∫do de command-menu.css:

.command-menu {
    position: absolute;
    bottom: 100%;
    left: 0;
    width: 100%;
    max-height: 200px;
    overflow-y: auto;
    background-color: var(--bg-primary);
    border: 1px solid var(--border-color);
    border-radius: 4px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    display: none;
    z-index: 1000;
}

.command-menu.show {
    display: block;
}

.command-menu-item {
    padding: 8px 16px;
    cursor: pointer;
    transition: background-color 0.2s;
}

.command-menu-item:hover {
    background-color: var(--hover-color);
}

.chat-item {
    cursor: pointer;
    transition: all 0.2s;
    user-select: none;
    pointer-events: all;
}

.chat-item * {
    pointer-events: none;
}

.chat-item:hover {
    background-color: var(--hover-color);
}

.chat-item.active {
    background-color: var(--selected-color);
}


Conte√∫do de forms.css:
.search-box {
    position: relative;
    margin-bottom: 1rem;
}

.search-box input {
    width: 100%;
    padding: 0.75rem;
    border: 1px solid var(--border-color);
    border-radius: 5px;
    background-color: var(--input-bg);
    color: var(--text-primary);
}

.input-box {
    display: flex;
    gap: 1rem;
    width: 100%;
    max-width: 800px;
    margin-bottom: 2rem;
    position: relative;
}

.input-box textarea {
    width: 100%;
    padding: 1rem;
    padding-right: 3.5rem;
    border: 1px solid var(--border-color);
    border-radius: 0.5rem;
    background-color: var(--input-bg);
    color: var(--text-primary);
    font-size: 1rem;
    resize: none;
    min-height: 56px;
    max-height: 200px;
    line-height: 1.5;
    scrollbar-width: none;
    -ms-overflow-style: none;
}

.input-box textarea::-webkit-scrollbar {
    display: none;
}

.input-box .send-btn,
.input-box .stop-btn {
    position: absolute;
    right: 0.75rem;
    bottom: 0.75rem;
    background: transparent;
    border: none;
    color: var(--text-primary);
    cursor: pointer;
    padding: 0.5rem;
    border-radius: 4px;
    transition: all 0.2s;
    display: flex;
    align-items: center;
    justify-content: center;
}

.input-box .send-btn:hover,
.input-box .stop-btn:hover {
    background-color: var(--action-hover);
}

.input-box .stop-btn {
    right: 5rem;
    bottom: 0.5rem;
}

.quick-actions {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 1rem;
    width: 100%;
    max-width: 600px;
}

.model-select {
    padding: 0.5rem;
    border-radius: 4px;
    border: 1px solid var(--border-color);
    background-color: var(--input-bg);
    color: var(--text-primary);
}

Conte√∫do de messages.css:
/* Bot√µes de a√ß√£o nas mensagens */
.message .action-btn {
    background: transparent;
    border: none;
    color: var(--text-secondary);
    padding: 0.5rem;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.3s ease;
}

.message .action-btn:hover {
    background-color: var(--action-hover);
    color: var(--text-primary);
}

.message .action-btn.copied {
    color: #4CAF50;
    background-color: rgba(76, 175, 80, 0.1);
}

.message .message-actions {
    position: absolute;
    top: 0.5rem;
    right: 0.5rem;
    display: none;
    gap: 0.5rem;
}

.message:hover .message-actions {
    display: flex;
}

/* Estilos para formata√ß√£o de mensagens com Markdown */
.message-content {
    line-height: 1.6;
}

.message-content h1, 
.message-content h2, 
.message-content h3 {
    margin: 1rem 0 0.5rem 0;
    line-height: 1.2;
}

.message-content h1 {
    font-size: 1.5rem;
    border-bottom: 1px solid var(--border-color);
    padding-bottom: 0.5rem;
}

.message-content h2 {
    font-size: 1.3rem;
}

.message-content h3 {
    font-size: 1.1rem;
}

.message-content code {
    background-color: var(--action-hover);
    padding: 0.2em 0.4em;
    border-radius: 3px;
    font-family: monospace;
    font-size: 0.9em;
}

/* Container para o bloco de c√≥digo com cabe√ßalho */
.code-container {
    position: relative;
    margin: 1em 0;
    border-radius: 5px;
    overflow: hidden;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    padding: 0; /* Remove padding extra */
}

.code-header {
    background-color: #2d2d2d !important;
    color: #ffffff;
    padding: 5px 10px;
    font-size: 0.9em;
    font-weight: bold;
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin: 0; /* Remove margens */
    border-bottom: none; /* Remove borda para colar com o bloco */
}

.language-label {
    text-transform: uppercase;
    font-size: 0.8em;
    letter-spacing: 1px;
    flex: 1; /* Expande para empurrar o bot√£o */
}

/* Blocos de c√≥digo estilo terminal */
.message-content .code-block {
    background-color: #1e1e1e !important; /* Fundo preto estilo terminal */
    color: #f8f8f2; /* Texto branco */
    padding: 15px;
    border-radius: 0; /* Remove bordas arredondadas para colar com o header */
    font-family: 'Consolas', 'Courier New', monospace;
    position: relative;
    overflow-x: auto; /* Para c√≥digos longos */
    border: 1px solid #333;
    margin: 0; /* Remove margem para alinhar com o cabe√ßalho */
    border-top: none; /* Remove borda superior para colar com o header */
}

.message-content .code-block code {
    background: none !important;
    padding: 0;
    color: #f8f8f2 !important;
    display: block;
    white-space: pre;
}

/* Bot√£o de copiar c√≥digo */
.code-copy-btn {
    background: transparent;
    color: white;
    border: none;
    padding: 5px 8px;
    cursor: pointer;
    border-radius: 3px;
    font-size: 0.8rem;
    transition: background-color 0.2s;
    margin-left: auto; /* Alinha o bot√£o √† direita */
}

.code-copy-btn:hover {
    background: #666;
}

.code-copy-btn.copied {
    background: #4CAF50;
}

/* Estilos para tabelas Markdown */
.chat-container .message-content table {
    width: 100%; /* Ocupa toda a largura dispon√≠vel */
    border-collapse: collapse; /* Une as bordas das c√©lulas */
    margin: 0.5rem 0; /* Espa√ßo reduzido acima e abaixo */
    padding: 0;
    table-layout: fixed; /* Evita c√©lulas desproporcionais */
}

.chat-container .message-content th,
.chat-container .message-content td {
    border: 1px solid var(--border-color); /* Bordas vis√≠veis */
    padding: 0.5rem; /* Espa√ßo interno reduzido */
    text-align: left; /* Alinhamento √† esquerda */
    vertical-align: top; /* Evita alinhamentos estranhos */
    word-wrap: break-word; /* Quebra palavras longas */
    overflow-wrap: break-word;
}

.chat-container .message-content th {
    background-color: var(--action-hover); /* Fundo leve para cabe√ßalhos */
    font-weight: bold; /* Cabe√ßalhos em negrito */
}

.chat-container .message-content tr:nth-child(even) {
    background-color: rgba(0, 0, 0, 0.05); /* Efeito zebrado nas linhas pares */
}

/* Ajuste para tema escuro, se necess√°rio */
[data-theme="dark"] .chat-container .message-content th {
    background-color: var(--action-hover);
}

[data-theme="dark"] .chat-container .message-content tr:nth-child(even) {
    background-color: rgba(255, 255, 255, 0.05);
}

/* Estilos para cita√ß√µes */
.message-content blockquote {
    border-left: 4px solid var(--text-secondary);
    margin: 0.5rem 0;
    padding: 0.5rem 0 0.5rem 1rem;
    color: var(--text-secondary);
    background-color: rgba(125, 125, 125, 0.1);
    border-radius: 0 4px 4px 0;
}

/* Estilos para listas */
.message-content ul, 
.message-content ol {
    padding-left: 1.5rem;
    margin: 0.5rem 0;
}

.message-content ul li, 
.message-content ol li {
    margin-bottom: 0.25rem;
}

/* Estilos para links */
.message-content a {
    color: #3498db;
    text-decoration: none;
}

.message-content a:hover {
    text-decoration: underline;
}

/* Estilos para mensagens espec√≠ficas */
.message.assistant .message-content {
    color: var(--text-primary);
}

.message.user .message-content {
    color: var(--text-primary);
}

/* Estilos para highlight.js */
.hljs {
    background: #1e1e1e !important;
    color: #d4d4d4 !important;
    font-family: 'Consolas', 'Courier New', monospace !important;
    line-height: 1.6 !important;
    tab-size: 4 !important;
}

/* Ajustes para temas claro/escuro */
[data-theme="dark"] .hljs {
    background: #1e1e1e !important;
    color: #d4d4d4 !important;
}

/* For√ßar tema claro para o highlight.js */
[data-theme="light"] .hljs {
    background: #f8f8f8 !important;
    color: #333;
}

/* For√ßa o fundo escuro para os blocos de c√≥digo em ambos os temas */
[data-theme="light"] pre code,
[data-theme="dark"] pre code {
    background-color: #1e1e1e !important;
    color: #d4d4d4 !important;
}


Conte√∫do de container.css:
.container {
    display: flex;
    height: 100vh;
    position: relative;
}

.input-container {
    padding: 1.5rem;
    border-top: 1px solid var(--border-color);
    max-width: 800px;
    margin: 0 auto;
    width: 100%;
}

/* Loading Animation */
.loading {
    display: flex;
    gap: 0.5rem;
    align-items: center;
    padding: 1rem;
}

.loading span {
    width: 8px;
    height: 8px;
    background-color: var(--text-primary);
    border-radius: 50%;
    animation: bounce 0.5s alternate infinite;
}

.loading span:nth-child(2) {
    animation-delay: 0.1s;
}

.loading span:nth-child(3) {
    animation-delay: 0.2s;
}

@keyframes bounce {
    to {
        transform: translateY(-4px);
    }
}

Conte√∫do de main-content.css:
.main-content {
    flex: 1;
    margin-left: 260px;
    transition: margin-left 0.3s ease;
    display: flex;
    flex-direction: column;
    height: 100vh;
}

.main-content.expanded {
    margin-left: 0;
}

.chat-container {
    flex: 1;
    overflow-y: auto;
    padding: 2rem;
    max-width: 800px;
    margin: 0 auto;
    width: 100%;
    scrollbar-width: none;
    -ms-overflow-style: none;
}

.chat-container::-webkit-scrollbar {
    display: none;
}

.message {
    position: relative;
    max-width: 80%;
    margin-bottom: 1.5rem;
    padding: 1rem;
    border-radius: 0.5rem;
    line-height: 1.5;
}

.message.user {
    background-color: var(--msg-user);
    margin-left: auto;
    color: var(--text-primary);
}

.message.assistant {
    background-color: var(--msg-bot);
    margin-right: auto;
    color: var(--text-primary);
}

.message .message-actions {
    position: absolute;
    top: 0.5rem;
    right: 0.5rem;
    display: none;
    gap: 0.5rem;
}

.message:hover .message-actions {
    display: flex;
}

.message .action-btn {
    background: transparent;
    border: none;
    color: var(--text-secondary);
    padding: 0.5rem;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.2s;
}

.message .action-btn:hover {
    background-color: var(--action-hover);
    color: var(--text-primary);
}

/* Top Bar */
.top-bar {
    padding: 1rem;
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 1rem;
    border-bottom: 1px solid var(--border-color);
    background-color: var(--bg-primary);
}

.top-bar-actions {
    display: flex;
    align-items: center;
    gap: 1rem;
}

/* Welcome Screen */
.welcome-screen {
    flex: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 2rem;
    max-width: 800px;
    margin: 0 auto;
    width: 100%;
}

.welcome-screen h1 {
    font-size: 2rem;
    margin-bottom: 2rem;
    color: var(--text-primary);
}

Conte√∫do de sidebar.css:

.sidebar {
    position: fixed;
    width: 260px;
    height: 100vh;
    background-color: var(--sidebar-bg);
    padding: 1rem;
    border-right: 1px solid var(--border-color);
    display: flex;
    flex-direction: column;
    transition: transform 0.3s ease;
    z-index: 1000;
}

.sidebar.collapsed {
    transform: translateX(-260px);
}

.chat-list {
    flex: 1;
    overflow-y: auto;
    scrollbar-width: thin;
    scrollbar-color: var(--text-disabled) transparent;
}

.chat-list::-webkit-scrollbar {
    width: 5px;
}

.chat-list::-webkit-scrollbar-track {
    background: transparent;
}

.chat-list::-webkit-scrollbar-thumb {
    background-color: var(--text-disabled);
    border-radius: 20px;
}

.chat-item {
    padding: 0.75rem;
    border-radius: 5px;
    cursor: pointer;
    margin-bottom: 0.5rem;
    display: flex;
    align-items: center;
    justify-content: space-between;
    transition: background-color 0.2s;
    position: relative;
}

.chat-item:hover {
    background-color: var(--action-hover);
}

.chat-item .action-buttons {
    display: none;
    gap: 5px;
    z-index: 100;
    position: absolute;
    right: 8px;
    top: 50%;
    transform: translateY(-50%);
    background: rgba(0, 0, 0, 0.7);
    padding: 3px;
    border-radius: 4px;
    pointer-events: auto;
}

.chat-item:hover .action-buttons {
    display: flex;
}

.chat-item .action-btn {
    background: #333;
    border: none;
    color: white;
    padding: 5px;
    border-radius: 3px;
    cursor: pointer;
    transition: all 0.2s;
    z-index: 200;
    pointer-events: auto;
    font-size: 12px;
    width: 24px;
    height: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.chat-item .action-btn i {
    font-size: 14px;
}

.chat-item .action-btn:hover {
    background-color: #444;
}

.chat-title {
    flex: 1;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    margin-right: 0.5rem;
}

.chat-item.active {
    background-color: var(--action-selected);
    font-weight: 500;
    border-left: 4px solid var(--color-success);
}


Conte√∫do de styles.css:

@import './components/command-menu.css';

/* Reset e vari√°veis base */
@import './base/variables.css';

@import './base/reset.css';
@import './base/typography.css';

/* Layouts principais */
@import './layout/container.css';
@import './layout/sidebar.css';
@import './layout/main-content.css';

/* Componentes */
@import './components/buttons.css';
@import './components/forms.css';
@import './components/messages.css';
@import './components/code-highlight.css';

/* Temas */
@import './themes/light-theme.css';
@import './themes/dark-theme.css';

/* Importando tema do highlight.js */
@import url('https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css');
@import url('https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css') (prefers-color-scheme: dark);

.chat-container table {
  width: 100%; /* Faz a tabela ocupar toda a largura dispon√≠vel */
  border-collapse: collapse; /* Une as bordas das c√©lulas */
  margin: 1rem 0; /* Adiciona espa√ßo acima e abaixo da tabela */
}

.chat-container th,
.chat-container td {
  border: 1px solid #ccc; /* Adiciona bordas vis√≠veis √†s c√©lulas */
  padding: 0.75rem; /* D√° espa√ßo interno √†s c√©lulas */
  text-align: left; /* Alinha o texto √† esquerda */
}

.chat-container th {
  background-color: #f5f5f5; /* Fundo leve para os cabe√ßalhos */
  font-weight: bold; /* Deixa os cabe√ßalhos em negrito */
}

.chat-container tr:nth-child(even) {
  background-color: #fafafa; /* Efeito zebrado nas linhas pares */
}


.command-menu.visible {
    display: block !important;
}

.command-item {
    padding: 10px;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 8px;
    color: var(--text-primary);
}

.command-item:hover {
    background-color: var(--action-hover);
}

.command-icon {
    color: var(--text-secondary);
    width: 20px;
}

.command-text {
    font-weight: 500;
}

.command-description {
    font-size: 0.875rem;
    color: var(--text-secondary);
}

.command-menu {
    display: none;
    position: absolute;
    /* outras propriedades de estilo */
}
.command-menu.visible {
    display: block;
}


Conte√∫do de dark-theme.css:
[data-theme="dark"] {
    --bg-primary: #343541;
    --text-primary: #fff;
    --text-secondary: rgba(255, 255, 255, 0.7);
    --msg-user: #444654;
    --msg-bot: #444654;
    --sidebar-bg: #202123;
    --input-bg: #40414f;
}

Conte√∫do de light-theme.css:
:root {
    --bg-primary: #f7f7f8;
    --text-primary: #000000;
    --text-secondary: rgba(0, 0, 0, 0.7);
    --msg-user: #e6e6e6;
    --msg-bot: #d9d9d9;
    --sidebar-bg: #ffffff;
    --input-bg: #ffffff;
}

Conte√∫do de variables.css:

:root {
    --bg-primary: #f7f7f8;
    --text-primary: #000000;
    --text-secondary: rgba(0, 0, 0, 0.7);
    --text-disabled: rgba(0, 0, 0, 0.5);
    --action-active: #000000;
    --action-hover: rgba(0, 0, 0, 0.08);
    --action-selected: rgba(0, 0, 0, 0.16);
    --action-disabled: rgba(0, 0, 0, 0.3);
    --action-disabled-background: rgba(0, 0, 0, 0.12);
    --msg-user: #e6e6e6;
    --msg-bot: #d9d9d9;
    --sidebar-bg: #ffffff;
    --input-bg: #ffffff;
    --border-color: rgba(0, 0, 0, 0.12);
    --code-bg: #f8f8f8;
    --code-header-bg: #f1f1f1;
    --color-success: #4CAF50;
}

[data-theme="dark"] {
    --bg-primary: #343541;
    --text-primary: #fff;
    --text-secondary: rgba(255, 255, 255, 0.7);
    --text-disabled: rgba(255, 255, 255, 0.5);
    --action-active: #fff;
    --action-hover: rgba(255, 255, 255, 0.08);
    --action-selected: rgba(255, 255, 255, 0.16);
    --action-disabled: rgba(255, 255, 255, 0.3);
    --action-disabled-background: rgba(255, 255, 255, 0.12);
    --msg-user: #444654;
    --msg-bot: #444654;
    --sidebar-bg: #202123;
    --input-bg: #40414f;
    --border-color: rgba(255, 255, 255, 0.12);
    --code-bg: #1e1e1e;
    --code-header-bg: #2d2d2d;
    --color-success: #4CAF50;
}


Conte√∫do de chatActions.js:

import { mostrarCarregamento } from './chatUI.js';
import { adicionarMensagem } from './chatUI.js';
import { adicionarMensagemAoHistorico, criarNovaConversa, atualizarListaConversas } from './chatStorage.js';

let abortControllers = {};

function inicializarConversa(conversationId) {
    if (!window.conversations[conversationId]) {
        // console.log(`[DEBUG] Inicializando estrutura para conversa ${conversationId}`);
        window.conversations[conversationId] = {
            data: { 
                id: conversationId,
                title: "Nova Conversa",
                messages: []
            },
            streaming: false,
            currentResponse: '',
            eventSource: null,
            abortController: null
        };
    }
    return window.conversations[conversationId];
}

// Fun√ß√£o para atualizar os bot√µes com base na conversa atual
export function atualizarBotoes(sendBtn, stopBtn) {
    const conversationId = window.conversaAtual?.id;
    if (!conversationId) {
        // Se n√£o houver conversa ativa, mostrar apenas o bot√£o de enviar
        sendBtn.style.display = 'flex';
        stopBtn.style.display = 'none';
        return;
    }
    
    const conversation = window.conversations[conversationId];
    if (conversation && conversation.streaming) {
        sendBtn.style.display = 'none';
        stopBtn.style.display = 'flex';
    } else {
        sendBtn.style.display = 'flex';
        stopBtn.style.display = 'none';
    }
    
    // console.log(`[DEBUG] Bot√µes atualizados para conversa ${conversationId}: streaming=${conversation?.streaming}`);
}

export async function enviarMensagem(mensagem, input, chatContainer, sendBtn, stopBtn) {
    if (!mensagem.trim()) return;

    if (mensagem.startsWith('/youtube ')) {
        const videoUrl = mensagem.split(' ')[1];
        if (!videoUrl) {
            adicionarMensagem(chatContainer, "Por favor, forne√ßa uma URL do YouTube v√°lida", 'assistant');
            return;
        }

        if (!window.conversaAtual) {
            criarNovaConversa();
        }

        adicionarMensagem(chatContainer, mensagem, 'user');
        adicionarMensagemAoHistorico(mensagem, 'user');
        // Atualiza lista de conversas ap√≥s enviar mensagem
        atualizarListaConversas();

        const loadingDiv = mostrarCarregamento(chatContainer);
        try {
            const response = await fetch('/process_youtube', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ 
                    video_url: videoUrl,
                    conversation_id: window.conversaAtual.id,
                    comando: mensagem
                })
            });

            const data = await response.json();
            loadingDiv.remove();

            if (data.error) {
                adicionarMensagem(chatContainer, `Erro: ${data.error}`, 'assistant');
                adicionarMensagemAoHistorico(`Erro: ${data.error}`, 'assistant');
            } else {
                adicionarMensagem(chatContainer, data.text, 'assistant');
                adicionarMensagemAoHistorico(data.text, 'assistant');
            }
            
            window.dispatchEvent(new CustomEvent('historicoAtualizado'));
            // Atualiza lista de conversas ap√≥s receber resposta
            atualizarListaConversas();
        } catch (error) {
            loadingDiv.remove();
            const errorMsg = "Erro ao processar o v√≠deo";
            adicionarMensagem(chatContainer, errorMsg, 'assistant');
            adicionarMensagemAoHistorico(errorMsg, 'assistant');
        }
        return;
    }

    if (!window.conversaAtual) {
        // console.log("[DEBUG] Criando nova conversa...");
        criarNovaConversa();
    }

    const conversationId = window.conversaAtual.id;
    // console.log(`[DEBUG] Enviando mensagem para conversa: ${conversationId}`);

    const conversation = inicializarConversa(conversationId);
    
    adicionarMensagem(chatContainer, mensagem, 'user');
    adicionarMensagemAoHistorico(mensagem, 'user', conversationId);
    // Atualiza lista de conversas ap√≥s enviar mensagem do usu√°rio
    atualizarListaConversas();

    input.value = '';
    input.style.height = 'auto';
    
    const loadingDiv = mostrarCarregamento(chatContainer);

    // Marcar conversa como streaming e atualizar bot√µes
    conversation.streaming = true;
    atualizarBotoes(sendBtn, stopBtn);
    
    conversation.abortController = new AbortController();
    abortControllers[conversationId] = conversation.abortController;

    conversation.currentResponse = '';

    try {
        const response = await fetch('/send_message', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                message: mensagem,
                conversation_id: conversationId
            }),
            signal: conversation.abortController.signal
        });

        if (!response.ok) {
            throw new Error('Erro na resposta do servidor');
        }

        const reader = response.body.getReader();
        const decoder = new TextDecoder('utf-8');
        
        let streamingDiv = null;

        while (true) {
            const { value, done } = await reader.read();
            if (done) break;

            const chunk = decoder.decode(value, { stream: true });
            const lines = chunk.split('\n');

            for (const line of lines) {
                if (line.startsWith('data: ')) {
                    try {
                        const jsonData = JSON.parse(line.slice(6));
                        if (jsonData.content) {
                            conversation.currentResponse += jsonData.content;
                            
                            if (window.conversaAtual && window.conversaAtual.id === conversationId) {
                                if (!streamingDiv) {
                                    loadingDiv.remove();
                                    streamingDiv = document.createElement('div');
                                    streamingDiv.className = 'message assistant streaming-message';
                                    chatContainer.appendChild(streamingDiv);
                                }
                                
                                streamingDiv.innerHTML = `<div class="message-content"><p>${conversation.currentResponse.replace(/\n/g, '<br>')}</p></div>`;
                                chatContainer.scrollTop = chatContainer.scrollHeight;
                            }
                        }
                    } catch (e) {
                        console.error('Erro ao processar chunk:', e);
                    }
                }
            }
        }

        if (streamingDiv) {
            streamingDiv.remove();
        } else if (window.conversaAtual && window.conversaAtual.id === conversationId) {
            loadingDiv.remove();
        }
        
        if (window.conversaAtual && window.conversaAtual.id === conversationId) {
            adicionarMensagem(chatContainer, conversation.currentResponse, 'assistant');
            window.dispatchEvent(new CustomEvent('historicoAtualizado'));
            window.dispatchEvent(new CustomEvent('mensagemEnviada'));
        } else {
            // console.log(`[DEBUG] Conversa mudou durante streaming. N√£o atualizando UI.`);
        }
        
        // Sempre salvar a mensagem no hist√≥rico local, independentemente da conversa ativa
        adicionarMensagemAoHistorico(conversation.currentResponse, 'assistant', conversationId);
        // Atualiza lista de conversas ap√≥s receber resposta
        atualizarListaConversas();
        
    } catch (erro) {
        if (erro.name === 'AbortError') {
            // console.log('Gera√ß√£o de resposta interrompida pelo usu√°rio');
            if (window.conversaAtual && window.conversaAtual.id === conversationId) {
                loadingDiv.remove();
            }
        } else {
            console.error('Erro:', erro);
            if (window.conversaAtual && window.conversaAtual.id === conversationId) {
                loadingDiv.remove();
            }
            const errorMsg = 'Erro ao conectar com o servidor. Por favor, tente novamente.';
            
            if (window.conversaAtual && window.conversaAtual.id === conversationId) {
                adicionarMensagem(chatContainer, errorMsg, 'assistant');
            }
            
            adicionarMensagemAoHistorico(errorMsg, 'assistant', conversationId);
        }
    } finally {
        if (conversation) {
            conversation.streaming = false;
            conversation.abortController = null;
        }
        delete abortControllers[conversationId];
        
        // Atualizar os bot√µes apenas se estamos na mesma conversa
        if (window.conversaAtual && window.conversaAtual.id === conversationId) {
            atualizarBotoes(sendBtn, stopBtn);
        }
    }
}

export function interromperResposta() {
    const conversationId = window.conversaAtual?.id;
    if (!conversationId) return;
    
    // console.log(`[DEBUG] Interrompendo resposta para conversa: ${conversationId}`);
    
    if (abortControllers[conversationId]) {
        abortControllers[conversationId].abort();
    }
    
    const conversation = window.conversations[conversationId];
    if (conversation) {
        if (conversation.eventSource) {
            conversation.eventSource.close();
            conversation.eventSource = null;
        }
        conversation.streaming = false;
        
        // Atualizar bot√µes ap√≥s interromper
        const sendBtn = document.getElementById('send-btn');
        const stopBtn = document.getElementById('stop-btn');
        if (sendBtn && stopBtn) {
            atualizarBotoes(sendBtn, stopBtn);
        }
    }
}


Conte√∫do de chatStorage.js:
import { adicionarMensagem } from './chatUI.js';
import { atualizarBotoes } from './chatActions.js';
import { entrarNaSalaDeConversa } from './chatSync.js';
import { melhorarBlocosCodigo, escapeHTML } from './chatUtils.js';
import { renderMessage } from '../messageRenderer.js';

// Cache para conversas j√° carregadas
const conversationCache = {};

export function carregarConversa(id) {
    // Reset the current view
    const chatContainer = document.querySelector('.chat-container');
    const welcomeScreen = document.querySelector('.welcome-screen');
    const inputContainer = document.querySelector('.input-container');
    
    if (!chatContainer) {
        console.error('[ERRO] Chat container n√£o encontrado');
        return;
    }
    
    // Show loading indicator
    welcomeScreen.style.display = 'none';
    chatContainer.style.display = 'block';
    inputContainer.style.display = 'block';
    chatContainer.innerHTML = '<div class="loading-indicator">Carregando conversa...</div>';
    
    // Primeiro, carregamos apenas os metadados da conversa
    fetch(`/get_conversation/${id}`)
        .then(response => {
            if (!response.ok) throw new Error('HTTP error: ' + response.status);
            return response.json();
        })
        .then(conversa => {
            if (conversa.error) {
                console.error('Erro ao carregar conversa:', conversa.error);
                chatContainer.innerHTML = '<div class="error-message">Erro ao carregar conversa</div>';
                return;
            }
            
            // Normalizar estrutura da conversa
            if (!conversa.messages) {
                conversa.messages = conversa.mensagens || [];
                delete conversa.mensagens;
            }
            
            if (!Array.isArray(conversa.messages)) {
                console.error('[ERRO] Messages n√£o √© um array, corrigindo...');
                conversa.messages = [];
            }
            
            if (conversa.titulo) {
                conversa.title = conversa.titulo;
                delete conversa.titulo;
            }
            
            // Armazenar conversa atual e atualizar cache de conversas
            window.conversaAtual = {
                ...conversa,
                messages: [] // Inicialmente vazio, ser√° carregado por lotes
            };
            
            if (!window.conversas) window.conversas = [];
            window.conversas = window.conversas.map(c => 
                c.id === conversa.id ? conversa : c
            );

            // Adicionar √† estrutura de conversas global por ID
            if (!window.conversations) window.conversations = {};
            
            // Preservar o estado de streaming se j√° existir
            const existingConversation = window.conversations[id];
            window.conversations[id] = {
                data: conversa,
                streaming: existingConversation ? existingConversation.streaming : false,
                currentResponse: existingConversation ? existingConversation.currentResponse : '',
                eventSource: existingConversation ? existingConversation.eventSource : null,
                abortController: existingConversation ? existingConversation.abortController : null,
                pendingUpdates: false,
                totalMessages: conversa.messages.length,
                loadedMessages: new Set(), // Limpar o conjunto de mensagens carregadas
                isLoading: false // Controle de estado de carregamento
            };
            
            // Limpar o container e preparar para lazy loading
            chatContainer.innerHTML = '';
            
            console.log(`[DEBUG] Iniciando carregamento da conversa ${id}`);
            
            // Iniciar o carregamento ass√≠ncrono das mensagens em lotes
            carregarMensagensEmLotes(id, 0, 20);  // Carrega as primeiras 20 mensagens

            // Entrar na sala de WebSocket para esta conversa
            entrarNaSalaDeConversa(id);
            
            // Atualizar lista de conversas para refletir o chat ativo
            atualizarListaConversas();
            
            window.dispatchEvent(new CustomEvent('conversaCarregada'));
            window.dispatchEvent(new CustomEvent('historicoAtualizado'));
        })
        .catch(error => {
            console.error('Erro ao carregar conversa:', error);
            chatContainer.innerHTML = '<div class="error-message">Erro ao carregar conversa</div>';
        });
}

// Nova fun√ß√£o para carregar mensagens em lotes
function carregarMensagensEmLotes(conversationId, offset, limit) {
    const chatContainer = document.querySelector('.chat-container');
    
    if (!chatContainer) {
        console.error('[ERRO] Chat container n√£o encontrado');
        return;
    }
    
    if (!window.conversations || !window.conversations[conversationId]) {
        console.error('[ERRO] Conversa n√£o encontrada na estrutura global');
        return;
    }
    
    const conversation = window.conversations[conversationId];
    if (conversation.isLoading) {
        console.log('[INFO] Carregamento j√° em andamento, ignorando');
        return;
    }
    
    conversation.isLoading = true;
    
    // Mostrar indicador apenas no primeiro lote
    if (offset === 0 && !chatContainer.querySelector('.loading-indicator')) {
        const loadingIndicator = document.createElement('div');
        loadingIndicator.className = 'loading-indicator';
        loadingIndicator.textContent = 'Carregando mensagens...';
        loadingIndicator.id = 'loading-indicator';
        chatContainer.appendChild(loadingIndicator);
    }
    
    console.log(`[DEBUG] Carregando lote: offset=${offset}, limit=${limit}`);
    
    fetch(`/get_conversation/${conversationId}/${offset}/${limit}`)
        .then(response => response.json())
        .then(data => {
            const loadingIndicator = document.getElementById('loading-indicator');
            if (loadingIndicator) {
                chatContainer.removeChild(loadingIndicator);
            }
            
            if (data.error) {
                console.error('Erro ao carregar mensagens:', data.error);
                conversation.isLoading = false;
                return;
            }
            
            const messages = data.messages || [];
            const hasMore = data.hasMore || false;
            const total = data.total || 0;
            
            console.log(`[DEBUG] Recebido: ${messages.length} mensagens, hasMore=${hasMore}, total=${total}`);
            
            if (offset === 0 && messages.length === 0) {
                const emptyMessage = document.createElement('div');
                emptyMessage.className = 'empty-message';
                emptyMessage.textContent = 'Nenhuma mensagem nesta conversa.';
                chatContainer.appendChild(emptyMessage);
                conversation.isLoading = false;
                return;
            }
            
            const fragment = document.createDocumentFragment();
            const loadedMessages = conversation.loadedMessages;
            
            messages.forEach((msg) => {
                // Criar um ID √∫nico para a mensagem baseado em seu conte√∫do e timestamp
                const messageId = msg.id || 
                                msg.timestamp || 
                                `${conversationId}_${msg.content.slice(0, 20)}_${Date.now()}`;
                
                if (!loadedMessages.has(messageId)) {
                    console.log(`[DEBUG] Adicionando nova mensagem: ${messageId}`);
                    loadedMessages.add(messageId);
                    
                    const messageDiv = document.createElement('div');
                    messageDiv.className = `message ${msg.role === 'assistant' ? 'assistant' : 'user'}`;
                    messageDiv.dataset.messageId = messageId;
                    
                    const messageContent = document.createElement('div');
                    messageContent.className = 'message-content';
                    messageContent.innerHTML = msg.role === 'assistant' ? 
                        renderMessage(msg.content) : 
                        `<p>${escapeHTML(msg.content).replace(/\n/g, '<br>')}</p>`;
                    
                    const messageActions = document.createElement('div');
                    messageActions.className = 'message-actions';
                    messageActions.innerHTML = `
                        <button class="action-btn copy-btn" onclick="window.copiarMensagem(this)" title="Copiar mensagem">
                            <i class="fas fa-copy"></i>
                        </button>
                        ${msg.role === 'assistant' ? `
                            <button class="action-btn regenerate-btn" onclick="window.regenerarResposta(this)" title="Regenerar resposta">
                                <i class="fas fa-redo"></i>
                            </button>
                        ` : ''}
                    `;
                    
                    messageDiv.appendChild(messageContent);
                    messageDiv.appendChild(messageActions);
                    
                    if (offset === 0) {
                        fragment.appendChild(messageDiv);
                    } else {
                        fragment.insertBefore(messageDiv, fragment.firstChild);
                    }
                } else {
                    console.log(`[DEBUG] Mensagem ${messageId} j√° carregada, ignorada`);
                }
            });
            
            if (offset === 0) {
                chatContainer.appendChild(fragment);
            } else {
                if (chatContainer.firstChild) {
                    chatContainer.insertBefore(fragment, chatContainer.firstChild);
                } else {
                    chatContainer.appendChild(fragment);
                }
            }
            
            setTimeout(() => melhorarBlocosCodigo(), 100);
            atualizarBotoes(document.getElementById('send-btn'), document.getElementById('stop-btn'));
            
            const oldHeight = chatContainer.scrollHeight;
            const oldScrollTop = chatContainer.scrollTop;
            
            // Configurar scroll apenas se houver mais mensagens
            if (hasMore && loadedMessages.size < total) {
                console.log(`[DEBUG] Configurando scroll listener, mensagens carregadas: ${loadedMessages.size}/${total}`);
                configureScrollListener(conversationId, offset + limit, limit);
            } else {
                console.log(`[DEBUG] Todas as mensagens carregadas (${loadedMessages.size}/${total}), removendo listener`);
                if (chatContainer._scrollListener) {
                    chatContainer.removeEventListener('scroll', chatContainer._scrollListener);
                    chatContainer._scrollListener = null;
                }
            }
            
            if (offset === 0) {
                chatContainer.scrollTop = chatContainer.scrollHeight;
            } else {
                const newHeight = chatContainer.scrollHeight;
                chatContainer.scrollTop = oldScrollTop + (newHeight - oldHeight);
            }
            
            conversation.isLoading = false;
        })
        .catch(error => {
            console.error('Erro ao carregar lote:', error);
            conversation.isLoading = false;
            const loadingIndicator = document.getElementById('loading-indicator');
            if (loadingIndicator) loadingIndicator.textContent = 'Erro ao carregar mensagens.';
        });
}

// Configurar detector de scroll para lazy loading
function configureScrollListener(conversationId, nextOffset, limit) {
    const chatContainer = document.querySelector('.chat-container');
    
    if (!chatContainer) {
        console.error('[ERRO] Chat container n√£o encontrado');
        return;
    }
    
    // Remover listener anterior se existir
    if (chatContainer._scrollListener) {
        chatContainer.removeEventListener('scroll', chatContainer._scrollListener);
        chatContainer._scrollListener = null;
    }
    
    const scrollListener = function() {
        const conversation = window.conversations[conversationId];
        if (!conversation) {
            console.error('[ERRO] Conversa n√£o encontrada na estrutura global');
            return;
        }
        
        if (conversation.isLoading) {
            console.log('[DEBUG] Carregamento em andamento, ignorando scroll');
            return;
        }
        
        // Verificar se estamos pr√≥ximos do topo e n√£o estamos carregando
        if (chatContainer.scrollTop < 100) {
            console.log(`[DEBUG] Scroll no topo, carregando mais mensagens de offset ${nextOffset}`);
            
            // Remover listener antes de carregar para evitar chamadas m√∫ltiplas
            chatContainer.removeEventListener('scroll', scrollListener);
            chatContainer._scrollListener = null;
            
            // Carregar pr√≥ximo lote
            carregarMensagensEmLotes(conversationId, nextOffset, limit);
        }
    };
    
    // Adicionar novo listener
    chatContainer.addEventListener('scroll', scrollListener);
    chatContainer._scrollListener = scrollListener;
    
    console.log(`[DEBUG] Scroll listener configurado para offset ${nextOffset}`);
}

export function atualizarListaConversas() {
    // console.log('[DEBUG] Atualizando lista de conversas');
    
    const chatList = document.querySelector('.chat-list');
    if (!chatList) {
        console.error('[ERRO] Chat list n√£o encontrada');
        return;
    }

    // Limpar qualquer listener existente para evitar duplica√ß√£o
    if (chatList._clickListener) {
        chatList.removeEventListener('click', chatList._clickListener);
    }

    fetch('/get_conversation_history')
        .then(response => response.json())
        .then(conversas => {
            chatList.innerHTML = '';
            conversas.forEach(conversa => {
                const conversaElement = document.createElement('div');
                conversaElement.className = 'chat-item';
                if (window.conversaAtual && window.conversaAtual.id === conversa.id) {
                    conversaElement.classList.add('active');
                }
                
                conversaElement.dataset.id = conversa.id;
                
                const titulo = conversa.title || conversa.titulo || 'Nova conversa';
                
                const spanTitulo = document.createElement('span');
                spanTitulo.className = 'chat-title';
                spanTitulo.textContent = titulo;
                conversaElement.appendChild(spanTitulo);
                
                const actionButtons = document.createElement('div');
                actionButtons.className = 'action-buttons';
                actionButtons.style.position = 'relative';
                actionButtons.style.zIndex = '100';
                
                // Bot√£o Renomear com √≠cone
                const renameBtn = document.createElement('button');
                renameBtn.className = 'action-btn rename-btn';
                renameBtn.dataset.id = conversa.id;
                renameBtn.title = 'Renomear conversa';
                renameBtn.innerHTML = '<i class="fas fa-edit"></i>'; // √çcone de l√°pis para editar
                renameBtn.style.pointerEvents = 'auto';
                
                // Adicionar listener direto ao bot√£o
                renameBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    // console.log('[DEBUG] Rename clicked diretamente para ID:', conversa.id);
                    renomearConversa(conversa.id);
                });
                
                // Bot√£o Excluir com √≠cone
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'action-btn delete-btn';
                deleteBtn.dataset.id = conversa.id;
                deleteBtn.title = 'Excluir conversa';
                deleteBtn.innerHTML = '<i class="fas fa-trash"></i>'; // √çcone de lixeira para excluir
                deleteBtn.style.pointerEvents = 'auto';
                
                // Adicionar listener direto ao bot√£o
                deleteBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    // console.log('[DEBUG] Delete clicked diretamente para ID:', conversa.id);
                    excluirConversa(conversa.id);
                });
                
                actionButtons.appendChild(renameBtn);
                actionButtons.appendChild(deleteBtn);
                conversaElement.appendChild(actionButtons);
                
                // Evitar que cliques nos bot√µes disparem o carregamento da conversa
                actionButtons.addEventListener('click', function(e) {
                    e.stopPropagation();
                    // console.log('[DEBUG] Clique capturado em action-buttons');
                });
                
                chatList.appendChild(conversaElement);
            });
            
            // Adicionar listener de delega√ß√£o tamb√©m como fallback
            const clickListener = function(e) {
                // console.log('[DEBUG] Clique detectado em:', e.target);
                
                // Se clicar nos bot√µes, n√£o carrega a conversa
                if (e.target.closest('.action-buttons')) {
                    // console.log('[DEBUG] Clique em bot√µes, interrompendo propaga√ß√£o');
                    e.stopPropagation();
                    return;
                }
                
                // Verificar se clicou em um bot√£o de renomear
                const renameBtn = e.target.closest('.rename-btn');
                if (renameBtn) {
                    e.preventDefault();
                    e.stopPropagation();
                    const id = renameBtn.dataset.id;
                    // console.log('[DEBUG] Bot√£o renomear clicado para ID:', id);
                    renomearConversa(id);
                    return;
                }
                
                // Verificar se clicou em um bot√£o de excluir
                const deleteBtn = e.target.closest('.delete-btn');
                if (deleteBtn) {
                    e.preventDefault();
                    e.stopPropagation();
                    const id = deleteBtn.dataset.id;
                    // console.log('[DEBUG] Bot√£o excluir clicado para ID:', id);
                    excluirConversa(id);
                    return;
                }
                
                // Se n√£o clicou em nenhum bot√£o, carrega a conversa
                const chatItem = e.target.closest('.chat-item');
                if (chatItem) {
                    const id = chatItem.dataset.id;
                    // console.log('[DEBUG] Carregando conversa pelo clique:', id);
                    carregarConversa(id);
                }
            };
            
            chatList.addEventListener('click', clickListener);
            chatList._clickListener = clickListener; // Salva a refer√™ncia para poder remover depois
            
            window.dispatchEvent(new CustomEvent('listaAtualizada'));
        })
        .catch(error => console.error('Erro ao atualizar lista de conversas:', error));
}

export function criarNovaConversa() {
    const novaConversa = {
        id: Date.now().toString(),
        title: "Nova Conversa",
        messages: []
    };
    
    window.conversas = window.conversas || [];
    window.conversas.unshift(novaConversa);
    window.conversaAtual = novaConversa;
    
    // Adicionar √† estrutura de conversas global
    if (!window.conversations) window.conversations = {};
    window.conversations[novaConversa.id] = {
        data: novaConversa,
        streaming: false,
        currentResponse: ''
    };
    
    // Atualizar lista de conversas instantaneamente ao criar nova conversa
    atualizarListaConversas();
    window.dispatchEvent(new CustomEvent('historicoAtualizado'));
    
    return novaConversa;
}

export function adicionarMensagemAoHistorico(mensagem, tipo, conversationId = null) {
    // Se n√£o especificado, usa a conversa atual
    conversationId = conversationId || (window.conversaAtual ? window.conversaAtual.id : null);
    
    // console.log(`[DEBUG] Adicionando mensagem √† conversa ${conversationId}, tipo: ${tipo}`);
    
    if (!conversationId) {
        // console.log('[CORRE√á√ÉO] N√£o h√° conversa atual, criando uma nova');
        const novaConversa = criarNovaConversa();
        conversationId = novaConversa.id;
    }
    
    // Refer√™ncia √† conversa na estrutura global de conversas
    let conversation = window.conversations[conversationId];
    
    if (!conversation) {
        console.log(`[ERRO] Conversa ${conversationId} n√£o encontrada na estrutura global`);
        return;
    }
    
    // Verificar se a estrutura da conversa no estado global est√° correta
    if (!window.conversaAtual || !Array.isArray(window.conversaAtual.messages)) {
        // console.log('[CORRE√á√ÉO] Estado da conversa atual inv√°lido, corrigindo');
        window.conversaAtual = {
            id: conversationId,
            title: window.conversations[conversationId].data.title || "Nova conversa",
            messages: []
        };
        
        // Atualizar na estrutura global
        window.conversations[conversationId].data = window.conversaAtual;
    }
    
    try {
        const message = {
            content: mensagem,
            role: tipo,
            timestamp: new Date().toISOString()
        };
        
        // Adicionar mensagem ao hist√≥rico da conversa atual
        if (window.conversaAtual && window.conversaAtual.id === conversationId) {
            window.conversaAtual.messages.push(message);
        }
        
        // Adicionar tamb√©m √† estrutura de dados de conversas global
        if (!Array.isArray(window.conversations[conversationId].data.messages)) {
            window.conversations[conversationId].data.messages = [];
        }
        
        window.conversations[conversationId].data.messages.push(message);
        
        // console.log(`[DEBUG] Mensagem adicionada com sucesso √† conversa ${conversationId}`);
        
        window.dispatchEvent(new CustomEvent('historicoAtualizado'));
        window.dispatchEvent(new CustomEvent('mensagemAdicionada'));
        
    } catch (err) {
        console.error(`[ERRO CR√çTICO] Falha ao adicionar mensagem √† conversa ${conversationId}:`, err);
    }
    
    // IMPORTANTE: Removido a chamada fetch para /save_message aqui para evitar duplica√ß√£o
    // O backend j√° salva a mensagem ao final do streaming
}

export function renomearConversa(id) {
    // console.log('[DEBUG] Tentando renomear conversa:', id);
    
    const novoTitulo = prompt('Digite o novo t√≠tulo da conversa:');
    if (!novoTitulo || !novoTitulo.trim()) {
        // console.log('[DEBUG] Opera√ß√£o cancelada pelo usu√°rio');
        return;
    }

    fetch(`/rename_conversation/${id}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ title: novoTitulo.trim() })
    })
    .then(response => {
        // console.log('[DEBUG] Status da resposta:', response.status);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        return response.json();
    })
    .then(data => {
        // console.log('[DEBUG] Resposta do servidor:', data);
        
        if (data.success) {
            // console.log('[DEBUG] Conversa renomeada com sucesso');
            
            // Atualizar na conversa atual se for a mesma
            if (window.conversaAtual && window.conversaAtual.id === id) {
                window.conversaAtual.title = novoTitulo.trim();
            }
            
            // Atualizar na estrutura global de conversas
            if (window.conversations && window.conversations[id]) {
                window.conversations[id].data.title = novoTitulo.trim();
            }
            
            // Atualizar na lista de conversas em mem√≥ria
            if (window.conversas) {
                window.conversas = window.conversas.map(c => 
                    c.id === id ? {...c, title: novoTitulo.trim()} : c
                );
            }
            
            // Atualizar a lista de conversas na UI
            atualizarListaConversas();
            
            // Notificar sistema sobre altera√ß√£o
            window.dispatchEvent(new CustomEvent('conversaAtualizada', { 
                detail: { id, newTitle: novoTitulo.trim() } 
            }));
        } else {
            throw new Error(data.error || 'Erro desconhecido');
        }
    })
    .catch(error => {
        console.error('[ERRO] Falha ao renomear:', error);
        alert('Erro ao renomear conversa: ' + error.message);
    });
}

export function excluirConversa(id) {
    // console.log('[DEBUG] Tentando excluir conversa:', id);
    
    if (!confirm('Tem certeza que deseja excluir esta conversa?')) {
        // console.log('[DEBUG] Opera√ß√£o cancelada pelo usu√°rio');
        return;
    }

    fetch(`/delete_conversation/${id}`, {
        method: 'DELETE',
        headers: { 'Content-Type': 'application/json' }
    })
    .then(response => {
        // console.log('[DEBUG] Status da resposta:', response.status);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        return response.json();
    })
    .then(data => {
        // console.log('[DEBUG] Resposta do servidor:', data);
        
        if (data.success) {
            // console.log('[DEBUG] Conversa exclu√≠da com sucesso');
            
            // Remover da mem√≥ria
            if (window.conversas) {
                window.conversas = window.conversas.filter(c => c.id !== id);
            }
            
            // Remover da estrutura global de conversas e finalizar qualquer streaming em andamento
            if (window.conversations && window.conversations[id]) {
                // Interromper streaming se existir
                if (window.conversations[id].abortController) {
                    window.conversations[id].abortController.abort();
                }
                if (window.conversations[id].eventSource) {
                    window.conversations[id].eventSource.close();
                }
                delete window.conversations[id];
            }
            
            // Se a conversa atual foi exclu√≠da, voltar para a tela inicial
            if (window.conversaAtual && window.conversaAtual.id === id) {
                window.conversaAtual = null;
                const welcomeScreen = document.querySelector('.welcome-screen');
                const chatContainer = document.querySelector('.chat-container');
                const inputContainer = document.querySelector('.input-container');
                
                welcomeScreen.style.display = 'flex';
                chatContainer.style.display = 'none';
                inputContainer.style.display = 'none';
                
                // Atualizar bot√µes para estado inicial
                const sendBtn = document.getElementById('send-btn');
                const stopBtn = document.getElementById('stop-btn');
                if (sendBtn && stopBtn) {
                    sendBtn.style.display = 'flex';
                    stopBtn.style.display = 'none';
                }
            }
            
            // Atualizar a lista de conversas
            atualizarListaConversas();
            
            // Notificar sistema sobre exclus√£o
            window.dispatchEvent(new CustomEvent('conversaExcluida', { 
                detail: { id } 
            }));
        } else {
            throw new Error(data.error || 'Erro desconhecido');
        }
    })
    .catch(error => {
        console.error('[ERRO] Falha na requisi√ß√£o:', error);
        alert('Erro ao excluir conversa: ' + error.message);
    });
}


Conte√∫do de chatSync.js:
/**
 * chatSync.js
 * Respons√°vel pela sincroniza√ß√£o entre sess√µes do chat via WebSockets
 */

let socket = null;
let isConnected = false;
let reconnectAttempts = 0;
const MAX_RECONNECT_ATTEMPTS = 5;
const RECONNECT_DELAY = 3000; // 3 segundos

/**
 * Inicializa a conex√£o com WebSocket e configura os listeners
 */
export function inicializarSync() {
    // Tentar obter uma sessionId do localStorage ou criar uma nova
    const sessionId = localStorage.getItem('sessionId') || gerarSessionId();
    localStorage.setItem('sessionId', sessionId);
    
    // Inicializar socket.io
    try {
        // URL atual do documento no navegador para evitar problemas de CORS
        const url = window.location.origin;
        socket = io(url);
        
        // Configurar listeners de conex√£o
        setupConnectionListeners(sessionId);
        
        // Configurar listeners de eventos
        setupEventListeners();
        
        return true;
    } catch (error) {
        console.error("Erro ao inicializar WebSocket:", error);
        return false;
    }
}

/**
 * Configura os listeners para eventos de conex√£o
 */
function setupConnectionListeners(sessionId) {
    if (!socket) return;
    
    socket.on('connect', () => {
        isConnected = true;
        reconnectAttempts = 0;
        // Registrar sess√£o do usu√°rio para notifica√ß√µes
        socket.emit('register_session', { session_id: sessionId });
        
        // Registrar conversa atual (se existir)
        if (window.conversaAtual && window.conversaAtual.id) {
            entrarNaSalaDeConversa(window.conversaAtual.id);
        }
    });
    
    socket.on('disconnect', () => {
        isConnected = false;
    });
    
    socket.on('connect_error', (error) => {
        if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
            reconnectAttempts++;
            setTimeout(() => {
                socket.connect();
            }, RECONNECT_DELAY);
        }
    });
}

/**
 * Configura os listeners para eventos espec√≠ficos do chat
 */
function setupEventListeners() {
    if (!socket) return;
    
    // Receber fragmento de mensagem em tempo real
    socket.on('message_chunk', (data) => {
        if (!window.conversaAtual || window.conversaAtual.id !== data.conversation_id) {
            // Se n√£o for a conversa atual, apenas atualizar o buffer da conversa
            atualizarBufferDaConversa(data.conversation_id, data.content);
            return;
        }
        
        // Se for a conversa atual e estiver vis√≠vel, atualizar a UI
        if (document.visibilityState === 'visible') {
            atualizarMensagemEmStream(data.content);
        }
    });
    
    // Receber notifica√ß√£o de que uma conversa foi atualizada
    socket.on('conversation_updated', (data) => {
        // Atualizar lista de conversas
        atualizarListaConversas();
        
        // Se for a conversa atual, atualizar a UI
        if (window.conversaAtual && window.conversaAtual.id === data.conversation_id) {
            // Se a aba estiver inativa, recarregar a conversa quando se tornar ativa
            if (document.visibilityState !== 'visible') {
                marcarParaRecarregar(data.conversation_id);
            } else {
                // Finalizar o streaming removendo a classe streaming-message
                const streamingMessage = document.querySelector('.streaming-message');
                if (streamingMessage) {
                    streamingMessage.classList.remove('streaming-message');
                }
            }
        }
    });
    
    // Receber notifica√ß√£o de que uma conversa foi renomeada
    socket.on('conversation_renamed', (data) => {
        // Atualizar no estado local
        if (window.conversas) {
            window.conversas = window.conversas.map(c => 
                c.id === data.conversation_id ? {...c, title: data.new_title} : c
            );
        }
        
        if (window.conversations && window.conversations[data.conversation_id]) {
            window.conversations[data.conversation_id].data.title = data.new_title;
        }
        
        // Atualizar lista de conversas
        atualizarListaConversas();
    });
    
    // Receber notifica√ß√£o de que uma conversa foi exclu√≠da
    socket.on('conversation_deleted', (data) => {
        // Remover do estado local
        if (window.conversas) {
            window.conversas = window.conversas.filter(c => c.id !== data.conversation_id);
        }
        
        if (window.conversations && window.conversations[data.conversation_id]) {
            delete window.conversations[data.conversation_id];
        }
        
        // Se for a conversa atual, voltar para a tela inicial
        if (window.conversaAtual && window.conversaAtual.id === data.conversation_id) {
            window.conversaAtual = null;
            mostrarTelaInicial();
        }
        
        // Atualizar lista de conversas
        atualizarListaConversas();
    });
}

/**
 * Entra na sala de uma conversa espec√≠fica para receber atualiza√ß√µes
 */
export function entrarNaSalaDeConversa(conversationId) {
    if (!socket || !isConnected) return;
    
    // Sair de todas as salas anteriores primeiro
    if (window.salaAtual) {
        socket.emit('leave_conversation', { conversation_id: window.salaAtual });
    }
    
    // Entrar na nova sala
    socket.emit('join_conversation', { conversation_id: conversationId });
    window.salaAtual = conversationId;
}

/**
 * Atualiza o buffer de uma conversa com um novo fragmento de mensagem
 */
function atualizarBufferDaConversa(conversationId, fragmento) {
    if (!window.conversations) window.conversations = {};
    if (!window.conversations[conversationId]) {
        window.conversations[conversationId] = {
            data: { 
                id: conversationId,
                title: "Nova Conversa",
                messages: []
            },
            streaming: true,
            currentResponse: fragmento,
            pendingUpdates: true
        };
    } else {
        window.conversations[conversationId].currentResponse += fragmento;
        window.conversations[conversationId].pendingUpdates = true;
    }
}

/**
 * Atualiza a mensagem que est√° sendo exibida em stream na conversa atual
 * Vers√£o melhorada para garantir que o streaming seja exibido em tempo real
 */
function atualizarMensagemEmStream(fragmento) {
    const chatContainer = document.querySelector('.chat-container');
    if (!chatContainer) return;
    
    // Encontrar a mensagem em streaming atual ou criar uma nova
    let streamingMessage = chatContainer.querySelector('.streaming-message');
    
    // Se n√£o existir, criar uma nova mensagem para streaming
    if (!streamingMessage) {
        streamingMessage = document.createElement('div');
        streamingMessage.className = 'message assistant streaming-message';
        streamingMessage.innerHTML = '<div class="message-content"></div>';
        chatContainer.appendChild(streamingMessage);
    }
    
    // Atualizar a mensagem com o novo fragmento
    const messageContent = streamingMessage.querySelector('.message-content');
    if (messageContent) {
        // Inicializar currentResponse se n√£o existir
        const conversation = window.conversations[window.conversaAtual.id];
        if (!conversation.currentResponse) conversation.currentResponse = '';
        
        // Acumular o fragmento
        conversation.currentResponse += fragmento;
        
        // Usar importa√ß√£o din√¢mica para renderizar markdown em tempo real
        try {
            const { renderStreamingMessage } = window.messageRenderer || { renderStreamingMessage: (text) => text };
            const renderedHtml = renderStreamingMessage(conversation.currentResponse);
            messageContent.innerHTML = renderedHtml;
        } catch (error) {
            // Fallback para texto simples se houver erro
            messageContent.innerHTML = `<p>${conversation.currentResponse}</p>`;
        }
        
        // Melhorar blocos de c√≥digo quando apropriado
        setTimeout(() => {
            if (typeof window.melhorarBlocosCodigo === 'function') {
                window.melhorarBlocosCodigo(streamingMessage);
            }
        }, 100);
        
        // Rolar para o final
        chatContainer.scrollTop = chatContainer.scrollHeight;
    }
}

/**
 * Marcar uma conversa para ser recarregada quando a aba ficar vis√≠vel
 */
function marcarParaRecarregar(conversationId) {
    localStorage.setItem('conversaParaRecarregar', conversationId);
}

/**
 * Verificar se h√° conversas para recarregar quando a aba ficar vis√≠vel
 */
function verificarRecarregamento() {
    const conversaParaRecarregar = localStorage.getItem('conversaParaRecarregar');
    if (conversaParaRecarregar) {
        localStorage.removeItem('conversaParaRecarregar');
        if (window.conversaAtual && window.conversaAtual.id === conversaParaRecarregar) {
            carregarConversa(conversaParaRecarregar);
        }
    }
}

/**
 * Gera um ID de sess√£o √∫nico
 */
function gerarSessionId() {
    return Date.now().toString() + '-' + Math.random().toString(36).substr(2, 9);
}

// Configurar o listener de visibilidade para sincroniza√ß√£o
document.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'visible') {
        verificarRecarregamento();
        
        // Recarregar lista de conversas
        atualizarListaConversas();
        
        // Se houver uma conversa aberta com atualiza√ß√µes pendentes, recarreg√°-la
        if (window.conversaAtual && window.conversations && 
            window.conversations[window.conversaAtual.id] && 
            window.conversations[window.conversaAtual.id].pendingUpdates) {
            
            carregarConversa(window.conversaAtual.id);
            window.conversations[window.conversaAtual.id].pendingUpdates = false;
        }
    }
});

// Fun√ß√µes importadas de outros m√≥dulos que ser√£o definidas no escopo global
const melhorarBlocosCodigo = window.melhorarBlocosCodigo || function() {};
const carregarConversa = window.carregarConversa || function() {};
const atualizarListaConversas = window.atualizarListaConversas || function() {};
const mostrarTelaInicial = window.mostrarTelaInicial || function() {};


Conte√∫do de chatUI.js:
import { escapeHTML } from './chatUtils.js';
import { renderMessage } from '../messageRenderer.js';
import { melhorarBlocosCodigo } from './chatUtils.js';

export function iniciarChat(welcomeScreen, chatContainer, inputContainer) {
    welcomeScreen.style.display = 'none';
    chatContainer.style.display = 'block';
    inputContainer.style.display = 'block';
    chatContainer.innerHTML = '';
    
    // Verificar se h√° uma conversa carregada na estrutura global
    const conversationId = window.conversaAtual?.id;
    if (conversationId && window.conversations && window.conversations[conversationId]) {
        // console.log(`[DEBUG] Iniciando chat para conversa: ${conversationId}`);
    } else {
        // console.log('[DEBUG] Iniciando chat sem conversa ativa');
    }
}

export function mostrarTelaInicial(welcomeScreen, chatContainer, inputContainer, welcomeInput, chatInput) {
    welcomeScreen.style.display = 'flex';
    chatContainer.style.display = 'none';
    inputContainer.style.display = 'none';
    welcomeInput.value = '';
    if (chatInput) chatInput.value = '';
    
    // Limpar refer√™ncia da conversa atual para evitar mistura de contextos
    window.conversaAtual = null;
    // console.log('[DEBUG] Retornando para tela inicial, conversa atual limpa');
    
    // Remover qualquer listener de scroll
    if (chatContainer._scrollListener) {
        chatContainer.removeEventListener('scroll', chatContainer._scrollListener);
        chatContainer._scrollListener = null;
    }
}

export function adicionarMensagem(chatContainer, texto, tipo) {
    // Verificar se o cont√™iner de chat existe
    if (!chatContainer) {
        console.error('[ERRO] Cont√™iner de chat n√£o encontrado ao adicionar mensagem');
        return;
    }
    
    // Verificar se h√° uma conversa ativa
    const conversationId = window.conversaAtual?.id;
    if (!conversationId) {
        console.warn('[AVISO] Tentando adicionar mensagem sem conversa ativa');
    } else {
        // console.log(`[DEBUG] Adicionando mensagem √† conversa ${conversationId}, tipo: ${tipo}`);
    }
    
    const mensagemDiv = document.createElement('div');
    mensagemDiv.className = `message ${tipo}`;
    
    // Associar ID da conversa para garantir isolamento
    if (conversationId) {
        mensagemDiv.dataset.conversationId = conversationId;
    }
    
    // Processamento de Markdown para mensagens do assistente
    let conteudoHtml;
    if (tipo === 'assistant') {
        // Aplicar formata√ß√£o Markdown apenas nas mensagens do assistente
        conteudoHtml = renderMessage(texto);
        // console.log('[DEBUG] HTML renderizado (primeiros 150 caracteres):', conteudoHtml.substring(0, 150) + '...');
    } else {
        // Para mensagens do usu√°rio, apenas escape HTML e quebras de linha
        conteudoHtml = `<p>${escapeHTML(texto).replace(/\n/g, '<br>')}</p>`;
    }
    
    const conteudo = `
        <div class="message-content">${conteudoHtml}</div>
        <div class="message-actions">
            <button class="action-btn copy-btn" onclick="window.copiarMensagem(this)" title="Copiar mensagem">
                <i class="fas fa-copy"></i>
            </button>
            ${tipo === 'assistant' ? `
                <button class="action-btn regenerate-btn" onclick="window.regenerarResposta(this)" title="Regenerar resposta">
                    <i class="fas fa-redo"></i>
                </button>
            ` : ''}
        </div>
    `;
    
    mensagemDiv.innerHTML = conteudo;
    chatContainer.appendChild(mensagemDiv);
    chatContainer.scrollTop = chatContainer.scrollHeight;
    
    // Melhorar os blocos de c√≥digo imediatamente ap√≥s adicionar a mensagem
    if (tipo === 'assistant') {
        setTimeout(() => {
            // console.log('[DEBUG] Aplicando melhorias aos blocos de c√≥digo...');
            melhorarBlocosCodigo();
        }, 0);
    }
}

export function mostrarCarregamento(chatContainer) {
    // Verificar se o cont√™iner de chat existe
    if (!chatContainer) {
        console.error('[ERRO] Cont√™iner de chat n√£o encontrado ao mostrar carregamento');
        return document.createElement('div'); // Retorna um div vazio como fallback
    }
    
    const loadingDiv = document.createElement('div');
    loadingDiv.className = 'loading message assistant';
    
    // Associar ID da conversa para garantir isolamento
    const conversationId = window.conversaAtual?.id;
    if (conversationId) {
        loadingDiv.dataset.conversationId = conversationId;
        // console.log(`[DEBUG] Mostrando carregamento para conversa: ${conversationId}`);
    } else {
        console.warn('[AVISO] Mostrando carregamento sem conversa ativa');
    }
    
    loadingDiv.innerHTML = `
        <span></span>
        <span></span>
        <span></span>
    `;
    chatContainer.appendChild(loadingDiv);
    chatContainer.scrollTop = chatContainer.scrollHeight;
    return loadingDiv;
}

// Adicionar CSS para os novos elementos
const style = document.createElement('style');
style.textContent = `
.loading-indicator {
    padding: 1rem;
    text-align: center;
    color: var(--text-secondary);
    font-style: italic;
}

.error-message {
    padding: 1rem;
    text-align: center;
    color: var(--error);
    font-weight: bold;
}

.empty-message {
    padding: 1rem;
    text-align: center;
    color: var(--text-secondary);
    font-style: italic;
}
`;
document.head.appendChild(style);


Conte√∫do de chatUtils.js:
export function escapeHTML(text) {
    const div = document.createElement('div');
    div.innerText = text;
    return div.innerHTML;
}

export function copiarMensagem(button) {
    console.log('[DEBUG] Copiando mensagem...');
    const mensagem = button.closest('.message').querySelector('.message-content').innerText; // Usando innerText para preservar formata√ß√£o
    navigator.clipboard.writeText(mensagem)
        .then(() => {
            button.innerHTML = '<i class="fas fa-check"></i>';
            button.classList.add('copied');
            
            setTimeout(() => {
                button.innerHTML = '<i class="fas fa-copy"></i>';
                button.classList.remove('copied');
            }, 2000);
        })
        .catch(err => {
            console.error('[ERRO] Falha ao copiar mensagem:', err);
            alert('N√£o foi poss√≠vel copiar a mensagem. Por favor, tente novamente.');
        });
}

export function regenerarResposta(button) {
    console.log('[DEBUG] Regenerando resposta...');
    const mensagemOriginal = button.closest('.message').previousElementSibling;
    if (!mensagemOriginal) {
        console.error('Mensagem original n√£o encontrada');
        return;
    }

    const texto = mensagemOriginal.querySelector('.message-content').textContent;
    const chatInput = document.getElementById('chat-input');
    const chatForm = document.getElementById('chat-form');

    if (chatInput && chatForm) {
        chatInput.value = texto;
        chatForm.dispatchEvent(new Event('submit'));
    } else {
        console.error('Elementos do formul√°rio n√£o encontrados');
    }
}

export function copiarCodigo(button) {
    console.log('[DEBUG] Copiando c√≥digo...');
    const codeContainer = button.closest('.code-container');
    if (!codeContainer) {
        console.error('[ERRO] Container de c√≥digo n√£o encontrado');
        return;
    }
    
    const codeBlock = codeContainer.querySelector('.code-block code') || codeContainer.querySelector('code');
    if (!codeBlock) {
        console.error('[ERRO] Bloco de c√≥digo n√£o encontrado');
        return;
    }
    
    const code = codeBlock.textContent
        .replace(/&lt;/g, '<')
        .replace(/&gt;/g, '>')
        .replace(/&amp;/g, '&');
    
    navigator.clipboard.writeText(code)
        .then(() => {
            button.innerHTML = '<i class="fas fa-check"></i>';
            button.classList.add('copied');
            
            setTimeout(() => {
                button.innerHTML = '<i class="fas fa-copy"></i>';
                button.classList.remove('copied');
            }, 2000);
        })
        .catch(err => {
            console.error('[ERRO] Falha ao copiar c√≥digo:', err);
            alert('N√£o foi poss√≠vel copiar o c√≥digo. Por favor, tente novamente.');
        });
}

/**
 * Adiciona barras de t√≠tulos e bot√µes de copiar aos blocos de c√≥digo
 */
export function melhorarBlocosCodigo() {
    // console.log('[DEBUG] Melhorando blocos de c√≥digo...');
    const temaAtual = document.documentElement.getAttribute('data-theme');
    // console.log('[DEBUG] Tema atual:', temaAtual);
    
    document.querySelectorAll('pre code').forEach((block) => {
        // Evitar duplica√ß√£o se j√° tiver sido processado
        if (block.parentElement.parentElement.classList.contains('code-container')) {
            return;
        }

        // Extrair a linguagem da classe - melhorada para capturar apenas letras/n√∫meros
        // console.log('[DEBUG] Classes do bloco:', block.className);
        const langMatch = block.className.match(/language-([a-zA-Z0-9]+)/i);
        let language = langMatch ? langMatch[1] : 'plaintext';
        
        // Capitalizar apenas a primeira letra para exibi√ß√£o mais elegante
        language = language.charAt(0).toUpperCase() + language.slice(1).toLowerCase();
        // console.log('[DEBUG] Linguagem detectada:', language);

        // Criar container principal
        const container = document.createElement('div');
        container.className = 'code-container';

        // Criar barra de t√≠tulo com bot√£o de copiar
        const header = document.createElement('div');
        header.className = 'code-header';
        header.innerHTML = `
            <span class="language-label">${language.toUpperCase()}</span>
            <button class="code-copy-btn" title="Copiar c√≥digo">
                <i class="fas fa-copy"></i>
            </button>
        `;

        // Adicionar manipulador de eventos para o bot√£o de copiar
        const copyBtn = header.querySelector('.code-copy-btn');
        copyBtn.addEventListener('click', function() {
            copiarCodigo(this);
        });

        // Reorganizar a estrutura do DOM
        const pre = block.parentElement;
        pre.classList.add('code-block');
        
        // Inserir elementos na DOM
        const parent = pre.parentElement;
        parent.insertBefore(container, pre);
        container.appendChild(header);
        container.appendChild(pre);
        
        // Reaplicar o highlight para garantir que o destaque de sintaxe seja mantido
        hljs.highlightElement(block);
    });
}

// Expor fun√ß√£o globalmente para o onclick
window.copiarCodigo = copiarCodigo;
window.melhorarBlocosCodigo = melhorarBlocosCodigo;


Conte√∫do de chat.js:

import { 
    iniciarChat,
    mostrarTelaInicial,
    adicionarMensagem,
    mostrarCarregamento
} from './chat/chatUI.js';

import {
    enviarMensagem,
    interromperResposta,
    atualizarBotoes
} from './chat/chatActions.js';

import {
    carregarConversa,
    atualizarListaConversas,
    criarNovaConversa,
    adicionarMensagemAoHistorico,
    renomearConversa,
    excluirConversa
} from './chat/chatStorage.js';

import {
    copiarCodigo,
    copiarMensagem,
    melhorarBlocosCodigo
} from './chat/chatUtils.js';

import {
    inicializarSync,
    entrarNaSalaDeConversa
} from './chat/chatSync.js';

// Estado global das conversas
window.conversations = {};

// Fun√ß√£o para inicializar uma conversa na estrutura global
window.inicializarConversa = function(conversationId) {
    if (!window.conversations[conversationId]) {
        // Inicializando estrutura para conversa
        window.conversations[conversationId] = {
            data: { 
                id: conversationId,
                title: "Nova Conversa",
                messages: []
            },
            streaming: false,
            currentResponse: '',
            eventSource: null,
            abortController: null,
            pendingUpdates: false
        };
    }
    return window.conversations[conversationId];
};

// Fun√ß√£o para copiar c√≥digo - melhorada para preservar indenta√ß√£o
window.copiarCodigo = function(button) {
    const codeContainer = button.closest('.code-container');
    const codeBlock = codeContainer.querySelector('.code-block code');
    const code = codeBlock.innerText; // Usa innerText para preservar indenta√ß√£o
    
    navigator.clipboard.writeText(code).then(() => {
        // Feedback visual
        button.innerHTML = '<i class="fas fa-check"></i>';
        button.classList.add('copied');
        
        // Restaurar o √≠cone original ap√≥s 2 segundos
        setTimeout(() => {
            button.innerHTML = '<i class="fas fa-copy"></i>';
            button.classList.remove('copied');
        }, 2000);
    }).catch(err => {
        console.error('Erro ao copiar c√≥digo:', err);
        alert('N√£o foi poss√≠vel copiar o c√≥digo. Por favor, tente novamente.');
    });
};

// Fun√ß√£o para copiar mensagem completa
window.copiarMensagem = function(button) {
    const messageDiv = button.closest('.message');
    const content = messageDiv.querySelector('.message-content').innerText; // Tamb√©m usa innerText aqui
    
    navigator.clipboard.writeText(content).then(() => {
        // Feedback visual
        button.innerHTML = '<i class="fas fa-check"></i>';
        button.classList.add('copied');
        
        // Restaurar o √≠cone original ap√≥s 2 segundos
        setTimeout(() => {
            button.innerHTML = '<i class="fas fa-copy"></i>';
            button.classList.remove('copied');
        }, 2000);
    }).catch(err => {
        console.error('Erro ao copiar mensagem:', err);
        alert('N√£o foi poss√≠vel copiar a mensagem. Por favor, tente novamente.');
    });
};

// Fun√ß√£o para regenerar resposta (√∫til para depura√ß√£o)
window.regenerarResposta = function(button) {
    if (!window.conversaAtual) {
        console.error('[ERRO] Sem conversa ativa para regenerar resposta');
        return;
    }
    
    const messageDiv = button.closest('.message');
    const conversationId = window.conversaAtual.id;
    
    // Encontrar a √∫ltima mensagem do usu√°rio na conversa atual
    if (window.conversations[conversationId] && 
        window.conversations[conversationId].data && 
        window.conversations[conversationId].data.messages) {
        
        const messages = window.conversations[conversationId].data.messages;
        let lastUserMessage = null;
        
        // Percorrer mensagens de tr√°s para frente para encontrar a √∫ltima do usu√°rio
        for (let i = messages.length - 1; i >= 0; i--) {
            if (messages[i].role === 'user') {
                lastUserMessage = messages[i].content;
                break;
            }
        }
        
        if (lastUserMessage) {
            // Remover a mensagem atual da IA
            messageDiv.remove();
            
            // Re-enviar a mensagem do usu√°rio para gerar nova resposta
            const chatContainer = document.querySelector('.chat-container');
            const sendBtn = document.getElementById('send-btn');
            const stopBtn = document.getElementById('stop-btn');
            const dummyInput = { value: '' };
            
            enviarMensagem(lastUserMessage, dummyInput, chatContainer, sendBtn, stopBtn);
        } else {
            console.error('[ERRO] N√£o foi poss√≠vel encontrar a √∫ltima mensagem do usu√°rio');
        }
    }
};

// Inicializar a sincroniza√ß√£o via WebSockets quando o DOM estiver carregado
document.addEventListener('DOMContentLoaded', () => {
    // Inicializar WebSocket para sincroniza√ß√£o entre abas
    inicializarSync();
    
    // Configurar o listener de visibilidade para sincroniza√ß√£o
    document.addEventListener('visibilitychange', () => {
        if (document.visibilityState === 'visible') {
            // Atualizar a lista de conversas quando a aba ficar vis√≠vel
            atualizarListaConversas();
        }
    });
});

export {
    iniciarChat,
    mostrarTelaInicial,
    adicionarMensagem,
    enviarMensagem,
    interromperResposta,
    carregarConversa,
    atualizarListaConversas,
    criarNovaConversa,
    adicionarMensagemAoHistorico,
    renomearConversa,
    excluirConversa,
    melhorarBlocosCodigo,
    atualizarBotoes,
    inicializarSync,
    entrarNaSalaDeConversa
};


Conte√∫do de commandMenu.js:
export function initCommandMenu(inputElement, menuElement, commands = ['/youtube', '/google', '/help', '/settings']) {
    let selectedIndex = -1;
    const items = [];

    // Garantir que o menu esteja no body para evitar problemas de posicionamento
    if (menuElement.parentNode !== document.body) {
        menuElement.parentNode.removeChild(menuElement);
        document.body.appendChild(menuElement);
    }

    // Resetar estilos inline que podem estar causando problemas
    menuElement.style.display = 'none';
    menuElement.style.visibility = 'hidden';
    menuElement.style.position = 'absolute';
    menuElement.classList.remove('visible');

    if (!inputElement || !menuElement) {
        console.error('Elementos de input ou menu n√£o foram fornecidos.');
        return;
    }

    function updateMenuPosition() {
        requestAnimationFrame(() => {
            const rect = inputElement.getBoundingClientRect();
            const menuHeight = menuElement.offsetHeight || 200;
            const spaceAbove = rect.top - menuHeight;

            // Se n√£o tem espa√ßo acima, abre pra baixo
            if (spaceAbove < 10) {
                menuElement.style.bottom = 'auto';
                menuElement.style.top = `${rect.bottom + 5}px`;
            } else {
                menuElement.style.top = 'auto';
                menuElement.style.bottom = `${window.innerHeight - rect.top + 5}px`;
            }
            
            menuElement.style.left = `${rect.left}px`;
            menuElement.style.width = `${rect.width}px`;
            menuElement.style.visibility = 'visible';
        });
    }

    // Quando o usu√°rio digitar, verifica se o texto come√ßa com '/'
    inputElement.addEventListener('input', function() {
        const text = this.value;
        
        if (text.startsWith('/')) {
            const filtered = commands.filter(cmd => 
                cmd.toLowerCase().startsWith(text.toLowerCase())
            );

            if (filtered.length > 0) {
                menuElement.innerHTML = filtered.map(cmd => `
                    <div class="command-item" role="option" data-command="${cmd}">
                        <div>
                            <div class="command-text">${cmd}</div>
                            <div class="command-description">Descri√ß√£o para ${cmd}</div>
                        </div>
                    </div>
                `).join('');

                menuElement.querySelectorAll('.command-item').forEach(item => {
                    item.addEventListener('click', function(e) {
                        e.stopPropagation();
                        const command = this.dataset.command;
                        inputElement.value = command + ' ';
                        menuElement.classList.remove('visible');
                        menuElement.style.display = 'none';
                        inputElement.focus();
                        inputElement.selectionStart = inputElement.selectionEnd = inputElement.value.length;
                    });
                });

                menuElement.style.display = 'block';
                menuElement.classList.add('visible');
                updateMenuPosition();
            } else {
                menuElement.classList.remove('visible');
                menuElement.style.display = 'none';
            }
        } else {
            menuElement.classList.remove('visible');
            menuElement.style.display = 'none';
        }
    });

    // Atualizar posi√ß√£o do menu ao rolar a p√°gina
    window.addEventListener('scroll', () => {
        if (menuElement.classList.contains('visible')) {
            updateMenuPosition();
        }
    });

    // Atualizar posi√ß√£o do menu ao redimensionar a janela
    window.addEventListener('resize', () => {
        if (menuElement.classList.contains('visible')) {
            updateMenuPosition();
        }
    });

    function updateSelectedItem() {
        items.forEach((item, index) => {
            item.classList.toggle('selected', index === selectedIndex);
            item.setAttribute('aria-selected', index === selectedIndex);
        });
        
        if (items[selectedIndex]) {
            items[selectedIndex].scrollIntoView({
                block: 'nearest',
                behavior: 'auto'
            });
        }
    }

    inputElement.addEventListener('keydown', function(e) {
        if (!menuElement.classList.contains('visible')) return;

        switch(e.key) {
            case 'Escape':
                e.preventDefault();
                menuElement.classList.remove('visible');
                menuElement.style.display = 'none';
                selectedIndex = -1;
                updateSelectedItem();
                break;
                
            case 'Enter':
                e.preventDefault();
                if (selectedIndex > -1 && items[selectedIndex]) {
                    items[selectedIndex].click();
                }
                break;

            case 'ArrowDown':
                e.preventDefault();
                selectedIndex = Math.min(selectedIndex + 1, items.length - 1);
                if (selectedIndex === -1 && items.length > 0) selectedIndex = 0;
                updateSelectedItem();
                break;
                
            case 'ArrowUp':
                e.preventDefault();
                selectedIndex = Math.max(selectedIndex - 1, -1);
                updateSelectedItem();
                break;
        }
    });

    // Observer para atualizar itens quando o conte√∫do do menu mudar
    const observer = new MutationObserver(() => {
        items.length = 0;
        menuElement.querySelectorAll('.command-item').forEach(item => items.push(item));
        selectedIndex = -1;
        updateSelectedItem();
    });

    observer.observe(menuElement, { childList: true, subtree: true });

    // Clicar fora fecha o menu
    document.addEventListener('click', (e) => {
        if (!menuElement.contains(e.target) && e.target !== inputElement) {
            menuElement.classList.remove('visible');
            menuElement.style.display = 'none';
        }
    });
}


Conte√∫do de events.js:
// Importa√ß√µes necess√°rias
import { toggleTheme } from './theme.js';
import { toggleSidebar } from './sidebar.js';
import { configureTextarea } from './textarea.js';

export function configureEventListeners() {
    const themeToggle = document.querySelector('.theme-toggle');
    const modelSelect = document.querySelector('.model-select');
    const sidebarToggle = document.querySelector('.sidebar-toggle');
    const headerSidebarToggle = document.querySelector('.header-sidebar-toggle');

    // Event Listeners
    themeToggle?.addEventListener('click', toggleTheme);
    sidebarToggle?.addEventListener('click', toggleSidebar);
    headerSidebarToggle?.addEventListener('click', toggleSidebar);

    modelSelect?.addEventListener('change', (e) => {
        window.currentModel = e.target.value;
    });

    // Configurar textareas
    configureTextarea(document.querySelector('#chat-input'));
    configureTextarea(document.querySelector('#welcome-input'));
}

Conte√∫do de init.js:
import { initializeTheme } from './theme.js';
import { configureEventListeners } from './events.js';

document.addEventListener('DOMContentLoaded', () => {
    initializeTheme();
    configureEventListeners();
});

Conte√∫do de main.js:

import './init.js';
import { 
    iniciarChat,
    mostrarTelaInicial,
    adicionarMensagem,
    melhorarBlocosCodigo,
    inicializarSync
} from './chat.js';
import { enviarMensagem, interromperResposta } from './chat/chatActions.js';
import { 
    carregarConversa,
    atualizarListaConversas,
    criarNovaConversa,
    adicionarMensagemAoHistorico,
    renomearConversa,
    excluirConversa
} from './chat/chatStorage.js';
import { initializeInputBar, destroyInputBar } from './modules/inputBar.js';
import { copiarMensagem, regenerarResposta } from './chat/chatUtils.js';

// Estado global
window.currentModel = 'gemma2:2b';
window.conversas = [];
window.conversaAtual = null;
window.conversations = {}; // Nova estrutura global para mapear conversas por ID
window.copiarMensagem = copiarMensagem;
window.regenerarResposta = regenerarResposta;

let welcomeBar = null;
let chatBar = null;

document.addEventListener('DOMContentLoaded', () => {
    // Inicializar WebSocket para sincroniza√ß√£o entre abas
    inicializarSync();
    
    const welcomeForm = document.getElementById('welcome-form');
    const chatForm = document.getElementById('chat-form');
    const chatContainer = document.querySelector('.chat-container');
    const welcomeInput = document.getElementById('welcome-input');
    const chatInput = document.getElementById('chat-input');
    const sendBtn = document.getElementById('send-btn');
    const stopBtn = document.getElementById('stop-btn');
    const newChatBtn = document.querySelector('.new-chat-btn');

    // Configurar menu de comando usando o m√≥dulo criado
    const welcomeCommandMenu = document.getElementById('command-menu');
    const chatCommandMenu = document.getElementById('chat-command-menu');

    const COMMANDS = [
        { command: '/youtube', description: 'Processar v√≠deo do YouTube' },
        { command: '/salvar', description: 'Salvar conversa atual' },
        { command: '/historico', description: 'Ver hist√≥rico completo' },
        { command: '/config', description: 'Abrir configura√ß√µes' }
    ];

    // Prevenir submit padr√£o dos formul√°rios
    document.querySelectorAll('form').forEach(form => {
        form.addEventListener('submit', (e) => {
            e.preventDefault();
        });
    });

    // Inicializar barra de entrada da tela inicial
    if (welcomeInput && welcomeCommandMenu) {
        welcomeBar = initializeInputBar(
            welcomeInput, 
            welcomeCommandMenu, 
            COMMANDS.map(c => c.command)
        );

        welcomeForm?.addEventListener('submit', async (e) => {
            e.preventDefault();
            const message = welcomeInput.value.trim();
            if (!message) return;
            
            // Criar nova conversa se n√£o existir
            if (!window.conversaAtual) {
                criarNovaConversa();
            }

            // Limpar barra de boas-vindas antes de trocar de tela
            welcomeBar?.destroy();

            iniciarChat(
                document.querySelector('.welcome-screen'),
                chatContainer,
                document.querySelector('.input-container')
            );
            
            await enviarMensagem(message, welcomeInput, chatContainer, sendBtn, stopBtn);
            atualizarListaConversas(); // Atualizar hist√≥rico ap√≥s enviar mensagem
            
            // Adicionar barras de t√≠tulo aos blocos de c√≥digo
            setTimeout(() => {
                melhorarBlocosCodigo();
            }, 100);
        });
    }

    // Inicializar barra de entrada do chat
    if (chatInput && chatCommandMenu) {
        chatBar = initializeInputBar(
            chatInput, 
            chatCommandMenu, 
            COMMANDS.map(c => c.command)
        );

        chatForm?.addEventListener('submit', async (e) => {
            e.preventDefault();
            const message = chatInput.value.trim();
            if (!message) return;
            
            // Verificar se h√° uma conversa ativa
            if (!window.conversaAtual) {
                criarNovaConversa();
            }
            
            // Armazenar o ID da conversa atual para garantir que estamos na mesma conversa ap√≥s o streaming
            const currentConversationId = window.conversaAtual.id;
            
            chatBar.clear();
            await enviarMensagem(message, chatInput, chatContainer, sendBtn, stopBtn);
            
            // Verificar se ainda estamos na mesma conversa
            if (window.conversaAtual && window.conversaAtual.id === currentConversationId) {
                atualizarListaConversas(); // Atualizar hist√≥rico ap√≥s enviar mensagem
                
                // Adicionar barras de t√≠tulo aos blocos de c√≥digo
                setTimeout(() => {
                    melhorarBlocosCodigo();
                }, 100);
            }
        });
    }

    // Configurar bot√£o de nova conversa
    newChatBtn?.addEventListener('click', () => {
        if (window.conversaAtual) {
            atualizarListaConversas(); // Atualizar hist√≥rico antes de criar nova conversa
        }
        
        // Limpar barra do chat antes de trocar de tela
        chatBar?.destroy();
        
        window.conversaAtual = null;
        mostrarTelaInicial(
            document.querySelector('.welcome-screen'),
            chatContainer,
            document.querySelector('.input-container'),
            welcomeInput,
            chatInput
        );

        // Reinicializar barra de boas-vindas
        if (welcomeInput && welcomeCommandMenu) {
            welcomeBar = initializeInputBar(
                welcomeInput, 
                welcomeCommandMenu, 
                COMMANDS.map(c => c.command)
            );
        }
    });

    // Configurar bot√£o de parar resposta
    stopBtn?.addEventListener('click', () => {
        interromperResposta();
    });

    // Inicializar lista de conversas
    atualizarListaConversas();

    // Eventos para gerenciamento de estado isolado
    window.addEventListener('conversaCarregada', (e) => {
        if (e.detail && e.detail.id) {
            // Conversa carregada
        }
    });
    
    window.addEventListener('conversaAtualizada', (e) => {
        if (e.detail && e.detail.id) {
            // Conversa atualizada
        }
        atualizarListaConversas();
    });
    
    window.addEventListener('mensagemEnviada', (e) => {
        if (window.conversaAtual) {
            // Mensagem enviada 
        }
    });
    
    // Processar blocos de c√≥digo j√° existentes (ao carregar uma conversa)
    melhorarBlocosCodigo();
    
    // Observar mudan√ßas no DOM para processar novos blocos de c√≥digo
    const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
            if (mutation.addedNodes.length > 0) {
                setTimeout(() => {
                    melhorarBlocosCodigo();
                }, 100);
            }
        });
    });
    
    observer.observe(chatContainer, { childList: true, subtree: true });
    
    // Configurar o listener de visibilidade para sincroniza√ß√£o
    document.addEventListener('visibilitychange', () => {
        if (document.visibilityState === 'visible') {
            // Atualizar o estado quando a aba ficar vis√≠vel
            atualizarListaConversas();
            
            // Se houver uma conversa atual, verificar se h√° atualiza√ß√µes pendentes
            if (window.conversaAtual && window.conversations[window.conversaAtual.id]?.pendingUpdates) {
                carregarConversa(window.conversaAtual.id);
                window.conversations[window.conversaAtual.id].pendingUpdates = false;
            }
        }
    });
});

// Expor fun√ß√µes globalmente
window.carregarConversa = carregarConversa;
window.criarNovaConversa = criarNovaConversa;
window.adicionarMensagemAoHistorico = adicionarMensagemAoHistorico;
window.interromperResposta = interromperResposta;
window.renomearConversa = renomearConversa;
window.excluirConversa = excluirConversa;
window.melhorarBlocosCodigo = melhorarBlocosCodigo;



Conte√∫do de messageRenderer.js:

/**
 * Renderiza uma mensagem formatada com Markdown usando marked.js e highlight.js
 * @param {string} text - Texto em formato Markdown
 * @returns {string} HTML formatado
 */
export function renderMessage(text) {
    // Verificar depend√™ncias
    if (typeof marked === 'undefined') {
        console.error('[ERRO] marked.js n√£o est√° definido.');
        return `<p>${text}</p>`;
    }
    if (typeof hljs === 'undefined') {
        console.error('[ERRO] highlight.js n√£o est√° definido.');
        return `<pre>${text}</pre>`;
    }

    // Capturar ID da conversa atual para contexto
    const conversationId = window.conversaAtual?.id;

    // Configurar highlight.js
    hljs.configure({
        cssSelector: 'pre code',
        ignoreUnescapedHTML: true
    });

    // Configurar marked.js com destaque simples
    marked.setOptions({
        gfm: true,               // Suporte a GitHub Flavored Markdown
        breaks: false,           // N√£o converter \n em <br>
        pedantic: false,         // N√£o ser extremamente r√≠gido
        sanitize: false,         // N√£o sanitizar (usaremos DOMPurify)
        smartLists: true,        // Listas inteligentes
        smartypants: false,      // N√£o usar tipografia avan√ßada
        highlight: function(code, lang) {
            try {
                // Identificar a linguagem correta ou usar plaintext como fallback
                const language = lang && hljs.getLanguage(lang) ? lang : 'plaintext';
                
                // Aplicar highlight.js ao c√≥digo
                const highlighted = hljs.highlight(code, { language }).value;
                
                // Retornar o c√≥digo com a classe de linguagem para detec√ß√£o posterior
                return `<code class="language-${language} hljs">${highlighted}</code>`;
            } catch (error) {
                return code;
            }
        }
    });

    try {
        // Verificar DOMPurify
        if (typeof DOMPurify === 'undefined') {
            return marked.parse(text);
        }

        // Configurar sanitiza√ß√£o para preservar a estrutura do c√≥digo
        const allowedTags = ['pre', 'code', 'span', 'div', 'p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
                            'ul', 'ol', 'li', 'blockquote', 'a', 'strong', 'em', 'del', 'table',
                            'thead', 'tbody', 'tr', 'th', 'td', 'hr', 'br', 'img'];

        const allowedAttributes = {
            'code': ['class'],  // Permitir classes em <code> para detectar a linguagem
            'span': ['class'],
            'a': ['href', 'target', 'rel'],
            'img': ['src', 'alt'],
            // Adicionar data-* attributes para manter isolamento de contexto
            '*': ['data-conversation-id']
        };

        // Parsear o Markdown
        const htmlContent = marked.parse(text);

        // Sanitizar o HTML preservando a estrutura
        const finalHtml = DOMPurify.sanitize(htmlContent, {
            ALLOWED_TAGS: allowedTags,
            ALLOWED_ATTR: allowedAttributes,
            ADD_ATTR: ['target', 'data-conversation-id'],
        });
        
        return finalHtml;
    } catch (error) {
        return `<p>${text.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</p>`;
    }
}

/**
 * Renderiza incrementalmente mensagens durante o streaming
 * Vers√£o otimizada para atualiza√ß√µes r√°pidas durante streaming
 */
export function renderStreamingMessage(text) {
    // Para streaming, usamos uma vers√£o simplificada para melhor performance
    try {
        if (typeof marked === 'undefined' || typeof DOMPurify === 'undefined') {
            return `<p>${text.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</p>`;
        }
        
        // Sanitizar o texto em Markdown
        const htmlContent = marked.parse(text);
        const finalHtml = DOMPurify.sanitize(htmlContent, {
            ALLOWED_TAGS: ['p', 'strong', 'em', 'code', 'pre', 'br', 'ul', 'ol', 'li'],
        });
        
        return finalHtml;
    } catch (error) {
        // Fallback seguro se houver erro
        return `<p>${text.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</p>`;
    }
}


Conte√∫do de commandHandler.js:
(function() { // IIFE para isolamento de escopo
    const COMMAND_PREFIX = '/';
    const COMMANDS = ['/youtube', '/google', '/help', '/settings'];
    
    class CommandMenu {
        constructor() {
            this.input = document.getElementById('chat-input');
            if (!this.input) {
                console.error('[Erro] Elemento #chat-input n√£o encontrado');
                return;
            }
            
            this.initMenu();
            this.setupListeners();
        }

        initMenu() {
            this.menu = document.createElement('div');
            this.menu.className = 'cmd-menu';
            document.body.appendChild(this.menu);
        }

        setupListeners() {
            this.input.addEventListener('input', () => this.handleInput());
            document.addEventListener('click', (e) => this.handleOutsideClick(e));
            this.menu.addEventListener('click', (e) => this.handleMenuClick(e));
        }

        handleInput() {
            const text = this.input.value.trim();
            
            if (text.startsWith(COMMAND_PREFIX)) {
                this.positionMenu();
                this.filterCommands(text);
            } else {
                this.hideMenu();
            }
        }

        positionMenu() {
            const rect = this.input.getBoundingClientRect();
            this.menu.style.top = `${rect.bottom + window.scrollY}px`;
            this.menu.style.left = `${rect.left}px`;
            this.menu.classList.add('visible');
        }

        filterCommands(text) {
            this.menu.innerHTML = COMMANDS
                .filter(cmd => cmd.toLowerCase().startsWith(text.toLowerCase()))
                .map(cmd => `<div class="cmd-item" data-cmd="${cmd}">${cmd}</div>`)
                .join('');
        }

        handleMenuClick(e) {
            const item = e.target.closest('.cmd-item');
            if (item) {
                this.input.value = `${item.dataset.cmd} `;
                this.hideMenu();
                this.input.focus();
            }
        }

        handleOutsideClick(e) {
            if (!this.input.contains(e.target) && !this.menu.contains(e.target)) {
                this.hideMenu();
            }
        }

        hideMenu() {
            this.menu.classList.remove('visible');
        }
    }

    // Inicializa√ß√£o segura ap√≥s DOM carregado
    document.addEventListener('DOMContentLoaded', () => {
        new CommandMenu();
    });
})();


Conte√∫do de inputBar.js:

import { initCommandMenu } from '../commandMenu.js';
import { configureTextarea } from '../textarea.js';

const activeListeners = new WeakMap();

function handleSubmit(e, inputElement) {
    e.preventDefault();
    const message = inputElement.value.trim();
    
    // N√£o enviar se for comando incompleto
    if (message.startsWith('/') && !message.includes(' ')) {
        return;
    }

    if (message) {
        const submitEvent = new CustomEvent('customSubmit', { 
            detail: { message },
            bubbles: true 
        });
        e.target.dispatchEvent(submitEvent);
    }
}

export function initializeInputBar(inputElement, menuElement, commands) {
    if (!inputElement || !menuElement) {
        console.error('Elementos necess√°rios n√£o fornecidos para initializeInputBar');
        return;
    }

    // Limpar listeners antigos se existirem
    destroyInputBar(inputElement);

    // Configurar textarea (autoajuste de altura e eventos)
    configureTextarea(inputElement);

    // Configurar menu de comandos
    initCommandMenu(inputElement, menuElement, commands);

    // Adicionar evento de submit unificado
    const form = inputElement.closest('form');
    if (form) {
        const boundSubmitHandler = (e) => handleSubmit(e, inputElement);
        form.addEventListener('submit', boundSubmitHandler);
        
        // Armazenar refer√™ncia ao listener para limpeza posterior
        activeListeners.set(form, boundSubmitHandler);
    }

    // Adicionar atributos de acessibilidade
    inputElement.setAttribute('aria-label', 'Campo de mensagem');
    inputElement.setAttribute('aria-describedby', 'message-instructions');

    return {
        focus: () => inputElement.focus(),
        clear: () => {
            inputElement.value = '';
            inputElement.style.height = 'auto';
        },
        getValue: () => inputElement.value,
        setValue: (value) => {
            inputElement.value = value;
            inputElement.style.height = 'auto';
            inputElement.style.height = inputElement.scrollHeight + 'px';
        },
        destroy: () => destroyInputBar(inputElement)
    };
}

export function destroyInputBar(inputElement) {
    const form = inputElement.closest('form');
    if (form) {
        // Remover listener espec√≠fico se existir
        const listener = activeListeners.get(form);
        if (listener) {
            form.removeEventListener('submit', listener);
            activeListeners.delete(form);
        }
    }
}


Conte√∫do de sidebar.js:
export function toggleSidebar() {
    const sidebar = document.querySelector('.sidebar');
    const mainContent = document.querySelector('.main-content');
    
    sidebar.classList.toggle('collapsed');
    mainContent.classList.toggle('expanded');
}

Conte√∫do de textarea.js:

export function configureTextarea(textarea) {
    if (!textarea) return;

    textarea.addEventListener('input', function() {
        this.style.height = 'auto';
        this.style.height = (this.scrollHeight) + 'px';
    });

    textarea.addEventListener('keydown', function(e) {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            const form = this.closest('form');
            if (form) {
                const event = new Event('submit', {
                    'bubbles': true,
                    'cancelable': true
                });
                form.dispatchEvent(event);
            }
        }
    });
}


Conte√∫do de theme.js:
// Estado do tema
let currentTheme = 'light';

// Fun√ß√£o para alternar o tema
export function toggleTheme() {
    currentTheme = currentTheme === 'light' ? 'dark' : 'light';
    document.documentElement.setAttribute('data-theme', currentTheme);
    localStorage.setItem('theme', currentTheme);
    
    const themeToggle = document.querySelector('.theme-toggle');
    if (themeToggle) {
        themeToggle.innerHTML = currentTheme === 'light' 
            ? '<i class="fas fa-moon"></i>' 
            : '<i class="fas fa-sun"></i>';
    }
}

// Fun√ß√£o para inicializar o tema
export function initializeTheme() {
    const savedTheme = localStorage.getItem('theme') || 'light';
    if (savedTheme === 'dark') {
        toggleTheme();
    }
}

Conte√∫do de utils.js:
export function escapeHTML(text) {
    const div = document.createElement('div');
    div.innerText = text;
    return div.innerHTML;
}

export function mostrarCarregamento(chatContainer) {
    const loadingDiv = document.createElement('div');
    loadingDiv.className = 'loading message assistant';
    loadingDiv.innerHTML = `
        <span></span>
        <span></span>
        <span></span>
    `;
    chatContainer.appendChild(loadingDiv);
    chatContainer.scrollTop = chatContainer.scrollHeight;
    return loadingDiv;
}

Conte√∫do de index.html:

<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Chat</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;500&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    
    <!-- Bibliotecas para Markdown e Code Highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.0.6/purify.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    
    <!-- Socket.IO para sincroniza√ß√£o em tempo real -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.5/socket.io.min.js"></script>
    
    <!-- CSS do projeto -->
    <link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='css/styles.css') }}">

</head>
<body>
    <div class="container">
        <!-- Barra Lateral -->
        <aside class="sidebar">
            <button class="new-chat-btn">
                <i class="fas fa-plus"></i>
                Novo Chat
            </button>
            <div class="search-box">
                <input type="text" id="search-input" placeholder="Pesquisar conversas...">
            </div>
            <div class="chat-list">
                <!-- Lista de conversas ser√° preenchida via JavaScript -->
            </div>
            <button class="settings-btn">
                <i class="fas fa-cog"></i>
                Configura√ß√µes
            </button>
        </aside>

        <!-- Conte√∫do Principal -->
        <main class="main-content">
            <div class="top-bar">
                <button class="header-sidebar-toggle">
                    <i class="fas fa-bars"></i>
                </button>
                <h1 class="program-name">AI Chat</h1>
                <div class="top-bar-actions">
                    <button class="theme-toggle">
                        <i class="fas fa-moon"></i>
                    </button>
                    <select class="model-select">
                        <option value="gemma2:2b">gemma2:2b</option>
                    </select>
                </div>
            </div>

            <!-- Tela de Boas-vindas -->
            <div class="welcome-screen">
                <h1>Como posso ajudar?</h1>
                <form class="input-box" id="welcome-form">
                    <textarea 
                        id="welcome-input" 
                        placeholder="Digite / para ver os comandos..." 
                        rows="1"
                    ></textarea>
                    <!-- √Årea para o menu de comandos na tela de boas-vindas -->
                    <div id="command-menu" class="command-menu">
                        <div class="command-item" data-command="/youtube">
                            <i class="fas fa-youtube command-icon"></i>
                            <div>
                                <div class="command-text">/youtube</div>
                                <div class="command-description">Resumir v√≠deo do YouTube</div>
                            </div>
                        </div>
                    </div>
                    <button type="submit" class="send-btn">
                        <i class="fas fa-paper-plane"></i>
                    </button>
                </form>
                <div class="quick-actions">
                    <button class="quick-action-btn">
                        <i class="fas fa-lightbulb"></i>
                        Sugerir ideias
                    </button>
                    <button class="quick-action-btn">
                        <i class="fas fa-file-alt"></i>
                        Resumir texto
                    </button>
                    <button class="quick-action-btn">
                        <i class="fas fa-code"></i>
                        Ajuda com c√≥digo
                    </button>
                    <button class="quick-action-btn">
                        <i class="fas fa-question-circle"></i>
                        Tirar d√∫vidas
                    </button>
                </div>
            </div>

            <!-- Container de Chat -->
            <div class="chat-container" style="display: none;">
                <!-- Mensagens ser√£o inseridas aqui -->
            </div>

            <!-- Container de Input -->
            <div class="input-container" style="display: none;">
                <form class="input-box" id="chat-form">
                    <textarea 
                        id="chat-input" 
                        placeholder="Digite / para ver os comandos..." 
                        rows="1"
                    ></textarea>
                    <!-- √Årea para o menu de comandos no chat ativo -->
                    <div id="chat-command-menu" class="command-menu">
                        <div class="command-item" data-command="/youtube">
                            <i class="fas fa-youtube command-icon"></i>
                            <div>
                                <div class="command-text">/youtube</div>
                                <div class="command-description">Resumir v√≠deo do YouTube</div>
                            </div>
                        </div>
                    </div>
                    <button type="submit" class="send-btn" id="send-btn">
                        <i class="fas fa-paper-plane"></i>
                    </button>
                    <button type="button" class="stop-btn" id="stop-btn" style="display: none;">
                        <i class="fas fa-stop"></i>
                    </button>
                </form>
            </div>
        </main>
    </div>

    <!-- Inicializa√ß√£o do highlight.js -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Configurar highlight.js
            hljs.configure({
                ignoreUnescapedHTML: true
            });
            
            // Aplicar highlight.js em todos os blocos de c√≥digo
            document.querySelectorAll('pre code').forEach((block) => {
                hljs.highlightElement(block);
            });
            
            // Expor copiarCodigo globalmente
            window.copiarCodigo = function(button) {
                const codeContainer = button.closest('.code-container');
                const codeBlock = codeContainer.querySelector('.code-block code');
                
                const tempTextarea = document.createElement('textarea');
                tempTextarea.value = codeBlock.innerText
                    .replace(/&lt;/g, '<')
                    .replace(/&gt;/g, '>')
                    .replace(/&amp;/g, '&')
                    .trim();
                
                document.body.appendChild(tempTextarea);
                tempTextarea.select();
                
                try {
                    document.execCommand('copy');
                    button.innerHTML = '<i class="fas fa-check"></i>';
                    button.classList.add('copied');
                    
                    setTimeout(() => {
                        button.innerHTML = '<i class="fas fa-copy"></i>';
                        button.classList.remove('copied');
                    }, 2000);
                } catch (err) {
                    console.error('Erro ao copiar c√≥digo:', err);
                    alert('N√£o foi poss√≠vel copiar o c√≥digo. Por favor, tente novamente.');
                } finally {
                    document.body.removeChild(tempTextarea);
                }
            };
        });
    </script>

    <!-- Scripts do projeto -->
    <script type="module" src="{{ url_for('static', filename='js/theme.js') }}"></script>
    <script type="module" src="{{ url_for('static', filename='js/main.js') }}"></script>
</body>
</html>


Conte√∫do de chat_history.py:
import json
from datetime import datetime
import os

HISTORY_FILE = 'data/chat_history.json'

def ensure_data_directory():
    os.makedirs('data', exist_ok=True)

def get_conversation_history():
    ensure_data_directory()
    try:
        if os.path.exists(HISTORY_FILE):
            with open(HISTORY_FILE, 'r', encoding='utf-8') as f:
                return json.load(f)
        return []
    except json.JSONDecodeError as e:
        print(f"Erro ao carregar hist√≥rico: {str(e)}")
        return []  # Retorna uma lista vazia em caso de erro
    except Exception as e:
        print(f"Erro ao carregar hist√≥rico: {str(e)}")
        return []  # Retorna uma lista vazia em caso de erro

def get_conversation_by_id(conversation_id):
    """Busca uma conversa espec√≠fica pelo ID"""
    conversations = get_conversation_history()
    for conversation in conversations:
        if conversation['id'] == conversation_id:
            return conversation
    return None
  
def save_conversation(message, response, conversation_id=None):
    """
    Salva ou atualiza uma conversa no hist√≥rico.
    Se conversation_id for fornecido, atualiza a conversa existente.
    Caso contr√°rio, cria uma nova conversa.
    """
    ensure_data_directory()
    try:
        # Carrega o hist√≥rico atual
        conversations = get_conversation_history()
        
        if conversation_id:
            # Atualiza conversa existente
            updated = False
            for conversation in conversations:
                if conversation['id'] == conversation_id:
                    conversation['messages'].extend([
                        {'role': 'user', 'content': message},
                        {'role': 'assistant', 'content': response}
                    ])
                    conversation['timestamp'] = datetime.now().isoformat()
                    updated = True
                    break
            
            # Se n√£o encontrou o ID, cria uma nova conversa (backup seguro)
            if not updated:
                conversation_id = str(len(conversations) + 1)
                new_conversation = {
                    'id': conversation_id,
                    'timestamp': datetime.now().isoformat(),
                    'messages': [
                        {'role': 'user', 'content': message},
                        {'role': 'assistant', 'content': response}
                    ]
                }
                conversations.append(new_conversation)
        else:
            # Cria nova conversa
            conversation_id = str(len(conversations) + 1)
            new_conversation = {
                'id': conversation_id,
                'timestamp': datetime.now().isoformat(),
                'messages': [
                    {'role': 'user', 'content': message},
                    {'role': 'assistant', 'content': response}
                ]
            }
            conversations.append(new_conversation)
        
        # Salva as conversas atualizadas
        with open(HISTORY_FILE, 'w', encoding='utf-8') as f:
            json.dump(conversations, f, ensure_ascii=False, indent=2)
        
        return conversation_id
    except Exception as e:
        print(f"Erro ao salvar conversa: {str(e)}")
        return None
 

Conte√∫do de chat_storage.py:

import json
import os
from datetime import datetime

DATA_DIR = "data"
CONVERSATIONS_DIR = os.path.join(DATA_DIR, "conversations")
INDEX_FILE = os.path.join(DATA_DIR, "index.json")

def ensure_directories():
    """Garante que os diret√≥rios necess√°rios existam"""
    os.makedirs(CONVERSATIONS_DIR, exist_ok=True)

def create_new_conversation():
    """Cria uma nova conversa e retorna seu ID"""
    ensure_directories()
    
    conversation_id = str(int(datetime.now().timestamp() * 1000))
    conversation = {
        "id": conversation_id,
        "title": "Nova conversa",
        "timestamp": datetime.now().isoformat(),
        "messages": []
    }
    
    save_conversation(conversation)
    update_index(conversation)
    
    return conversation_id

def save_conversation(conversation):
    """Salva uma conversa em seu arquivo JSON"""
    filename = f"conversation_{conversation['id']}.json"
    filepath = os.path.join(CONVERSATIONS_DIR, filename)
    
    # print(f"[DEBUG] Salvando conversa em: {filepath}")
    
    try:
        with open(filepath, 'w', encoding='utf-8') as f:
            json.dump(conversation, f, ensure_ascii=False, indent=2)
        # print("[DEBUG] Conversa salva com sucesso")
        return True
    except Exception as e:
        print(f"[ERRO] Falha ao salvar conversa: {str(e)}")
        return False

def update_index(conversation):
    """Atualiza o arquivo de √≠ndice com os metadados da conversa"""
    ensure_directories()
    
    # print(f"[DEBUG] Atualizando √≠ndice para conversa: {conversation['id']}")
    
    try:
        with open(INDEX_FILE, 'r', encoding='utf-8') as f:
            index = json.load(f)
    except (FileNotFoundError, json.JSONDecodeError):
        # print("[DEBUG] Arquivo de √≠ndice n√£o encontrado ou inv√°lido, criando novo")
        index = []
    
    entry = {
        "id": conversation["id"],
        "title": conversation.get("title", "Nova conversa"),
        "timestamp": conversation["timestamp"],
        "filename": f"conversation_{conversation['id']}.json"
    }
    
    # Remover entrada antiga se existir
    index = [item for item in index if item["id"] != conversation["id"]]
    index.append(entry)
    index.sort(key=lambda x: x["timestamp"], reverse=True)
    
    try:
        with open(INDEX_FILE, 'w', encoding='utf-8') as f:
            json.dump(index, f, ensure_ascii=False, indent=2)
        # print("[DEBUG] √çndice atualizado com sucesso")
        return True
    except Exception as e:
        print(f"[ERRO] Falha ao atualizar √≠ndice: {str(e)}")
        return False

def get_conversation_by_id(conversation_id):
    """Recupera uma conversa espec√≠fica pelo ID"""
    filename = f"conversation_{conversation_id}.json"
    filepath = os.path.join(CONVERSATIONS_DIR, filename)
    
    # print(f"[DEBUG] Buscando conversa: {conversation_id}")
    
    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            return json.load(f)
    except FileNotFoundError:
        # print(f"[DEBUG] Conversa n√£o encontrada: {conversation_id}")
        return None
    except json.JSONDecodeError:
        print(f"[ERRO] Arquivo de conversa corrompido: {conversation_id}")
        return None
    except Exception as e:
        print(f"[ERRO] Erro ao carregar conversa: {str(e)}")
        return None

def get_conversation_history():
    """Recupera o hist√≥rico de todas as conversas"""
    ensure_directories()
    
    # print("[DEBUG] Carregando hist√≥rico de conversas")
    
    try:
        with open(INDEX_FILE, 'r', encoding='utf-8') as f:
            index = json.load(f)
            
        # Verificar se todos os arquivos ainda existem
        valid_entries = []
        for entry in index:
            filepath = os.path.join(CONVERSATIONS_DIR, entry.get("filename", ""))
            if os.path.exists(filepath):
                valid_entries.append(entry)
            else:
                # print(f"[DEBUG] Arquivo n√£o encontrado para conversa {entry.get('id')}: {filepath}")
                pass
                
        return valid_entries
    except (FileNotFoundError, json.JSONDecodeError):
        # print("[DEBUG] Arquivo de √≠ndice n√£o encontrado ou inv√°lido")
        return []
    except Exception as e:
        print(f"[ERRO] Erro ao carregar hist√≥rico: {str(e)}")
        return []

def add_message_to_conversation(conversation_id, content, role):
    """Adiciona uma mensagem a uma conversa existente"""
    # print(f"[DEBUG] Adicionando mensagem tipo '{role}' √† conversa {conversation_id}")
    
    conversation = get_conversation_by_id(conversation_id)
    
    if not conversation:
        # print(f"[DEBUG] Criando nova conversa para ID: {conversation_id}")
        conversation = {
            "id": conversation_id,
            "title": "Nova conversa",
            "timestamp": datetime.now().isoformat(),
            "messages": []
        }
    
    message = {
        "role": role,
        "content": content,
        "timestamp": datetime.now().isoformat()
    }
    
    conversation["messages"].append(message)
    conversation["timestamp"] = datetime.now().isoformat()
    
    # Definir t√≠tulo automaticamente com base na primeira mensagem do usu√°rio
    if role == "user" and len([m for m in conversation["messages"] if m["role"] == "user"]) == 1:
        conversation["title"] = content[:30] + "..." if len(content) > 30 else content
        # print(f"[DEBUG] T√≠tulo da conversa atualizado para: {conversation['title']}")
    
    save_conversation(conversation)
    update_index(conversation)
    
    return True

def delete_conversation(conversation_id):
    """Exclui uma conversa e sua entrada no √≠ndice"""
    filename = f"conversation_{conversation_id}.json"
    filepath = os.path.join(CONVERSATIONS_DIR, filename)
    
    # print(f"[DEBUG] Tentando excluir conversa: {conversation_id}")
    
    try:
        # Remove o arquivo da conversa se existir
        if os.path.exists(filepath):
            os.remove(filepath)
            # print(f"[DEBUG] Arquivo da conversa removido: {filepath}")
        else:
            # print(f"[DEBUG] Arquivo n√£o encontrado: {filepath}")
            pass
            
        # Remove a entrada do √≠ndice
        try:
            with open(INDEX_FILE, 'r', encoding='utf-8') as f:
                index = json.load(f)
        except (FileNotFoundError, json.JSONDecodeError):
            # print("[DEBUG] Arquivo de √≠ndice n√£o encontrado ou inv√°lido")
            index = []
            
        # Filtra a conversa do √≠ndice
        index = [item for item in index if item["id"] != conversation_id]
        
        # Salva o √≠ndice atualizado
        with open(INDEX_FILE, 'w', encoding='utf-8') as f:
            json.dump(index, f, ensure_ascii=False, indent=2)
        
        # print("[DEBUG] Conversa exclu√≠da com sucesso")
        return True
    except Exception as e:
        print(f"[ERRO] Falha ao excluir conversa: {str(e)}")
        return False

def rename_conversation(conversation_id, new_title):
    """Renomeia uma conversa existente"""
    # print(f"[DEBUG] Tentando renomear conversa {conversation_id} para: {new_title}")
    
    conversation = get_conversation_by_id(conversation_id)
    if not conversation:
        print(f"[ERRO] Conversa {conversation_id} n√£o existe")
        return False
        
    try:
        # Atualiza o t√≠tulo com valida√ß√£o
        new_title = new_title.strip()
        if not new_title or len(new_title) > 100:
            print("[ERRO] T√≠tulo inv√°lido ou muito longo")
            return False
            
        conversation["title"] = new_title
        conversation["timestamp"] = datetime.now().isoformat() # Atualiza timestamp
        
        # print(f"[DEBUG] Novo t√≠tulo salvo: {conversation['title']}")
        
        # Salva as altera√ß√µes
        save_success = save_conversation(conversation)
        if not save_success:
            print("[ERRO] Falha ao salvar conversa")
            return False
            
        index_success = update_index(conversation)
        if not index_success:
            print("[ERRO] Falha ao atualizar √≠ndice")
            return False
        
        # print("[DEBUG] Conversa renomeada com sucesso")
        return True
    except Exception as e:
        print(f"[ERRO] Falha ao renomear conversa: {str(e)}")
        return False


Conte√∫do de text_processor.py:

def split_text(text: str, words_per_chunk: int = 300) -> list[str]:
    """
    Divide um texto em chunks menores baseado no n√∫mero de palavras.
    """
    words = text.split()
    chunks = []
    
    for i in range(0, len(words), words_per_chunk):
        chunk = ' '.join(words[i:i + words_per_chunk])
        chunks.append(chunk)
    
    return chunks

def clean_and_format_text(text: str) -> str:
    """
    Limpa e formata o texto removendo caracteres especiais e formata√ß√£o desnecess√°ria
    """
    import re
    
    # Remove m√∫ltiplos espa√ßos
    text = re.sub(r'\s+', ' ', text)
    # Remove caracteres especiais mantendo pontua√ß√£o b√°sica
    text = re.sub(r'[^\w\s.,!?-]', '', text)
    # Remove espa√ßos antes de pontua√ß√£o
    text = re.sub(r'\s+([.,!?])', r'\1', text)
    
    return text.strip()



Conte√∫do de __init__.py:

# Este arquivo pode ficar vazio


Conte√∫do de youtube_handler.py:

import os
import json
import yt_dlp
import re
from typing import Optional, Dict, Any, Tuple

class YoutubeHandler:
    def __init__(self, download_path: str = "./temp"):
        self.download_path = download_path
        if not os.path.exists(download_path):
            os.makedirs(download_path)

    def download_subtitles(self, video_url: str) -> Tuple[Optional[str], Optional[str]]:
        """
        Baixa as legendas de um v√≠deo do YouTube, priorizando PT-BR
        Retorna uma tupla (caminho_do_arquivo, t√≠tulo_do_v√≠deo)
        """
        ydl_opts = {
            'writesubtitles': True,
            'writeautomaticsub': True,  # Aceita legendas autom√°ticas como fallback
            'subtitleslangs': ['pt-BR', 'pt', 'en'],  # Prioridade: PT-BR > PT > EN
            'skip_download': True,
            'outtmpl': os.path.join(self.download_path, '%(id)s.%(ext)s'),
            'quiet': True
        }

        try:
            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                info = ydl.extract_info(video_url, download=True)
                video_id = info['id']
                video_title = info.get('title', 'V√≠deo sem t√≠tulo')
                
                # Procura primeiro por legendas em PT-BR
                pt_br_files = ['.pt-BR.vtt', '.pt_BR.vtt', '.pt-br.vtt']
                for suffix in pt_br_files:
                    file = os.path.join(self.download_path, f"{video_id}{suffix}")
                    if os.path.exists(file):
                        print(f"Encontradas legendas em PT-BR: {file}")
                        return file, video_title
                
                # Procura por legendas em PT
                pt_files = ['.pt.vtt', '.pt-PT.vtt']
                for suffix in pt_files:
                    file = os.path.join(self.download_path, f"{video_id}{suffix}")
                    if os.path.exists(file):
                        print(f"Encontradas legendas em PT: {file}")
                        return file, video_title
                
                # Fallback para EN
                en_file = os.path.join(self.download_path, f"{video_id}.en.vtt")
                if os.path.exists(en_file):
                    print("Usando legendas em ingl√™s como fallback")
                    return en_file, video_title
                
                # √öltimo recurso: qualquer arquivo .vtt dispon√≠vel
                for file in os.listdir(self.download_path):
                    if file.startswith(video_id) and file.endswith('.vtt'):
                        print(f"Usando legendas dispon√≠veis: {file}")
                        return os.path.join(self.download_path, file), video_title
                
                return None, None
                
        except Exception as e:
            print(f"Erro ao baixar legendas: {str(e)}")
            return None, None

    def clean_subtitles(self, subtitle_file: str) -> Optional[str]:
        """
        Limpa as legendas removendo timestamps, formata√ß√£o e repeti√ß√µes
        Retorna o texto limpo
        """
        if not os.path.exists(subtitle_file):
            return None

        try:
            # Tenta diferentes codifica√ß√µes
            content = None
            for encoding in ['utf-8', 'latin1', 'cp1252']:
                try:
                    with open(subtitle_file, 'r', encoding=encoding) as f:
                        content = f.read()
                        break
                except UnicodeDecodeError:
                    continue
            
            if content is None:
                raise Exception("N√£o foi poss√≠vel ler o arquivo com nenhuma codifica√ß√£o suportada")

            # Remove cabe√ßalho WEBVTT e metadados
            content = re.sub(r'WEBVTT.*\n', '', content)
            content = re.sub(r'Kind:.*\n', '', content)
            content = re.sub(r'Language:.*\n', '', content)
            
            # Remove timestamps e n√∫meros de sequ√™ncia
            content = re.sub(r'\d{2}:\d{2}:\d{2}[\.,]\d{3} --> .*\n', '', content)
            content = re.sub(r'^\d+$', '', content, flags=re.MULTILINE)
            
            # Remove tags HTML e formata√ß√£o
            content = re.sub(r'<[^>]+>', '', content)
            content = re.sub(r'{\\an\d}', '', content)
            content = re.sub(r'\[.*?\]', '', content)
            
            # Processa linha por linha removendo duplicatas
            seen_lines = set()
            cleaned_lines = []
            
            for line in content.split('\n'):
                line = line.strip()
                if line and not line.startswith(('<', '{', '[')) and line not in seen_lines:
                    cleaned_lines.append(line)
                    seen_lines.add(line)

            # Remove arquivo tempor√°rio
            os.remove(subtitle_file)
            
            # Junta as linhas com espa√ßo e remove espa√ßos extras
            return ' '.join(cleaned_lines).strip()
            
        except Exception as e:
            print(f"Erro ao limpar legendas: {str(e)}")
            return None



==========================================
Estrutura de pastas:
==========================================
persistencia-memoria-html
    app.py
    atualiza-git.bat
    codigo_completo.txt
    data
        conversations
            conversation_1741174682053.json
            conversation_1741737581748.json
        index.json
    DevMenu.bat
    DOCUMENTACAO.md
    init_eventlet.py
    README.md
    requirements.txt
    start_server.bat
    static
        css
            base
                reset.css
                typography.css
                variables.css
            components
                buttons.css
                code-highlight.css
                command-menu.css
                forms.css
                messages.css
            layout
                container.css
                main-content.css
                sidebar.css
            styles.css
            themes
                dark-theme.css
                light-theme.css
            variables.css
        js
            chat
                chatActions.js
                chatStorage.js
                chatSync.js
                chatUI.js
                chatUtils.js
            chat.js
            commandMenu.js
            events.js
            init.js
            main.js
            messageRenderer.js
            modules
                commandHandler.js
                inputBar.js
            sidebar.js
            textarea.js
            theme.js
            utils.js
    templates
        index.html
    utils
        chat_history.py
        chat_storage.py
        text_processor.py
        __init__.py
    youtube_handler.py
